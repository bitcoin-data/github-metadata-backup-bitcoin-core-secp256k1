{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129",
    "id": 1004746668,
    "node_id": "PR_kwDOAP4Jqs474zes",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1129.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1129.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/90e360acc2511f313964e394005bafb377b4f191",
    "number": 1129,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "ElligatorSwift + integrated x-only DH",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Builds on top of #979, #1118. Replaces #982.\r\n\r\nThis implements encoding of curve points using the ElligatorSwift algorithm, using 4 new API calls:\r\n* `secp256k1_ellswift_encode`, which converts a public key to a 64-byte pseudorandom encoding.\r\n* `secp256k1_ellswift_decode`, the reverse operation to convert back to normal public keys.\r\n* `secp256k1_ellswift_create`, which can be seen as a combination of `secp256k1_ec_pubkey_create` + `secp256k1_ellswift_encode`, but is somewhat safer.\r\n* `secp256k1_ellswift_xdh`, which implements x-only Diffie-Hellman directly on top of 64-byte encoded public keys, and more efficiently than decoding + invoking normal ECDH.\r\n\r\nThe scheme matches that of the SwiftEC paper (https://eprint.iacr.org/2022/759), with two changes (remapping undefined inputs, and encoding the Y parity in the u/t values themselves rather than in a separate bit). To decode an ElligatorSwift 64-byte encoded public key:\r\n* Interpret the encoding as two field elements $(u, t)$ in big-endian 32-byte encoding each, reducing modulo $p$.\r\n* If $u=0$, let $u=1$ instead.\r\n* If $t=0$, let $t=1$ instead.\r\n* If $u^3 + 7 + t^2 = 0$, let $t = 2t$ instead.\r\n* Let $X = \\dfrac{u^3 + 7 - t^2}{2t}$.\r\n* Let $Y = \\dfrac{X + t}{\\sqrt{-3}u}$.\r\n* Let $x$ be the first of $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ which is on the curve (at least one will be).\r\n* Let $y$ be the corresponding Y coordinate, with the same parity as (the original) $t$.\r\n* Return $(x,y)$.\r\n\r\nThis is significantly faster than the Elligator Squared code in #982.\r\n\r\nRelevant benchmark (AMD Ryzen 5950X, GCC 12.2.0, default config options; frequency fixed at 2.80 GHz):\r\n\r\n```\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)    \r\n\r\nec_keygen                     ,    27.9       ,    28.0       ,    28.0    \r\necdh                          ,    53.9       ,    53.9       ,    54.0    \r\nellswift_encode               ,    24.5       ,    24.5       ,    24.6    \r\nellswift_decode               ,    11.1       ,    11.1       ,    11.1    \r\nellswift_keygen               ,    52.5       ,    52.5       ,    52.6    \r\nellswift_ecdh                 ,    57.9       ,    58.0       ,    58.0    \r\n```",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/4",
      "html_url": "https://github.com/bitcoin-core/secp256k1/milestone/4",
      "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/4/labels",
      "id": 9136996,
      "node_id": "MI_kwDOAP4Jqs4Ai2tk",
      "number": 4,
      "state": "open",
      "title": "0.3.3 (or 0.4.0)",
      "description": "One month before 26.0 feature freeze https://github.com/bitcoin/bitcoin/issues/27758",
      "creator": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 1,
      "closed_issues": 8,
      "created_at": "2023-03-08T22:07:52Z",
      "updated_at": "2023-06-21T14:37:00Z",
      "due_on": "2023-09-01T07:00:00Z"
    },
    "created_at": "2022-07-21T22:21:50Z",
    "updated_at": "2023-06-27T20:10:21Z",
    "closed_at": "2023-06-21T14:37:00Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-06-21T14:37:00Z",
    "merge_commit_sha": "705ce7ed8c1557a31e1bfc99be06082c5098d9f5",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:202206_ellswift_dh",
      "ref": "202206_ellswift_dh",
      "sha": "90e360acc2511f313964e394005bafb377b4f191",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 11649,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-07-09T03:46:04Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2023-05-11T11:08:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "30574f22ea0d158a0414323f8c350fa8ddcabd30",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 962,
        "stargazers_count": 1802,
        "watchers_count": 1802,
        "size": 10374,
        "default_branch": "master",
        "open_issues_count": 145,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T01:00:35Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-08-01T08:52:35Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 2028,
    "deletions": 17,
    "changed_files": 19,
    "commits": 9,
    "review_comments": 198,
    "comments": 28
  },
  "events": [
    {
      "event": "reviewed",
      "id": 1047553401,
      "node_id": "PRR_kwDOAP4Jqs4-cGV5",
      "url": null,
      "actor": null,
      "commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "(just skimming)\r\n\r\nDo you think there's a nice way to avoid code duplication between `divsteps` and `posdivsteps`?",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1047553401",
      "submitted_at": "2022-07-22T08:28:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "commented",
      "id": 1192543515,
      "node_id": "IC_kwDOAP4Jqs5HFMUb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1192543515",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-22T12:54:11Z",
      "updated_at": "2022-07-22T12:54:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random Re posdivsteps see #979 which this PR is based on.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1192543515",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 7046301521,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAGj_gdR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7046301521",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-22T12:54:12Z"
    },
    {
      "event": "subscribed",
      "id": 7046301531,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAGj_gdb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7046301531",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-22T12:54:12Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-22T15:43:47Z",
      "updated_at": "2022-07-22T15:43:47Z",
      "source": {
        "issue": {
          "id": 1043863646,
          "node_id": "PR_kwDOABII584uDOCP",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23432",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23432/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23432/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23432/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23432",
          "number": 23432,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: CKey encode/decode to elligator-swift",
          "body": "This PR adds the ability to encode `CPubKey` objects to their pseudorandom elligator-swift representation. Depends on https://github.com/bitcoin-core/secp256k1/pull/1129.\r\n\r\nThe first 2 commits enable the availability of that upstream code and will be removed once https://github.com/bitcoin-core/secp256k1/pull/1129 is merged. Only last 3 commits need review here.",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 29,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23432",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23432",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23432.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23432.patch"
          },
          "closed_at": "2023-04-18T00:39:36Z",
          "created_at": "2021-11-03T17:14:42Z",
          "updated_at": "2023-04-18T00:39:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-22T19:53:37Z",
      "updated_at": "2022-07-22T19:53:37Z",
      "source": {
        "issue": {
          "id": 1059245454,
          "node_id": "PR_kwDOABII584uzo7R",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23561",
          "number": 23561,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Handshake prerequisites",
          "body": "Depends on #25361 for some constants, and on https://github.com/bitcoin-core/secp256k1/pull/1129 for ellswift integrated XDH but can be reviewed independently. Only the last 5 commits belong to this PR.\r\n\r\nThis PR adds xonly [ECDH](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#Initial_handshake) and [HKDF](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#keys-and-session-id-derivation) key derivation code for BIP324. Unit, bench and fuzz tests are included.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 31,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23561",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23561",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23561.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23561.patch"
          },
          "closed_at": "2023-04-18T08:50:23Z",
          "created_at": "2021-11-20T22:50:38Z",
          "updated_at": "2023-04-18T08:50:23Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1195896191,
      "node_id": "IC_kwDOAP4Jqs5HR-1_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1195896191",
      "actor": {
        "login": "paulmillr",
        "id": 574696,
        "node_id": "MDQ6VXNlcjU3NDY5Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/574696?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/paulmillr",
        "html_url": "https://github.com/paulmillr",
        "followers_url": "https://api.github.com/users/paulmillr/followers",
        "following_url": "https://api.github.com/users/paulmillr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/paulmillr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/paulmillr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/paulmillr/subscriptions",
        "organizations_url": "https://api.github.com/users/paulmillr/orgs",
        "repos_url": "https://api.github.com/users/paulmillr/repos",
        "events_url": "https://api.github.com/users/paulmillr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/paulmillr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-26T19:32:54Z",
      "updated_at": "2022-07-26T19:32:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "Looks awesome! Wanted to clarify this bit, for implementors of EllSwift in other languages / for standardization purpose.\r\n\r\n>Inputs (u,t) where u=0, t=0, or u^2+t^3+7=0, are remapped to other finite points, rather than outputting infinity.\r\n\r\nTo which points exactly? It's not immediately obvious from the code.",
      "user": {
        "login": "paulmillr",
        "id": 574696,
        "node_id": "MDQ6VXNlcjU3NDY5Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/574696?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/paulmillr",
        "html_url": "https://github.com/paulmillr",
        "followers_url": "https://api.github.com/users/paulmillr/followers",
        "following_url": "https://api.github.com/users/paulmillr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/paulmillr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/paulmillr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/paulmillr/subscriptions",
        "organizations_url": "https://api.github.com/users/paulmillr/orgs",
        "repos_url": "https://api.github.com/users/paulmillr/repos",
        "events_url": "https://api.github.com/users/paulmillr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/paulmillr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1195896191",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "commented",
      "id": 1195898081,
      "node_id": "IC_kwDOAP4Jqs5HR_Th",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1195898081",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-26T19:35:06Z",
      "updated_at": "2022-12-25T18:36:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "@paulmillr They are remapped as follows:\r\n* If $t=0$, set $t=1$ instead\r\n* If $u=0$, set $u=1$ instead\r\n* If $u^2+t^3+B=0$, set $t=2t$ instead\r\n* Run the normal algorithm\r\n\r\n(for applicable odd-ordered curves with A=0, this covers all otherwise unmapped points, but this remapping doesn't work for every ellswift-compatible curve).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1195898081",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 7067639584,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAGlQ58g",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7067639584",
      "actor": {
        "login": "paulmillr",
        "id": 574696,
        "node_id": "MDQ6VXNlcjU3NDY5Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/574696?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/paulmillr",
        "html_url": "https://github.com/paulmillr",
        "followers_url": "https://api.github.com/users/paulmillr/followers",
        "following_url": "https://api.github.com/users/paulmillr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/paulmillr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/paulmillr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/paulmillr/subscriptions",
        "organizations_url": "https://api.github.com/users/paulmillr/orgs",
        "repos_url": "https://api.github.com/users/paulmillr/repos",
        "events_url": "https://api.github.com/users/paulmillr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/paulmillr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-26T19:35:07Z"
    },
    {
      "event": "subscribed",
      "id": 7067639590,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAGlQ58m",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7067639590",
      "actor": {
        "login": "paulmillr",
        "id": 574696,
        "node_id": "MDQ6VXNlcjU3NDY5Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/574696?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/paulmillr",
        "html_url": "https://github.com/paulmillr",
        "followers_url": "https://api.github.com/users/paulmillr/followers",
        "following_url": "https://api.github.com/users/paulmillr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/paulmillr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/paulmillr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/paulmillr/subscriptions",
        "organizations_url": "https://api.github.com/users/paulmillr/orgs",
        "repos_url": "https://api.github.com/users/paulmillr/repos",
        "events_url": "https://api.github.com/users/paulmillr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/paulmillr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-26T19:35:07Z"
    },
    {
      "event": "reviewed",
      "id": 1054240770,
      "node_id": "PRR_kwDOAP4Jqs4-1nAC",
      "url": null,
      "actor": null,
      "commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1054240770",
      "submitted_at": "2022-07-28T14:51:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-12T04:27:55Z",
      "updated_at": "2022-09-12T04:27:55Z",
      "source": {
        "issue": {
          "id": 1115148146,
          "node_id": "PR_kwDOGZuyOM4xn3l9",
          "url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/6",
          "repository_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci",
          "labels_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/6/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/6/comments",
          "events_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/6/events",
          "html_url": "https://github.com/dhruv/bitcoin-core-ci/pull/6",
          "number": 6,
          "state": "open",
          "state_reason": null,
          "title": "#23432 bip324-ellsq",
          "body": "This PR adds the ability to encode `CPubKey` objects to their pseudorandom elligator-swift representation. Depends on https://github.com/bitcoin-core/secp256k1/pull/1129.\r\n\r\nThe first 2 commits enable the availability of that upstream code and will be removed once https://github.com/bitcoin-core/secp256k1/pull/1129 is merged.",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/pulls/6",
            "html_url": "https://github.com/dhruv/bitcoin-core-ci/pull/6",
            "diff_url": "https://github.com/dhruv/bitcoin-core-ci/pull/6.diff",
            "patch_url": "https://github.com/dhruv/bitcoin-core-ci/pull/6.patch"
          },
          "created_at": "2022-01-26T15:25:39Z",
          "updated_at": "2023-03-20T22:40:35Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-12T04:34:52Z",
      "updated_at": "2022-09-12T04:34:52Z",
      "source": {
        "issue": {
          "id": 1058039709,
          "node_id": "PR_kwDOGZuyOM4uvz2Z",
          "url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/3",
          "repository_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci",
          "labels_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/3/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/3/comments",
          "events_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/issues/3/events",
          "html_url": "https://github.com/dhruv/bitcoin-core-ci/pull/3",
          "number": 3,
          "state": "closed",
          "state_reason": null,
          "title": "#23561 bip324-handshake",
          "body": "Depends on anagram #25361 for some constants, and on https://github.com/bitcoin-core/secp256k1/pull/1129 for ellswift integrated XDH but can be reviewed independently. Only the last 5 commits belong to this PR.\r\n\r\nThis PR adds xonly [ECDH](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#Initial_handshake) and [HKDF](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#keys-and-session-id-derivation) key derivation code for BIP324. Unit, bench and fuzz tests are included.\r\n\r\nNote: The HKDF `salt` and `info` values are changed from the last published draft and will be updated in the overhaul.",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/pulls/3",
            "html_url": "https://github.com/dhruv/bitcoin-core-ci/pull/3",
            "diff_url": "https://github.com/dhruv/bitcoin-core-ci/pull/3.diff",
            "patch_url": "https://github.com/dhruv/bitcoin-core-ci/pull/3.patch"
          },
          "closed_at": "2023-01-13T21:15:04Z",
          "created_at": "2021-11-19T01:44:28Z",
          "updated_at": "2023-01-13T21:15:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7406784938,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAG5epGq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7406784938",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-16T23:16:25Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T19:20:48Z",
      "updated_at": "2022-10-03T19:20:48Z",
      "source": {
        "issue": {
          "id": 1096473924,
          "node_id": "PR_kwDOABII584wqtsr",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24005",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24005/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24005/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24005/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24005",
          "number": 24005,
          "state": "closed",
          "state_reason": null,
          "title": "test: add python implementation of Elligator swift",
          "body": "Built on top of https://github.com/bitcoin/bitcoin/pull/26222.\r\n\r\nThis PR introduces Elligator swift encoding and decoding in the functional test framework. It's used in #24748 for writing p2p encryption tests.",
          "user": {
            "login": "stratospher",
            "id": 44024636,
            "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
            "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/stratospher",
            "html_url": "https://github.com/stratospher",
            "followers_url": "https://api.github.com/users/stratospher/followers",
            "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
            "organizations_url": "https://api.github.com/users/stratospher/orgs",
            "repos_url": "https://api.github.com/users/stratospher/repos",
            "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/stratospher/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24005",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24005",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24005.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24005.patch"
          },
          "closed_at": "2023-06-30T18:31:03Z",
          "created_at": "2022-01-07T16:33:19Z",
          "updated_at": "2023-06-30T18:31:04Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7527661941,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHArwF1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7527661941",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-05T18:48:55Z"
    },
    {
      "event": "commented",
      "id": 1268818293,
      "node_id": "IC_kwDOAP4Jqs5LoKF1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1268818293",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-05T18:49:18Z",
      "updated_at": "2022-10-05T18:49:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added test vectors.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1268818293",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7715953983,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHL6B0_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7715953983",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-01T18:13:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7718698667,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHMEf6r",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7718698667",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-02T02:17:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7718743773,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHMEq7d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7718743773",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-02T02:26:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7728532621,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHMqAyN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7728532621",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T02:50:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7736278373,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHNHj1l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7736278373",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T22:21:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7744016013,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHNlE6N",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7744016013",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T21:08:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7744170595,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHNlqpj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7744170595",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T21:45:54Z"
    },
    {
      "event": "commented",
      "id": 1304364878,
      "node_id": "IC_kwDOAP4Jqs5NvwdO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1304364878",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-05T01:06:32Z",
      "updated_at": "2022-11-05T01:06:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've made a number of improvements:\r\n* Addressed comments so far\r\n* Added test vectors that are verified against the paper author's Sage code (https://github.com/Jchavezsaab/SwiftEC).\r\n* Documented the algorithms line-by-line\r\n* Renamed functions to better match the paper's names.\r\n* Split up the commits\r\n* A few small performance optimizations\r\n* Factored out helper functions for checking if an X coordinate is on the curve (directly, and when given as a fraction).\r\n\r\nI think it's ready for more review.\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1304364878",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7744817010,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHNoIdy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7744817010",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-05T03:16:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7796920695,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHQu5F3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7796920695",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-12T15:11:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7800040073,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHQ6yqJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7800040073",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-14T03:21:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7800383643,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHQ8Gib",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7800383643",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-14T04:54:24Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-18T05:19:00Z",
      "updated_at": "2022-11-18T05:19:00Z",
      "source": {
        "issue": {
          "id": 1167366626,
          "node_id": "PR_kwDOABII5840WLLa",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
          "number": 24545,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Enable v2 P2P encrypted transport",
          "body": "This PR brings together all other BIP324 PRs and enables v2 encrypted P2P transport.\r\n\r\nBuilds on top of PRs: #25361, #23233, #23561, #23432. It looks like there's a lot of commits, but **only the last 12 commits belong in this PR**. The rest will be merged with upstream PRs.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).\r\n\r\nBIP324 is [here](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\r\n\r\n### Running a v2 node\r\n#### Get the code\r\n```\r\ngit remote add bip324 git@github.com:dhruv/bitcoin.git\r\ngit fetch bip324\r\ngit checkout bip324/bip324-enable\r\n```\r\n\r\n#### Build for your OS\r\n\r\nFollow the appropriate instructions [here](https://github.com/bitcoin/bitcoin/blob/master/doc/README.md)\r\n\r\n#### Run the node\r\n\r\n```\r\nsrc/bitcoind -conf=CONFIG_FILE -v2transport=1\r\n```\r\n\r\n#### Connect with a friend's v2 node\r\n```\r\nsrc/bitcoin-cli -conf=CONFIG_FILE addnode \"FRIEND_IP:FRIEND_PORT\" \"add\" true\r\n```\r\nThe last parameter(`p2p_v2:true`) signals to your node that the peer is running a v2 supportive client and we should attempt to make an encrypted P2P connection (you're simulating the `NODE_P2P_V2` service flag advertisement manually). Should that fail however (say because the peer told you mistakenly, lied, etc.), this code will downgrade the connection to unencrypted v1 transport.\r\n\r\n### Things you are helpful to test\r\n\r\n* If your friend's node is a v2 node, you can see with wireshark that the bytes are pseudorandom (the easiest way to confirm this is that with a v1 connection, wireshark will tell you it has detected a Bitcoin connection and it'll even parse out the metadata like message type, etc; with v2, wireshark has no idea -- of course that _could_ be because wireshark does simply not know v2, but it is because the bytestream is pseudorandom)\r\n* Compare the v2 encrypted session id exposed via `getpeerinfo` as `v2_session_id` with your friend.\r\n* Add another peer that is actually v1, but try `addnode` still indicating v2 support. You should see with wireshark that after a failed attempt at a v2 handshake, the connection is downgraded to unencrypted v1 and wireshark can parse it.\r\n\r\nI've been told there are v2 nodes running at (happy to update the list as more people run persistent v2 nodes; message me and I'll add it here):\r\n```\r\nbe.anyone.eu.org\r\nrp7k2go3s5lyj3fnj6zn62ktarlrsft2ohlsxkyd7v3e3idqyptvread.onion:8333\r\njdcoysubtxazi7dketpyb5rnjorvxad4onftveohash2pdwkgw4bvnqd.onion:8333\r\nxci6cphki2pdb5qe7axzrcxcxabkbm24z4zlv2hn4ziy6grquqco2kyd.onion:8333\r\nslvtesfgg3mkksqqzh67al4sq6dx3rhlzqepa4ny7jonzuckg6msf3id.onion:8333\r\ngifm4fnj3vua664xhgeanx5fnpco3txkqy4amr4txbfsciiyrkxpf2qd.onion:8333\r\n300:5ecb:6b8a:d837::3:8333\r\n300:5ecb:6b8a:d837::a6d6:8333\r\n2001:470:1f1a:365::2:8333\r\n2001:470:1f1b:365:aa20:66ff:fe3f:1909:8333\r\n184.74.240.157:8533\r\n95.179.145.232:8333\r\n```",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 47,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24545",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24545.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24545.patch"
          },
          "closed_at": "2023-05-06T11:14:46Z",
          "created_at": "2022-03-12T18:43:06Z",
          "updated_at": "2023-05-06T11:14:46Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8017003730,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHd2cTS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8017003730",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-12T18:09:11Z"
    },
    {
      "event": "commented",
      "id": 1346977939,
      "node_id": "IC_kwDOAP4Jqs5QSUCT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1346977939",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-12T18:09:27Z",
      "updated_at": "2022-12-12T18:09:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on updated #979.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1346977939",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8105655834,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHjIn4a",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8105655834",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-23T19:54:37Z"
    },
    {
      "event": "commented",
      "id": 1364276918,
      "node_id": "IC_kwDOAP4Jqs5RUTa2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1364276918",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-23T19:55:28Z",
      "updated_at": "2022-12-23T19:55:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added an explanation of the algorithm and its relation to the paper, in `doc/ellswift.md`. I've also changed some of the code to better match the algorithm as described in that document (I found some simplifications while writing it).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1364276918",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8105672354,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHjIr6i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8105672354",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-23T20:00:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8116929543,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHjzoQH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8116929543",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-27T18:12:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8117635362,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHj2Uki",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8117635362",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-27T21:35:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8122793044,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHkJ_xU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8122793044",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-28T19:18:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8367933180,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHyxIb8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8367933180",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-26T21:14:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8367950937,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAHyxMxZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8367950937",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-26T21:16:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8642306476,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIDHyGs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8642306476",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T20:15:13Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T21:45:09Z",
      "updated_at": "2023-03-01T21:45:09Z",
      "source": {
        "issue": {
          "id": 1605708896,
          "node_id": "PR_kwDOAP4Jqs5LEiLv",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1217",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1217/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1217/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1217/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1217",
          "number": 1217,
          "state": "closed",
          "state_reason": null,
          "title": "Add secp256k1_fe_add_int function",
          "body": "Suggested here: https://github.com/bitcoin-core/secp256k1/pull/1118#discussion_r1067131562\r\n\r\nThis adds a new field function secp256k1_fe_add_int which is equivalent to secp256k1_fe_set_int + secp256k1_fe_add, which is a pattern that occurs a few times, and uses a needlessly convoluted computation for an absolutely trivial effect (incrementing one limb variable). Existing PRs like #1118 and #1129 add more ways this function would be useful.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1217",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1217",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1217.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1217.patch"
          },
          "closed_at": "2023-03-07T14:08:21Z",
          "created_at": "2023-03-01T21:45:09Z",
          "updated_at": "2023-04-20T17:53:08Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8686629863,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIFw3Pn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8686629863",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T14:40:17Z"
    },
    {
      "event": "commented",
      "id": 1458292616,
      "node_id": "IC_kwDOAP4Jqs5W68eI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1458292616",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T14:41:23Z",
      "updated_at": "2023-03-07T14:41:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on #1217, making use of the new `secp256k1_fe_add_int`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1458292616",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8963039561,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIWPSFJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8963039561",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T11:22:34Z"
    },
    {
      "event": "commented",
      "id": 1501710955,
      "node_id": "IC_kwDOAP4Jqs5Zgkpr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1501710955",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T11:24:21Z",
      "updated_at": "2023-04-10T11:24:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased after merge of #1118, also consistently applying the convention from #1252.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1501710955",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "milestoned",
      "id": 8964822913,
      "node_id": "MIE_lADOAP4Jqs5OUBcRzwAAAAIWWFeB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8964822913",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T15:45:35Z",
      "milestone": {
        "title": "0.3.2 (or 0.4.0)"
      }
    },
    {
      "event": "unsubscribed",
      "id": 8965044672,
      "node_id": "UE_lADOAP4Jqs5OUBcRzwAAAAIWW7nA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8965044672",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T16:10:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9024735148,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIZ6oes",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9024735148",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-17T13:46:40Z"
    },
    {
      "event": "commented",
      "id": 1511385290,
      "node_id": "IC_kwDOAP4Jqs5aFejK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1511385290",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-17T13:47:08Z",
      "updated_at": "2023-04-17T13:47:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased, and added to CMakeLists.txt.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1511385290",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-17T22:26:56Z",
      "updated_at": "2023-04-17T22:26:56Z",
      "source": {
        "issue": {
          "id": 1672049864,
          "node_id": "PR_kwDOABII585OhhEz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27479",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27479/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27479/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27479/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27479",
          "number": 27479,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: ElligatorSwift integrations",
          "body": "This replaces #23432 and part of #23561.\r\n\r\nThis PR introduces all of the ElligatorSwift-related changes (libsecp256k1 updates, generation, decoding, ECDH, tests, fuzzing, benchmarks) needed for BIP324.\r\n\r\nElligatorSwift is a special 64-byte encoding format for public keys introduced in libsecp256k1 in https://github.com/bitcoin-core/secp256k1/pull/1129. It has the property that *every* 64-byte array is a valid encoding for some public key, and every key has approximately $2^{256}$ encodings. Furthermore, it is possible to efficiently generate a uniformly random encoding for a given public key or private key. This is used for the key exchange phase in BIP324, to achieve a byte stream that is entirely pseudorandom, even before the shared encryption key is established.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27479",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27479",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27479.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27479.patch"
          },
          "closed_at": "2023-06-26T21:08:40Z",
          "created_at": "2023-04-17T22:17:40Z",
          "updated_at": "2023-06-26T21:08:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1396905813,
      "node_id": "PRR_kwDOAP4Jqs5TQxdV",
      "url": null,
      "actor": null,
      "commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "PR looks good! I checked that the implementation matches the algorithm description in the comments and BIP 324, but I did not read the markdown description of the algorithm in detail nor did I compare it with the paper.\r\n\r\nI also created a code [coverage report](https://nickler.ninja/files/coverage.main_impl.h.454c9b4a7f004f02889d157a589eaaea.html). One can see that the module is covered 100% once API tests (for ARG_CHECKS and secp256k1_ellswift_create with rnd32 == NULL) and two VERIFY_CHECK for unreachable conditions are added.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1396905813",
      "submitted_at": "2023-04-24T18:57:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9111744247,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIfGi73",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9111744247",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-27T08:46:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9114415185,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIfQvBR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9114415185",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-27T13:11:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9130905546,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIgPo_K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9130905546",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-29T15:36:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9131043584,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIgQKsA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9131043584",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-29T17:30:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9131308339,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIgRLUz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9131308339",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-29T21:36:13Z"
    },
    {
      "event": "reviewed",
      "id": 1407471651,
      "node_id": "PRR_kwDOAP4Jqs5T5FAj",
      "url": null,
      "actor": null,
      "commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1407471651",
      "submitted_at": "2023-05-01T09:18:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1410582658,
      "node_id": "PRR_kwDOAP4Jqs5UE8iC",
      "url": null,
      "actor": null,
      "commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1410582658",
      "submitted_at": "2023-05-03T14:32:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1411045434,
      "node_id": "PRR_kwDOAP4Jqs5UGtg6",
      "url": null,
      "actor": null,
      "commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Making my way through the commits. \r\n\r\nHere's a branch with fixups: https://github.com/real-or-random/secp256k1/tree/202206_ellswift_dh Currently, the only commit has some nits in the public header.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1411045434",
      "submitted_at": "2023-05-03T15:37:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1406521434,
      "node_id": "PRR_kwDOAP4Jqs5T1dBa",
      "url": null,
      "actor": null,
      "commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1406521434",
      "submitted_at": "2023-05-03T19:29:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9163400463,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIiLmUP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9163400463",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-04T06:49:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9164595884,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIiQKKs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9164595884",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-04T08:46:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9164870958,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIiRNUu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9164870958",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-04T09:08:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9174343875,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIi1WDD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9174343875",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-05T07:56:13Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T11:11:09Z",
      "updated_at": "2023-05-06T11:11:09Z",
      "source": {
        "issue": {
          "id": 1269628212,
          "node_id": "PR_kwDOABII5845knyj",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25361",
          "number": 25361,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Cipher suite",
          "body": "This PR supersedes #20962 and introduces a two-layered cipher suite used in the latest draft of [BIP324](https://github.com/bitcoin/bips/pull/1378).\r\n\r\n* Inner layer uses [RFC8439](https://datatracker.ietf.org/doc/html/rfc8439) which comes with a formal [security analysis](https://eprint.iacr.org/2014/613.pdf) so any novelty introduced by our cipher suite still offers a baseline confidence in confidentiality and authenticity. The RFC8439 instance is re-keyed every 256 messages for forward secrecy.\r\n* Outer layer uses a forward secure version of ChaCha20, `FSChaCha20` which re-keys itself every 256 messages for forward secrecy. It is used to encrypt the message length resulting in a pseudorandom byte stream.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 17,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25361",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25361",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25361.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25361.patch"
          },
          "closed_at": "2023-05-06T11:11:09Z",
          "created_at": "2022-06-13T15:40:56Z",
          "updated_at": "2023-05-06T11:11:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T11:11:30Z",
      "updated_at": "2023-05-06T11:11:30Z",
      "source": {
        "issue": {
          "id": 1021384855,
          "node_id": "PR_kwDOABII584s9UYg",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
          "number": 23233,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Add encrypted p2p transport {de}serializer",
          "body": "Revives #18242. Depends on #25361 (please review that first, the last 4 commits are to be reviewed here).\r\n\r\nThis PR adds a p2p message transport {de}serializer for encrypted packets leveraging the BIP324 specification.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 34,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23233",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23233.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23233.patch"
          },
          "closed_at": "2023-05-06T11:11:30Z",
          "created_at": "2021-10-08T19:01:33Z",
          "updated_at": "2023-05-06T11:11:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "subscribed",
      "id": 9182771673,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAIjVfnZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9182771673",
      "actor": {
        "login": "ExperiBass",
        "id": 33764485,
        "node_id": "MDQ6VXNlcjMzNzY0NDg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/33764485?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ExperiBass",
        "html_url": "https://github.com/ExperiBass",
        "followers_url": "https://api.github.com/users/ExperiBass/followers",
        "following_url": "https://api.github.com/users/ExperiBass/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ExperiBass/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ExperiBass/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ExperiBass/subscriptions",
        "organizations_url": "https://api.github.com/users/ExperiBass/orgs",
        "repos_url": "https://api.github.com/users/ExperiBass/repos",
        "events_url": "https://api.github.com/users/ExperiBass/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ExperiBass/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T15:10:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9182775945,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIjVgqJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9182775945",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T15:13:41Z"
    },
    {
      "event": "commented",
      "id": 1537203344,
      "node_id": "IC_kwDOAP4Jqs5bn9yQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1537203344",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T19:02:19Z",
      "updated_at": "2023-05-06T19:13:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "~~Hmm, I don't understand what's wrong here. The Windows builds seem to not be able to find the exported bip324 hash function?~~\r\n\r\nNevermind, just remembered and integrated #1209.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1537203344",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9183068076,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIjWn-s",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9183068076",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-06T19:05:34Z"
    },
    {
      "event": "reviewed",
      "id": 1416527777,
      "node_id": "PRR_kwDOAP4Jqs5Ubn-h",
      "url": null,
      "actor": null,
      "commit_id": "77d2ece87020f4967e1e41dfb34b9a37c24a5ce5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1416527777",
      "submitted_at": "2023-05-08T10:37:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9197376742,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkNNTm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9197376742",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T07:27:22Z"
    },
    {
      "event": "reviewed",
      "id": 1414501432,
      "node_id": "PRR_kwDOAP4Jqs5UT5Q4",
      "url": null,
      "actor": null,
      "commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I've reviewed the first 3 commits so far. And the writeup which was super helpful for reviewing the 3rd commit! (especially for understanding the encoding special cases) The logic described in the writeup and code do match. Also cross checked the constants till now (c1-c4, hash states for encode, create, xdh) by constructing them in python.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1414501432",
      "submitted_at": "2023-05-09T08:29:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1418257967,
      "node_id": "PRR_kwDOAP4Jqs5UiOYv",
      "url": null,
      "actor": null,
      "commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1418257967",
      "submitted_at": "2023-05-09T09:32:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199009218,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkTb3C",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199009218",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T09:54:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199224012,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkUQTM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199224012",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:14:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199237470,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkUTle",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199237470",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:15:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199251103,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkUW6f",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199251103",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:17:12Z"
    },
    {
      "event": "reviewed",
      "id": 1418331163,
      "node_id": "PRR_kwDOAP4Jqs5UigQb",
      "url": null,
      "actor": null,
      "commit_id": "fba93378f0554546f6eada8dfbfc128c7bcbb5bc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1418331163",
      "submitted_at": "2023-05-09T10:19:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199315940,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkUmvk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199315940",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:24:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199439591,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkVE7n",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199439591",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:38:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199528370,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkVamy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199528370",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:48:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199552030,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkVgYe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199552030",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:50:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9199617937,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkVweR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9199617937",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T10:58:18Z"
    },
    {
      "event": "commented",
      "id": 1539960615,
      "node_id": "IC_kwDOAP4Jqs5bye8n",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1539960615",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T11:00:02Z",
      "updated_at": "2023-05-09T11:00:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've made the following updates to the write-up:\r\n\r\n```diff\r\n@@ -35,7 +35,7 @@ x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2\r\n \r\n **Encoding** a given $x$ coordinate is conceptually done as follows:\r\n * Loop:\r\n-  * Pick a uniformy random field element $u.$\r\n+  * Pick a uniformly random field element $u.$\r\n   * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\r\n   * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\r\n   * Select a uniformly random $t \\in L$ and return $(u, t).$\r\n@@ -183,7 +183,7 @@ It is not possible that an encoding found through the $x_1$ expression decodes t\r\n take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\r\n precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\r\n values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\r\n-any other order requires more complicated round-trip checks in the encoder.\r\n+any order which does not place $x_3$ first requires more complicated round-trip checks in the encoder.\r\n \r\n ### 3.1 Switching to *v, w* coordinates\r\n \r\n@@ -204,9 +204,9 @@ $$\r\n \r\n We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\r\n expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\r\n-* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\r\n-* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\r\n-* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2).$\r\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\r\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\r\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2)$ (four solutions).\r\n \r\n ### 3.2 Avoiding computing all inverses\r\n \r\n@@ -271,7 +271,7 @@ Ignoring the negligible cases, we get:\r\n \r\n Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\r\n 50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\r\n-with negligible probability. The division in the first branch in fact cannot occur at all, $u^2 + uv + v^2 + a = 0$\r\n+with negligible probability. A division by 0 in the first branch in fact cannot occur at all, because $u^2 + uv + v^2 + a = 0$\r\n implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\r\n and $\\bot$ would have been returned already.\r\n \r\n@@ -304,8 +304,8 @@ There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each res\r\n \r\n ### 3.4 Dealing with special cases\r\n \r\n-As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs (besides division by zero).\r\n-For cryptographically sized curves, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\r\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs.\r\n+For cryptographically sized fields, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\r\n we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\r\n do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\r\n $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n@@ -315,24 +315,26 @@ $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n     Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\r\n     fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\r\n     This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\r\n-    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targetted uniformly by the\r\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targeted uniformly by the\r\n     encoder anyway as there will generally be more than 8.\r\n   * When $g(x) = 0$, the same $t$ would be produced as in the $x_3$ branch (where $c \\in \\\\{2, 3, 6, 7\\\\}$) which we give precedence\r\n     as it can deal with $g(u)=0$.\r\n     This is again only possible on even-ordered curves.\r\n * In the branch for $x_3$ (where $c \\in \\\\{2, 3, 6, 7\\\\}$):\r\n-  * When $u = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.\r\n-    It is equivalent to checking whether the square root is zero.\r\n-    This cannot occur in the $x_1$ / $x_2$ branch, as it would trigger the $g(-u-x)$ is square condition.\r\n+  * When $s=0$, a division by zero would occur.\r\n+  * When $v = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.\r\n+    It is equivalent to checking whether $r=0$.\r\n+    This cannot occur in the $x_1$ or $x_2$ branches, as it would trigger the $g(-u-x)$ is square condition.\r\n     A similar concern for $w = -w$ does not exist, as $w=0$ is already impossible in both branches: in the first\r\n-    it requires $g(u)=0$ which is already outlawed; in the second it would trigger division by zero.\r\n-* In the implementation of $P_u^{'-1}$, special cases can occur:\r\n+    it requires $g(u)=0$ which is already outlawed on even-ordered curves and impossible on others; in the second it would trigger division by zero.\r\n+* In the implementation of $P_u^{'-1}$, special cases can occur.\r\n   * For $a=0$ curves, $u=0$ and $t=0$ need to be avoided as they would trigger division by zero in the decoder.\r\n     The latter is only possible when $g(u)=0$ and can thus only occur on even-ordered curves.\r\n   * For $a \\neq 0$ curves, $h(u)t^2 = -1$ needs to be avoided as it would trigger division by zero in the decoder.\r\n   * Also for $a \\neq 0$ curves, if $w(u/2 + v) = X_0(u)$ but $w/2 \\neq Y_0(u)$, no $t$ exists.\r\n \r\n **Define** a version of $G_{c,u}(x)$ which deals with all these cases:\r\n+* If $u=0$, return $\\bot.$\r\n * If $c \\in \\\\{0, 1, 4, 5\\\\}:$\r\n   * If $g(u) = 0$ or $g(x) = 0$, return $\\bot$ (even curves only).\r\n   * If $g(-u-x)$ is square, return $\\bot.$\r\n@@ -340,10 +342,11 @@ $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n   * Let $v = x.$\r\n * Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\r\n   * Let $s = x-u.$\r\n-  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\r\n+  * If $s = 0$, return $\\bot.$\r\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\r\n   * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n-* Let $w = \\sqrt{s}.$\r\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n * Depending on $c:$\r\n   * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\r\n   * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\r\n@@ -371,10 +374,11 @@ Specialized for odd-ordered $a=0$ curves:\r\n   * Let $v = x.$\r\n * Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\r\n   * Let $s = x-u.$\r\n-  * Let $r = \\sqrt{-s(4(u^3 + b) + 3su^2)}.$\r\n+  * If $s = 0$, return $\\bot.$\r\n+  * Let $r = \\sqrt{-s(4(u^3 + b) + 3su^2)}$; return $\\bot$ if not square.\r\n   * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n-* Let $w = \\sqrt{s}.$\r\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n * Depending on $c:$\r\n   * If $c \\in \\\\{0, 2\\\\}:$ return $w(\\frac{\\sqrt{-3}-1}{2}u - v).$\r\n   * If $c \\in \\\\{1, 3\\\\}:$ return $w(\\frac{\\sqrt{-3}+1}{2}u + v).$\r\n@@ -431,10 +435,10 @@ And encoding would be done using a $G_{c,u}(x, y)$ function defined as:\r\n   * Let $v = x.$\r\n * Otherwise, when $c \\in \\\\{2, 3\\\\}:$\r\n   * Let $s = x-u.$\r\n-  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\r\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\r\n   * If $c = 3$ and $r = 0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n-* Let $w = \\sqrt{s}.$\r\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n * Let $w' = w$ if $sign(w/2) = sign(y)$; $-w$ otherwise.\r\n * Depending on $c:$\r\n   * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w').$\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1539960615",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9200264061,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkYON9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9200264061",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T12:51:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9200327295,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkYdp_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9200327295",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T12:56:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9200971855,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIka7BP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9200971855",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T13:49:21Z"
    },
    {
      "event": "reviewed",
      "id": 1418729566,
      "node_id": "PRR_kwDOAP4Jqs5UkBhe",
      "url": null,
      "actor": null,
      "commit_id": "9a9900ed998b213d457df945ff7fcfb141499589",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1418729566",
      "submitted_at": "2023-05-09T14:07:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9201318120,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIkcPjo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9201318120",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T14:16:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9212050393,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIlFLvZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9212050393",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-10T13:52:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9212119466,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIlFcmq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9212119466",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-10T13:58:31Z"
    },
    {
      "event": "commented",
      "id": 1542277390,
      "node_id": "IC_kwDOAP4Jqs5b7UkO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1542277390",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-10T14:05:20Z",
      "updated_at": "2023-05-10T14:05:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "After in-person discussion, we decided to make the \"prefix\" hasher not sort the inputs. This makes the BIP324 hasher an optimized specialization of the prefix hasher, plus is more simple to understand conceptually.\r\n\r\nThis required making two API changes:\r\n* The `secp256k1_ellswift_xdh` function now takes public keys `ell_a64` and `ell_b64` (corresponding to party A's pubkey and party B's pubkey) rather than `ell64_theirs` and `ell64_ours`. It also takes a new argument `party`, to identify whether the caller is party A or party B.\r\n* The `secp256k1_ellswift_xdh_hash_function` type now takes public keys `ell_a64` and `ell_b64` instead of `ell64_ours` and `ell64_theirs`.\r\n\r\nThis change is a generalization, in the sense that the old sorting hasher behavior can still be implemented if desired (either using a custom hasher that performs sorting, or by having the caller sort the keys before invocation).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1542277390",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "reviewed",
      "id": 1421195880,
      "node_id": "PRR_kwDOAP4Jqs5Utbpo",
      "url": null,
      "actor": null,
      "commit_id": "3cfa1e033dc7ca55521659bb72b7753053308ac1",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "code review ACK 3cfa1e033dc7ca55521659bb72b7753053308ac1\r\n\r\nI have not reviewed ellswift.md or otherwise verified that the pseudocode is correct.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1421195880",
      "submitted_at": "2023-05-10T18:39:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "labeled",
      "id": 9219215626,
      "node_id": "LE_lADOAP4Jqs5OUBcRzwAAAAIlghEK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9219215626",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T08:06:39Z",
      "label": {
        "name": "feature",
        "color": "A40C6C"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9229039528,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAImF_eo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9229039528",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T05:20:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9229136112,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAImGXDw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9229136112",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T05:40:32Z"
    },
    {
      "event": "commented",
      "id": 1545197377,
      "node_id": "IC_kwDOAP4Jqs5cGddB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1545197377",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T05:42:16Z",
      "updated_at": "2023-05-12T05:42:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased after #1207.\r\n\r\nChanges:\r\n```diff\r\ndiff --git a/src/modules/ellswift/main_impl.h b/src/modules/ellswift/main_impl.h\r\nindex 679fa870..61334c8d 100644\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -355,7 +355,7 @@ static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1\r\n         /* Compute a new u value by hashing. */\r\n         secp256k1_ellswift_prng(u32, hasher, cnt++);\r\n         /* overflow is not a problem (we prefer uniform u32 over uniform u). */\r\n-        (void)secp256k1_fe_set_b32(&u, u32);\r\n+        secp256k1_fe_set_b32_mod(&u, u32);\r\n         /* Since u is the output of a hash, it should practically never be 0. We could apply the\r\n          * u=0 to u=1 correction here too to deal with that case still, but it's such a low\r\n          * probability that we do not bother. */\r\n@@ -489,9 +489,8 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\r\n     ARG_CHECK(pubkey != NULL);\r\n     ARG_CHECK(ell64 != NULL);\r\n \r\n-    secp256k1_fe_set_b32(&u, ell64);\r\n-    secp256k1_fe_normalize_var(&u);\r\n-    secp256k1_fe_set_b32(&t, ell64 + 32);\r\n+    secp256k1_fe_set_b32_mod(&u, ell64);\r\n+    secp256k1_fe_set_b32_mod(&t, ell64 + 32);\r\n     secp256k1_fe_normalize_var(&t);\r\n     secp256k1_ellswift_swiftec_var(&p, &u, &t);\r\n     secp256k1_pubkey_save(pubkey, &p);\r\n@@ -562,10 +561,8 @@ int secp256k1_ellswift_xdh(const secp256k1_context *ctx, unsigned char *output,\r\n \r\n     /* Load remote public key (as fraction). */\r\n     theirs64 = party ? ell_a64 : ell_b64;\r\n-    secp256k1_fe_set_b32(&u, theirs64);\r\n-    secp256k1_fe_normalize_var(&u);\r\n-    secp256k1_fe_set_b32(&t, theirs64 + 32);\r\n-    secp256k1_fe_normalize_var(&t);\r\n+    secp256k1_fe_set_b32_mod(&u, theirs64);\r\n+    secp256k1_fe_set_b32_mod(&t, theirs64 + 32);\r\n     secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, &u, &t);\r\n \r\n     /* Load private key (using one if invalid). */\r\ndiff --git a/src/modules/ellswift/tests_impl.h b/src/modules/ellswift/tests_impl.h\r\nindex 95ff51cd..1cc14f7b 100644\r\n--- a/src/modules/ellswift/tests_impl.h\r\n+++ b/src/modules/ellswift/tests_impl.h\r\n@@ -285,7 +285,8 @@ void run_ellswift_tests(void) {\r\n          * because the \"hasher\" function we use here ignores the ell arguments. */\r\n         ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\r\n         CHECK(ret);\r\n-        secp256k1_fe_set_b32(&share_x, share32);\r\n+        (void)secp256k1_fe_set_b32_limit(&share_x, share32); /* no overflow is possible */\r\n+        secp256k1_fe_verify(&share_x);\r\n         /* Compute seckey*pubkey directly. */\r\n         secp256k1_ecmult(&resj, &decj, &sec, NULL);\r\n         secp256k1_ge_set_gej(&res, &resj);\r\n```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1545197377",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:00:54Z",
      "updated_at": "2023-05-12T07:00:54Z",
      "source": {
        "issue": {
          "id": 1707054771,
          "node_id": "I_kwDOABII585lv5az",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/27634",
          "number": 27634,
          "state": "open",
          "state_reason": null,
          "title": "BIP324 tracking issue",
          "body": "This issue will be updated to reflect the current state of [BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki) integration.\r\n\r\nPRs ready for review:\r\n* #28008\r\n* #28165\r\n\r\nOverall plan:\r\n* [x] ElligatorSwift integration in Bitcoin Core: #27479 \r\n  * [x] Dependency: ElligatorSwift support in libsecp256k1: bitcoin-core/secp256k1#1129\r\n  * [x] Dependency: update libsecp256k1 subtree: currently part of 27479.\r\n* [ ] Cipher suite implementation (formerly 25361):\r\n  * [x] Support for not wasting ChaCha20 stream bytes: #26153\r\n  * [x] Support for RFC8439 variant of ChaCha20: #27985\r\n  * [x] Support for incremental Poly1305 computation: #27993\r\n  * [ ] Cipher suite: #28008\r\n* [ ] P2P v2 connection support (formerly 23561, 23233, 24545):\r\n  * [ ] P2P transport abstraction: #28165\r\n  * [ ] BIP324 connection support: #28196\r\n* [ ] P2P v2 signalling integration (formerly 24545): no PR yet\r\n* [ ] BIP324 functional tests: #24748:\r\n   * [x] Dependency: ElligatorSwift support in functional tests: #24005\r\n   * [x] Dependency: Field element support in functional tests: #26222\r\n* [ ] P2P_V2 service flag support in DNS seeder: sipa/bitcoin-seeder#102\r\n* [x] Prehistory:\r\n  * [x] Old ChaCha20Poly1305@Bitcoin cipher: #15649\r\n  * [x] Preparing for multiple transport layers: #16202 and #16562\r\n  * [x] Miscellaneous fixes: #22331 #23271\r\n  * [x] ChaCha20 performance: #24946 \r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 0,
          "created_at": "2023-05-12T07:00:54Z",
          "updated_at": "2023-08-01T17:59:34Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1419972630,
      "node_id": "PRR_kwDOAP4Jqs5UoxAW",
      "url": null,
      "actor": null,
      "commit_id": "a91ad4864dc6945f7eefa3b82de31ce01e2b9b22",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1419972630",
      "submitted_at": "2023-05-12T10:54:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9240737438,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAImynae",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9240737438",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-14T21:03:31Z"
    },
    {
      "event": "reviewed",
      "id": 1427731966,
      "node_id": "PRR_kwDOAP4Jqs5VGXX-",
      "url": null,
      "actor": null,
      "commit_id": "2fb3ebee118cdf94d6098c0fb803fc9e56b9a3fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1427731966",
      "submitted_at": "2023-05-17T15:22:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9271500206,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIon92u",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9271500206",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T16:18:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9272812627,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIos-RT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9272812627",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T19:01:17Z"
    },
    {
      "event": "commented",
      "id": 1562835373,
      "node_id": "IC_kwDOAP4Jqs5dJvmt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1562835373",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-25T12:39:05Z",
      "updated_at": "2023-05-25T12:39:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "It seems that some of the changes to the writeup I made two weeks ago to be more explicit about all the edge cases are specific to a=0 curves. I'll look over them again.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1562835373",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "reviewed",
      "id": 1444140521,
      "node_id": "PRR_kwDOAP4Jqs5WE9Xp",
      "url": null,
      "actor": null,
      "commit_id": "614509cbc6ce606e6719aede4832d5839367e3b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Quick glimpse at the buildsystem...  changes look good to me.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1444140521",
      "submitted_at": "2023-05-25T15:24:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9344285458,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIs9nsS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9344285458",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-25T20:40:34Z"
    },
    {
      "event": "commented",
      "id": 1563482286,
      "node_id": "IC_kwDOAP4Jqs5dMNiu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1563482286",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-25T20:41:18Z",
      "updated_at": "2023-05-31T17:46:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made these changes to the doc:\r\n\r\n```diff\r\n--- a/doc/ellswift.md\r\n+++ b/doc/ellswift.md\r\n@@ -327,14 +327,13 @@ $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n     This cannot occur in the $x_1$ or $x_2$ branches, as it would trigger the $g(-u-x)$ is square condition.\r\n     A similar concern for $w = -w$ does not exist, as $w=0$ is already impossible in both branches: in the first\r\n     it requires $g(u)=0$ which is already outlawed on even-ordered curves and impossible on others; in the second it would trigger division by zero.\r\n-* In the implementation of $P_u^{'-1}$, special cases can occur.\r\n-  * For $a=0$ curves, $u=0$ and $t=0$ need to be avoided as they would trigger division by zero in the decoder.\r\n-    The latter is only possible when $g(u)=0$ and can thus only occur on even-ordered curves.\r\n-  * For $a \\neq 0$ curves, $h(u)t^2 = -1$ needs to be avoided as it would trigger division by zero in the decoder.\r\n-  * Also for $a \\neq 0$ curves, if $w(u/2 + v) = X_0(u)$ but $w/2 \\neq Y_0(u)$, no $t$ exists.\r\n+* Curve-specific special cases also exist that need to be rejected, because they result in $(u,t)$ which is invalid to the decoder, or because of division by zero in the encoder:\r\n+  * For $a=0$ curves, when $u=0$ or when $t=0$. The latter can only be reached by the encoder when $g(u)=0$, which requires an even-ordered curve.\r\n+  * For $a \\neq 0$ curves, when $X_0(u)=0$, when $h(u)t^2 = -1$, or when $2w(u + 2v) = 2X_0(u)$ while also either $w \\neq 2Y_0(u)$ or $h(u)=0$.\r\n \r\n **Define** a version of $G_{c,u}(x)$ which deals with all these cases:\r\n-* If $u=0$, return $\\bot.$\r\n+* If $a=0$ and $u=0$, return $\\bot.$\r\n+* If $a \\neq 0$ and $X_0(u)=0$, return $\\bot.$\r\n * If $c \\in \\\\{0, 1, 4, 5\\\\}:$\r\n   * If $g(u) = 0$ or $g(x) = 0$, return $\\bot$ (even curves only).\r\n   * If $g(-u-x)$ is square, return $\\bot.$\r\n@@ -347,15 +346,19 @@ $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n   * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n * Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n+* If $a \\neq 0$ and $w(u+2v) = 2X_0(u)$ and either $w \\neq 2Y_0(u)$ or $h(u) = 0$, return $\\bot.$\r\n * Depending on $c:$\r\n-  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\r\n-  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\r\n-  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\r\n-  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\r\n+  * If $c \\in \\\\{0, 2\\\\}$, let $t = P_u^{'-1}(v, w).$\r\n+  * If $c \\in \\\\{1, 3\\\\}$, let $t = P_u^{'-1}(-u-v, w).$\r\n+  * If $c \\in \\\\{4, 6\\\\}$, let $t = P_u^{'-1}(v, -w).$\r\n+  * If $c \\in \\\\{5, 7\\\\}$, let $t = P_u^{'-1}(-u-v, -w).$\r\n+* If $a=0$ and $t=0$, return $\\bot$ (even curves only).\r\n+* If $a \\neq 0$ and $h(u)t^2 = -1$, return $\\bot.$\r\n+* Return $t.$\r\n \r\n Given any $u$, using this algorithm over all $x$ and $c$ values, every $t$ value will be reached exactly once,\r\n for an $x$ for which $F_u(t) = x$ holds, except for these cases that will not be reached:\r\n-* (Obviously) all cases where $P_u(t)$ is not defined:\r\n+* All cases where $P_u(t)$ is not defined:\r\n   * For $a=0$ curves, when $u=0$, $t=0$, or $g(u) = -t^2.$\r\n   * For $a \\neq 0$ curves, when $h(u)t^2 = -1$, $X_0(u) = 0$, or $Y_0(u) (1 - h(u) t^2) = 2X_0(u)t.$\r\n * When $g(u)=0$, the potentially many $t$ values that decode to an $x$ satisfying $g(x)=0$ using the $x_2$ formula. These were excluded by the $g(u)=0$ condition in the $c \\in \\\\{0, 1, 4, 5\\\\}$ branch.\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1563482286",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9345361527,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAItBuZ3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9345361527",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-26T00:20:59Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9393506126,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIv5YdO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9393506126",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T17:40:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9393522455,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAIv5ccX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9393522455",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T17:42:26Z"
    },
    {
      "event": "commented",
      "id": 1570655645,
      "node_id": "IC_kwDOAP4Jqs5dnk2d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1570655645",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T17:47:52Z",
      "updated_at": "2023-05-31T17:47:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased, and addressed @theuni's comments. Ready for more review, I think.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1570655645",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 9393564795,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAIv5mx7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9393564795",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T17:47:52Z"
    },
    {
      "event": "subscribed",
      "id": 9393564802,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAIv5myC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9393564802",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T17:47:52Z"
    },
    {
      "event": "reviewed",
      "id": 1455742394,
      "node_id": "PRR_kwDOAP4Jqs5WxN26",
      "url": null,
      "actor": null,
      "commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK fe26466f040a6ddc242cea54037c2c4cd85a0bc9 on changes in Autotools, CMake and CI related stuff.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1455742394",
      "submitted_at": "2023-06-01T15:20:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1479976878,
      "node_id": "PRR_kwDOAP4Jqs5YNqeu",
      "url": null,
      "actor": null,
      "commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Here are some minor remarks about performance.\r\n\r\nContinuing to go through the main parts of the code. I'll probably also follow up with a fixup commit with some nits in the code comments later this week.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1479976878",
      "submitted_at": "2023-06-14T17:36:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9533622412,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI4P4iM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9533622412",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T21:51:32Z"
    },
    {
      "event": "commented",
      "id": 1592043356,
      "node_id": "IC_kwDOAP4Jqs5e5Kdc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1592043356",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T21:55:40Z",
      "updated_at": "2023-06-14T21:55:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made the following changes:\r\n\r\n```diff\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -256,9 +256,6 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n         s = m; /* s = -u */\r\n         secp256k1_fe_add(&s, &x); /* s = x-u */\r\n \r\n-        /* If s=0, fail. */\r\n-        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\r\n-\r\n         /* If s is not square, fail. */\r\n         if (!secp256k1_fe_is_square_var(&s)) return 0;\r\n \r\n@@ -278,7 +275,10 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n         VERIFY_CHECK(ret);\r\n \r\n         /* If (c & 1) = 1 and r = 0, fail. */\r\n-        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\r\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\r\n+\r\n+        /* If s=0, fail. */\r\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\r\n \r\n         /* Let v=(r/s-u)/2. */\r\n         secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\r\n@@ -360,15 +360,12 @@ static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1\r\n         secp256k1_fe_set_b32_mod(&u, u32);\r\n         /* Since u is the output of a hash, it should practically never be 0. We could apply the\r\n          * u=0 to u=1 correction here too to deal with that case still, but it's such a low\r\n-         * probability that we do not bother. */\r\n+         * probability event that we do not bother. */\r\n #ifdef VERIFY\r\n         VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\r\n #endif\r\n         /* Find a remainder t, and return it if found. */\r\n-        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\r\n-            secp256k1_fe_normalize_var(t);\r\n-            break;\r\n-        }\r\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\r\n     }\r\n }\r\n \r\n@@ -380,6 +377,7 @@ static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1\r\n  */\r\n static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\r\n     secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\r\n+    secp256k1_fe_normalize_var(t);\r\n     if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\r\n         secp256k1_fe_negate(t, t, 1);\r\n         secp256k1_fe_normalize_var(t);\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1592043356",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "reviewed",
      "id": 1481306768,
      "node_id": "PRR_kwDOAP4Jqs5YSvKQ",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1481306768",
      "submitted_at": "2023-06-15T11:05:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1481319678,
      "node_id": "PRR_kwDOAP4Jqs5YSyT-",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1481319678",
      "submitted_at": "2023-06-15T11:12:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1481409228,
      "node_id": "PRR_kwDOAP4Jqs5YTILM",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1481409228",
      "submitted_at": "2023-06-15T12:05:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1481422142,
      "node_id": "PRR_kwDOAP4Jqs5YTLU-",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1481422142",
      "submitted_at": "2023-06-15T12:18:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1482231176,
      "node_id": "PRR_kwDOAP4Jqs5YWQ2I",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "bitcoinfinancier",
        "id": 134175231,
        "node_id": "U_kgDOB_9Z_w",
        "avatar_url": "https://avatars.githubusercontent.com/u/134175231?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoinfinancier",
        "html_url": "https://github.com/bitcoinfinancier",
        "followers_url": "https://api.github.com/users/bitcoinfinancier/followers",
        "following_url": "https://api.github.com/users/bitcoinfinancier/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoinfinancier/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoinfinancier/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoinfinancier/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoinfinancier/orgs",
        "repos_url": "https://api.github.com/users/bitcoinfinancier/repos",
        "events_url": "https://api.github.com/users/bitcoinfinancier/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoinfinancier/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1482231176",
      "submitted_at": "2023-06-15T19:10:57Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1435473854,
      "node_id": "PRR_kwDOAP4Jqs5Vj5e-",
      "url": null,
      "actor": null,
      "commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1435473854",
      "submitted_at": "2023-06-15T19:12:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9558831333,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI5wDDl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9558831333",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-17T13:27:35Z"
    },
    {
      "event": "commented",
      "id": 1595760871,
      "node_id": "IC_kwDOAP4Jqs5fHWDn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1595760871",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-17T13:27:45Z",
      "updated_at": "2023-06-17T13:31:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made these changes:\r\n\r\n```diff\r\ndiff --git a/doc/ellswift.md b/doc/ellswift.md\r\nindex 9a1672b7..7fbb7c17 100644\r\n--- a/doc/ellswift.md\r\n+++ b/doc/ellswift.md\r\n@@ -341,9 +341,9 @@ $t$ value for multiple $c$ inputs (thereby biasing that encoding):\r\n   * Let $v = x.$\r\n * Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\r\n   * Let $s = x-u.$\r\n-  * If $s = 0$, return $\\bot.$\r\n   * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\r\n   * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\r\n+  * If $s = 0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n * Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n * If $a \\neq 0$ and $w(u+2v) = 2X_0(u)$ and either $w \\neq 2Y_0(u)$ or $h(u) = 0$, return $\\bot.$\r\n@@ -377,9 +377,9 @@ Specialized for odd-ordered $a=0$ curves:\r\n   * Let $v = x.$\r\n * Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\r\n   * Let $s = x-u.$\r\n-  * If $s = 0$, return $\\bot.$\r\n   * Let $r = \\sqrt{-s(4(u^3 + b) + 3su^2)}$; return $\\bot$ if not square.\r\n   * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\r\n+  * If $s = 0$, return $\\bot.$\r\n   * Let $v = (r/s - u)/2.$\r\n * Let $w = \\sqrt{s}$; return $\\bot$ if not square.\r\n * Depending on $c:$\r\ndiff --git a/include/secp256k1_ellswift.h b/include/secp256k1_ellswift.h\r\nindex 3d73c5f3..b0284d2b 100644\r\n--- a/include/secp256k1_ellswift.h\r\n+++ b/include/secp256k1_ellswift.h\r\n@@ -82,7 +82,7 @@ SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_\r\n \r\n /** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\r\n  *\r\n- *  Returns: 1 when pubkey is valid.\r\n+ *  Returns: 1 always.\r\n  *  Args:    ctx:        pointer to a context object\r\n  *  Out:     ell64:      pointer to a 64-byte array to be filled\r\n  *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\r\n@@ -96,6 +96,10 @@ SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_\r\n  * uniform. The randomness in rnd32 must not be a deterministic function of\r\n  * the pubkey (it can be derived from the private key, though).\r\n  *\r\n+ * It is not guaranteed that the computed encoding is stable across versions\r\n+ * of the library, even if all arguments to this function (including rnd32)\r\n+ * are the same.\r\n+ *\r\n  * This function runs in variable time.\r\n  */\r\n SECP256K1_API int secp256k1_ellswift_encode(\r\n@@ -136,10 +140,14 @@ SECP256K1_API int secp256k1_ellswift_decode(\r\n  * it is optional (and does result in encodings that are indistinguishable from\r\n  * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\r\n  * argument to secp256k1_ellswift_encode in this regard.\r\n-\r\n+ *\r\n  * This function can be used instead of calling secp256k1_ec_pubkey_create\r\n  * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\r\n  * key as entropy for the encoding (supplemented with auxrnd32, if provided).\r\n+ *\r\n+ * Like secp256k1_ellswift_encode, this function does not guaranteed that the\r\n+ * computed encoding is stable across versions of the library, even if all\r\n+ * arguments (including auxrnd32) are the same.\r\n  */\r\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\r\n     const secp256k1_context *ctx,\r\n@@ -159,10 +167,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\r\n  *                      (will not be NULL)\r\n  *           ell_b64:   pointer to the 64-byte encoded public key of party B\r\n  *                      (will not be NULL)\r\n- *           seckey32:  a pointer to the 32-byte secret key corresponding to\r\n- *                      ours64 (the correspondence is not checked)\r\n+ *           seckey32:  a pointer to our 32-byte secret key\r\n  *           party:     boolean indicating which party we are: zero if we are\r\n- *                      party A, non-zero if we are party B\r\n+ *                      party A, non-zero if we are party B. seckey32 must be\r\n+ *                      the private key corresponding to that party's ell_?64.\r\n+ *                      This correspondence is not checked.\r\n  *           hashfp:    pointer to a hash function.\r\n  *           data:      arbitrary data pointer passed through to hashfp.\r\n  *\r\ndiff --git a/src/modules/ellswift/main_impl.h b/src/modules/ellswift/main_impl.h\r\nindex 44e622aa..c37379e3 100644\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -8,6 +8,7 @@\r\n \r\n #include \"../../../include/secp256k1.h\"\r\n #include \"../../../include/secp256k1_ellswift.h\"\r\n+#include \"../../eckey.h\"\r\n #include \"../../hash.h\"\r\n \r\n /** c1 = (sqrt(-3)-1)/2 */\r\n@@ -175,10 +176,10 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n      *   - Let v=x.\r\n      * - If (c & 2) = 2:\r\n      *   - Let s=x-u.\r\n-     *   - If s=0, fail.\r\n      *   - If s is not square, fail.\r\n      *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\r\n      *   - If (c & 1) = 1 and r = 0, fail.\r\n+     *   - If s=0, fail.\r\n      *   - Let v=(r/s-u)/2.\r\n      * - Let w=sqrt(s).\r\n      * - If (c & 5) = 0: return -w*(c3*u + v)\r\n@@ -409,13 +410,15 @@ int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64\r\n     if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\r\n         secp256k1_fe t;\r\n         unsigned char p64[64] = {0};\r\n+        size_t ser_size;\r\n+        int ser_ret;\r\n         secp256k1_sha256 hash;\r\n \r\n-        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\r\n-         * hash with tag \"secp256k1_ellswift_encode\". */\r\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using\r\n+         * BIP340 tagged hash with tag \"secp256k1_ellswift_encode\". */\r\n         secp256k1_ellswift_sha256_init_encode(&hash);\r\n-        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\r\n-        secp256k1_fe_get_b32(p64 + 1, &p.x);\r\n+        ser_ret = secp256k1_eckey_pubkey_serialize(&p, p64, &ser_size, 1);\r\n+        VERIFY_CHECK(ser_ret && ser_size == 33);\r\n         secp256k1_sha256_write(&hash, p64, sizeof(p64));\r\n         secp256k1_sha256_write(&hash, rnd32, 32);\r\n \r\n@@ -424,7 +427,7 @@ int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64\r\n         secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\r\n         return 1;\r\n     }\r\n-    /* Only returned in case the provided pubkey is invalid. */\r\n+    /* Only reached in case the provided pubkey is invalid. */\r\n     return 0;\r\n }\r\n ```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1595760871",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9558834594,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI5wD2i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9558834594",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-17T13:29:28Z"
    },
    {
      "event": "reviewed",
      "id": 1484828359,
      "node_id": "PRR_kwDOAP4Jqs5YgK7H",
      "url": null,
      "actor": null,
      "commit_id": "4860ab0e2246b56469a564d980a1316c5e36fb47",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1484828359",
      "submitted_at": "2023-06-17T13:54:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9559216468,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI5xhFU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9559216468",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-17T17:34:31Z"
    },
    {
      "event": "commented",
      "id": 1595813792,
      "node_id": "IC_kwDOAP4Jqs5fHi-g",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1595813792",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-17T17:34:46Z",
      "updated_at": "2023-06-17T17:34:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made the following changes:\r\n\r\n```diff\r\ndiff --git a/src/modules/ellswift/tests_impl.h b/src/modules/ellswift/tests_impl.h\r\nindex 1454cd6d..86ca0986 100644\r\n--- a/src/modules/ellswift/tests_impl.h\r\n+++ b/src/modules/ellswift/tests_impl.h\r\n@@ -294,10 +294,10 @@ void run_ellswift_tests(void) {\r\n     }\r\n     /* Verify the joint behavior of secp256k1_ellswift_xdh */\r\n     for (i = 0; i < 200 * COUNT; i++) {\r\n-        unsigned char auxrnd32a[32], auxrnd32b[32], auxrnd32a_bad[32];\r\n-        unsigned char sec32a[32], sec32b[32], sec32a_bad[32];\r\n+        unsigned char auxrnd32a[32], auxrnd32b[32], auxrnd32a_bad[32], auxrnd32b_bad[32];\r\n+        unsigned char sec32a[32], sec32b[32], sec32a_bad[32], sec32b_bad[32];\r\n         secp256k1_scalar seca, secb;\r\n-        unsigned char ell64a[64], ell64b[64], ell64a_bad[64];\r\n+        unsigned char ell64a[64], ell64b[64], ell64a_bad[64], ell64b_bad[64];\r\n         unsigned char share32a[32], share32b[32], share32_bad[32];\r\n         unsigned char prefix64[64];\r\n         secp256k1_ellswift_xdh_hash_function hash_function;\r\n@@ -327,33 +327,60 @@ void run_ellswift_tests(void) {\r\n         secp256k1_scalar_get_b32(sec32b, &secb);\r\n \r\n         /* Construct ElligatorSwift-encoded public keys for those keys. */\r\n+        /* For A: */\r\n         ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, auxrnd32a);\r\n         CHECK(ret);\r\n+        /* For B: */\r\n         ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, auxrnd32b);\r\n         CHECK(ret);\r\n \r\n         /* Compute the shared secret both ways and compare with each other. */\r\n-        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, hash_function, data);\r\n+        /* For A: */\r\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32a, 0, hash_function, data);\r\n         CHECK(ret);\r\n-        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, hash_function, data);\r\n+        /* For B: */\r\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32b, 1, hash_function, data);\r\n         CHECK(ret);\r\n+        /* And compare: */\r\n         CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\r\n \r\n-        /* Verify that the shared secret doesn't match if public key encoding changes. */\r\n+        /* Verify that the shared secret doesn't match if other side's public key is incorrect. */\r\n+        /* For A (using a bad public key for B): */\r\n+        memcpy(ell64b_bad, ell64b, sizeof(ell64a_bad));\r\n+        secp256k1_testrand_flip(ell64b_bad, sizeof(ell64b_bad));\r\n+        ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b_bad, sec32a, 0, hash_function, data);\r\n+        CHECK(ret); /* Mismatching encodings don't get detected by secp256k1_ellswift_xdh. */\r\n+        CHECK(secp256k1_memcmp_var(share32_bad, share32a, 32) != 0);\r\n+        /* For B (using a bad public key for A): */\r\n         memcpy(ell64a_bad, ell64a, sizeof(ell64a_bad));\r\n         secp256k1_testrand_flip(ell64a_bad, sizeof(ell64a_bad));\r\n         ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a_bad, ell64b, sec32b, 1, hash_function, data);\r\n-        CHECK(ret); /* Invalid encodings don't get detected by secp256k1_ellswift_xdh. */\r\n+        CHECK(ret);\r\n         CHECK(secp256k1_memcmp_var(share32_bad, share32b, 32) != 0);\r\n \r\n-        /* Verify that the shared secret doesn't match if the private key changes. */\r\n+        /* Verify that the shared secret doesn't match if the private key is incorrect. */\r\n+        /* For A: */\r\n         memcpy(sec32a_bad, sec32a, sizeof(sec32a_bad));\r\n         secp256k1_testrand_flip(sec32a_bad, sizeof(sec32a_bad));\r\n         ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b, sec32a_bad, 0, hash_function, data);\r\n+        CHECK(!ret || secp256k1_memcmp_var(share32_bad, share32a, 32) != 0);\r\n+        /* For B: */\r\n+        memcpy(sec32b_bad, sec32b, sizeof(sec32b_bad));\r\n+        secp256k1_testrand_flip(sec32b_bad, sizeof(sec32b_bad));\r\n+        ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b, sec32b_bad, 1, hash_function, data);\r\n         CHECK(!ret || secp256k1_memcmp_var(share32_bad, share32b, 32) != 0);\r\n \r\n         if (hash_function != ellswift_xdh_hash_x32) {\r\n             /* Verify that the shared secret doesn't match when a different encoding of the same public key is used. */\r\n+            /* For A (changing B's public key): */\r\n+            memcpy(auxrnd32b_bad, auxrnd32b, sizeof(auxrnd32b_bad));\r\n+            secp256k1_testrand_flip(auxrnd32b_bad, sizeof(auxrnd32b_bad));\r\n+            ret = secp256k1_ellswift_create(CTX, ell64b_bad, sec32b, auxrnd32b_bad);\r\n+            CHECK(ret);\r\n+            ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b_bad, sec32a, 0, hash_function, data);\r\n+            CHECK(ret);\r\n+            CHECK(secp256k1_memcmp_var(share32_bad, share32a, 32) != 0);\r\n+            /* For B (changing A's public key): */\r\n             memcpy(auxrnd32a_bad, auxrnd32a, sizeof(auxrnd32a_bad));\r\n             secp256k1_testrand_flip(auxrnd32a_bad, sizeof(auxrnd32a_bad));\r\n             ret = secp256k1_ellswift_create(CTX, ell64a_bad, sec32a, auxrnd32a_bad);\r\n@@ -363,6 +390,11 @@ void run_ellswift_tests(void) {\r\n             CHECK(secp256k1_memcmp_var(share32_bad, share32b, 32) != 0);\r\n \r\n             /* Verify that swapping sides changes the shared secret. */\r\n+            /* For A (claiming to be B): */\r\n+            ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b, sec32a, 1, hash_function, data);\r\n+            CHECK(ret);\r\n+            CHECK(secp256k1_memcmp_var(share32_bad, share32a, 32) != 0);\r\n+            /* For B (claiming to be A): */\r\n             ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b, sec32b, 0, hash_function, data);\r\n             CHECK(ret);\r\n             CHECK(secp256k1_memcmp_var(share32_bad, share32b, 32) != 0);\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1595813792",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "reviewed",
      "id": 1484936885,
      "node_id": "PRR_kwDOAP4Jqs5Ygla1",
      "url": null,
      "actor": null,
      "commit_id": "e9f49bf4c2cd982951cb45e6594e4d0b9020395f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Noticed that the commit message of 16d251380fb3e619ff7da0a983735ff78d301307 contains some typos/inaccuracies:\r\n```diff\r\ndiff --git a/commitmsg.txt b/commitmsg.txt\r\nindex b1bd953..fadc3fe 100644\r\n--- a/commitmsg.txt\r\n+++ b/commitmsg.txt\r\n@@ -12,11 +12,11 @@\r\n     interpret them as field elements u and t. Then:\r\n     * Let c=0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852.\r\n     * Let u'=u unless u==0, in which case let u'=1.\r\n-    * Let t'=t unless t==1, in which case let t'=1.\r\n-    * Let t''=t unless u'^3 + + 7 + t'^2 == 0, in which case let t''=2*t'.\r\n+    * Let t'=t unless t==0, in which case let t'=1.\r\n+    * Let t''=t' unless u'^3 + 7 + t'^2 == 0, in which case let t''=2*t'.\r\n     * Let X=(u'^3 + 7 - t''^2)/(2*t'')\r\n     * Let Y=(u'^3 + 7 + t''^2)/(2*c*t''*u')\r\n-    * Let x be the first element out of [u+4*Y^2, (-X/Y-u)/2, (X/Y-u)/2] for which\r\n+    * Let x be the first element out of [u'+4*Y^2, (-X/Y-u')/2, (X/Y-u')/2] for which\r\n       x^3 + 7 is square (there will always be at least one).\r\n     * Let y be the square root of x^3 + 7 which has the same parity as t.\r\n     * Return the point with affine coordinates (x, y)\r\n```\r\nCould probably simply take the version of the decoding algorithm included in `include/secp256k1_ellswift.h` (or even completely remove it from the commit body, as it's added to the header in the same commit anyways?).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1484936885",
      "submitted_at": "2023-06-18T00:32:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9559898455,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI50HlX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9559898455",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-18T01:06:17Z"
    },
    {
      "event": "commented",
      "id": 1595914313,
      "node_id": "IC_kwDOAP4Jqs5fH7hJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1595914313",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-18T01:06:28Z",
      "updated_at": "2023-06-18T01:06:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made this change:\r\n```diff\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -296,7 +296,7 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n     if ((c & 5) == 0 || (c & 5) == 5) {\r\n         secp256k1_fe_negate(&m, &m, 1); /* m = -w */\r\n     }\r\n-    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\r\n+    /* Now m = {-w if c&5=0 or c&5=5; w otherwise}. */\r\n     secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\r\n     /* u = {c4 if c&1=1; c3 otherwise}*u */\r\n     secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1595914313",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "commented",
      "id": 1595914425,
      "node_id": "IC_kwDOAP4Jqs5fH7i5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1595914425",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-18T01:07:05Z",
      "updated_at": "2023-06-18T18:05:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "@theStack Thanks. I've dropped the scheme definition from the commit message. It's well documented in the code, the .h file, and the .md document.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1595914425",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 9559899271,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAI50HyH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9559899271",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-18T01:07:05Z"
    },
    {
      "event": "subscribed",
      "id": 9559899273,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAI50HyJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9559899273",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-18T01:07:05Z"
    },
    {
      "event": "referenced",
      "id": 9561769299,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI57QVT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9561769299",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "30574f22ea0d158a0414323f8c350fa8ddcabd30",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/30574f22ea0d158a0414323f8c350fa8ddcabd30",
      "created_at": "2023-06-18T18:34:51Z"
    },
    {
      "event": "reviewed",
      "id": 1487005600,
      "node_id": "PRR_kwDOAP4Jqs5Yoeeg",
      "url": null,
      "actor": null,
      "commit_id": "55efb1cb525c1b264c57c35203d1b83109948d5e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Verified that the code in the decoding/encoding functions `secp256k1_ellswift_xswiftec_frac_var` and `secp256k1_ellswift_xswiftec_inv_var` match the algorithm written in comments each (https://github.com/sipa/secp256k1/blob/55efb1cb525c1b264c57c35203d1b83109948d5e/src/modules/ellswift/main_impl.h#L74-L84 and https://github.com/sipa/secp256k1/blob/55efb1cb525c1b264c57c35203d1b83109948d5e/src/modules/ellswift/main_impl.h#L170-L189). Still planning to do a pen-and-paper review for the algorithm simplifications steps / substitutions pointed out in `secp256k1_ellswift_xswiftec_frac_var`.\r\n\r\nLeft two nits below (unrelated to the functions above), regarding API doc and the ellswift benchmark.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1487005600",
      "submitted_at": "2023-06-19T23:54:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1488237223,
      "node_id": "PRR_kwDOAP4Jqs5YtLKn",
      "url": null,
      "actor": null,
      "commit_id": "55efb1cb525c1b264c57c35203d1b83109948d5e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 55efb1cb525c1b264c57c35203d1b83109948d5e\r\n\r\nHere's a branch with some fixup comments, with commits prepared for `git rebase --interactive --autosquash`:  https://github.com/real-or-random/secp256k1/tree/202206_ellswift_dh\r\nYou are welcome to apply or reject; ACK anyway. My initial plan was to have only comment nits, but I found two further refinements on the way, see the commits there. \r\n\r\n*edit: It's probably clear to you, but I recommend first taking whatever fixup commits you want from my branch, and then addressing other review commits from @theStack here in order to minimize conflicts. ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1488237223",
      "submitted_at": "2023-06-20T14:02:16Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGE1OTdhNWE5Y2VkYzI3ZWI2YTExOTBiMTk1OWNiOWZlMGQyNmE3ZGM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc",
      "tree": {
        "sha": "0de9734de179adf3fda8e980007d62bab2c18fd4",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/0de9734de179adf3fda8e980007d62bab2c18fd4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/30574f22ea0d158a0414323f8c350fa8ddcabd30",
          "sha": "30574f22ea0d158a0414323f8c350fa8ddcabd30",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/30574f22ea0d158a0414323f8c350fa8ddcabd30"
        }
      ],
      "message": "Add benchmark for key generation",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T14:57:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-07-07T18:45:21Z"
      },
      "sha": "a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc5ZTViMmE4YjgwZjUwN2UyYzk5MzZmZjFjNGUyZmIzOWJjNjZhNGU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e",
      "tree": {
        "sha": "a9a143a394b97d9101a506e6116970fdf8948094",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a9a143a394b97d9101a506e6116970fdf8948094"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc",
          "sha": "a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a597a5a9cedc27eb6a1190b1959cb9fe0d26a7dc"
        }
      ],
      "message": "Add functions to test if X coordinate is valid",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:05:32Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T20:17:56Z"
      },
      "sha": "79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9580936346,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI7EXya",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9580936346",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:08:59Z"
    },
    {
      "event": "commented",
      "id": 1598984713,
      "node_id": "IC_kwDOAP4Jqs5fTpIJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1598984713",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:10:42Z",
      "updated_at": "2023-06-20T15:10:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "Squashed in @real-or-random's fixups:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_ellswift.h b/include/secp256k1_ellswift.h\r\nindex b0284d2b..d20fc0cc 100644\r\n--- a/include/secp256k1_ellswift.h\r\n+++ b/include/secp256k1_ellswift.h\r\n@@ -60,11 +60,11 @@ extern \"C\" {\r\n  *           data:       arbitrary data pointer that is passed through\r\n  */\r\n typedef int (*secp256k1_ellswift_xdh_hash_function)(\r\n-  unsigned char *output,\r\n-  const unsigned char *x32,\r\n-  const unsigned char *ell_a64,\r\n-  const unsigned char *ell_b64,\r\n-  void *data\r\n+    unsigned char *output,\r\n+    const unsigned char *x32,\r\n+    const unsigned char *ell_a64,\r\n+    const unsigned char *ell_b64,\r\n+    void *data\r\n );\r\n \r\n /** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\r\ndiff --git a/src/group_impl.h b/src/group_impl.h\r\nindex 8f6e05e0..dcd171f5 100644\r\n--- a/src/group_impl.h\r\n+++ b/src/group_impl.h\r\n@@ -823,8 +823,7 @@ static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\r\n #endif\r\n }\r\n \r\n-static int secp256k1_ge_x_on_curve_var(const secp256k1_fe *x)\r\n-{\r\n+static int secp256k1_ge_x_on_curve_var(const secp256k1_fe *x) {\r\n     secp256k1_fe c;\r\n     secp256k1_fe_sqr(&c, x);\r\n     secp256k1_fe_mul(&c, &c, x);\r\ndiff --git a/src/modules/ellswift/main_impl.h b/src/modules/ellswift/main_impl.h\r\nindex b021be3f..103ab40b 100644\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -24,112 +24,112 @@ static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4,\r\n static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\r\n     /* The implemented algorithm is the following (all operations in GF(p)):\r\n      *\r\n-     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\r\n-     * - If u=0, set u=1.\r\n-     * - If t=0, set t=1.\r\n-     * - If u^3+7+t^2 = 0, set t=2*t.\r\n-     * - Let X=(u^3+7-t^2)/(2*t)\r\n-     * - Let Y=(X+t)/(c0*u)\r\n-     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\r\n-     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\r\n-     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\r\n+     * - Let c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852.\r\n+     * - If u = 0, set u = 1.\r\n+     * - If t = 0, set t = 1.\r\n+     * - If u^3+7+t^2 = 0, set t = 2*t.\r\n+     * - Let X = (u^3+7-t^2)/(2*t).\r\n+     * - Let Y = (X+t)/(c0*u).\r\n+     * - If x3 = u+4*Y^2 is a valid x coordinate, return it.\r\n+     * - If x2 = (-X/Y-u)/2 is a valid x coordinate, return it.\r\n+     * - Return x1 = (X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\r\n      *\r\n      * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\r\n      *\r\n      * - Let c0 = ...\r\n-     * - If u=0, set u=1.\r\n-     * - If t=0, set t=1.\r\n-     * - Let s=t^2\r\n-     * - Let g=u^3+7\r\n-     * - If g+s=0, set t=2*t, s=4*s\r\n-     * - Let X=(g-s)/(2*t)\r\n-     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\r\n-     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\r\n-     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\r\n-     * - Return x1=-(x2+u).\r\n+     * - If u = 0, set u = 1.\r\n+     * - If t = 0, set t = 1.\r\n+     * - Let s = t^2\r\n+     * - Let g = u^3+7\r\n+     * - If g+s = 0, set t = 2*t, s = 4*s\r\n+     * - Let X = (g-s)/(2*t).\r\n+     * - Let Y = (X+t)/(c0*u) = (g+s)/(2*c0*t*u).\r\n+     * - If x3 = u+4*Y^2 is a valid x coordinate, return it.\r\n+     * - If x2 = (-X/Y-u)/2 is a valid x coordinate, return it.\r\n+     * - Return x1 = -(x2+u).\r\n      *\r\n      * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\r\n      * means X and Y do not need to be evaluated explicitly anymore.\r\n      *\r\n      * - ...\r\n-     * - If g+s=0, set s=4*s\r\n-     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\r\n-     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\r\n-     * - Return x1=-(x2+u).\r\n+     * - If g+s = 0, set s = 4*s.\r\n+     * - If x3 = u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\r\n+     * - If x2 = (-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\r\n+     * - Return x1 = -(x2+u).\r\n      *\r\n      * Simplifying x2 using 2 additional constants:\r\n      *\r\n-     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\r\n-     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\r\n+     * - Let c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40.\r\n+     * - Let c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee.\r\n      * - ...\r\n-     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\r\n+     * - If x2 = u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\r\n      * - ...\r\n      *\r\n      * Writing x3 as a fraction:\r\n      *\r\n      * - ...\r\n-     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\r\n+     * - If x3 = (3*s*u^3-(g+s)^2)/(3*s*u^2) ...\r\n      * - ...\r\n \r\n      * Overall, we get:\r\n      *\r\n-     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\r\n-     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\r\n-     * - If u=0, set u=1.\r\n-     * - If t=0, set s=1, else set s=t^2\r\n-     * - Let g=u^3+7\r\n-     * - If g+s=0, set s=4*s\r\n-     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\r\n-     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\r\n-     * - Return x1=-(x2+u)\r\n+     * - Let c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40.\r\n+     * - Let c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee.\r\n+     * - If u = 0, set u = 1.\r\n+     * - If t = 0, set s = 1, else set s = t^2.\r\n+     * - Let g = u^3+7.\r\n+     * - If g+s = 0, set s = 4*s.\r\n+     * - If x3 = (3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\r\n+     * - If x2 = u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\r\n+     * - Return x1 = -(x2+u).\r\n      */\r\n     secp256k1_fe u1, s, g, p, d, n, l;\r\n     u1 = *u;\r\n     if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\r\n     secp256k1_fe_sqr(&s, t);\r\n     if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\r\n-    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\r\n-    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\r\n-    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\r\n-    p = g; /* p = g */\r\n-    secp256k1_fe_add(&p, &s); /* p = g+s */\r\n+    secp256k1_fe_sqr(&l, &u1);                                   /* l = u^2 */\r\n+    secp256k1_fe_mul(&g, &l, &u1);                               /* g = u^3 */\r\n+    secp256k1_fe_add_int(&g, SECP256K1_B);                       /* g = u^3 + 7 */\r\n+    p = g;                                                       /* p = g */\r\n+    secp256k1_fe_add(&p, &s);                                    /* p = g+s */\r\n     if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\r\n-        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\r\n-        /* recompute p = g+s */\r\n-        p = g; /* p = g */\r\n-        secp256k1_fe_add(&p, &s); /* p = g+s */\r\n-    }\r\n-    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\r\n-    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\r\n-    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\r\n-    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\r\n-    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\r\n-    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\r\n-    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\r\n-        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\r\n+        secp256k1_fe_mul_int(&s, 4);\r\n+        /* Recompute p = g+s */\r\n+        p = g;                                                   /* p = g */\r\n+        secp256k1_fe_add(&p, &s);                                /* p = g+s */\r\n+    }                                              \r\n+    secp256k1_fe_mul(&d, &s, &l);                                /* d = s*u^2 */\r\n+    secp256k1_fe_mul_int(&d, 3);                                 /* d = 3*s*u^2 */\r\n+    secp256k1_fe_sqr(&l, &p);                                    /* l = (g+s)^2 */\r\n+    secp256k1_fe_negate(&l, &l, 1);                              /* l = -(g+s)^2 */\r\n+    secp256k1_fe_mul(&n, &d, &u1);                               /* n = 3*s*u^3 */\r\n+    secp256k1_fe_add(&n, &l);                                    /* n = 3*s*u^3-(g+s)^2 */\r\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {              \r\n+        /* Return x3 = n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\r\n         *xn = n;\r\n         *xd = d;\r\n         return;\r\n     }\r\n     *xd = p;\r\n-    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\r\n-    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\r\n-    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\r\n-    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\r\n-    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\r\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s);            /* l = c1*s */\r\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g);            /* n = c2*g */\r\n+    secp256k1_fe_add(&n, &l);                                    /* n = c1*s+c2*g */\r\n+    secp256k1_fe_mul(&n, &n, &u1);                               /* n = u*(c1*s+c2*g) */\r\n+    /* Possible optimization: in the invocation below, p^2 = (g+s)^2 is computed,\r\n      * which we already have computed above. This could be deduplicated. */\r\n     if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\r\n-        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\r\n+        /* Return x2 = n/p = u*(c1*s+c2*g)/(g+s) */\r\n         *xn = n;\r\n         return;\r\n     }\r\n-    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\r\n-    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\r\n-    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\r\n+    secp256k1_fe_mul(&l, &p, &u1);                               /* l = u*(g+s) */\r\n+    secp256k1_fe_add(&n, &l);                                    /* n = u*(c1*s+c2*g)+u*(g+s) */\r\n+    secp256k1_fe_negate(xn, &n, 2);                              /* n = -u*(c1*s+c2*g)-u*(g+s) */\r\n #ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\r\n #endif\r\n-    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\r\n+    /* Return x3 = n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\r\n }\r\n \r\n /** Decode ElligatorSwift encoding (u, t) to X coordinate. */\r\n@@ -182,12 +182,12 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n      *   - If s=0, fail.\r\n      *   - Let v=(r/s-u)/2.\r\n      * - Let w=sqrt(s).\r\n-     * - If (c & 5) = 0: return -w*(c3*u + v)\r\n-     * - If (c & 5) = 1: return  w*(c4*u + v)\r\n-     * - If (c & 5) = 4: return  w*(c3*u + v)\r\n-     * - If (c & 5) = 5: return -w*(c4*u + v)\r\n+     * - If (c & 5) = 0: return -w*(c3*u + v).\r\n+     * - If (c & 5) = 1: return  w*(c4*u + v).\r\n+     * - If (c & 5) = 4: return  w*(c3*u + v).\r\n+     * - If (c & 5) = 5: return -w*(c4*u + v).\r\n      */\r\n-    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\r\n+    secp256k1_fe x = *x_in, u = *u_in, g, v, s, m, r, q;\r\n     int ret;\r\n \r\n     secp256k1_fe_normalize_weak(&x);\r\n@@ -205,28 +205,28 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n         /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\r\n          * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\r\n          * would not match x). */\r\n-        m = x; /* m = x */\r\n-        secp256k1_fe_add(&m, &u); /* m = u+x */\r\n-        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\r\n-        /* test if (-u-x) is a valid X coordinate. If so, fail. */\r\n+        m = x;                                          /* m = x */\r\n+        secp256k1_fe_add(&m, &u);                       /* m = u+x */\r\n+        secp256k1_fe_negate(&m, &m, 2);                 /* m = -u-x */\r\n+        /* Test if (-u-x) is a valid X coordinate. If so, fail. */\r\n         if (secp256k1_ge_x_on_curve_var(&m)) return 0;\r\n \r\n         /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\r\n-        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\r\n-        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\r\n-        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\r\n-        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\r\n-\r\n-        /* Note that at this point, s=0 is impossible. If it were the case:\r\n-         *    s = -(u^2 + u*x + x^2) = 0.\r\n-         * => u^2 + u*x + x^2 = 0\r\n-         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\r\n+        secp256k1_fe_sqr(&s, &m);                       /* s = (u+x)^2 */\r\n+        secp256k1_fe_negate(&s, &s, 1);                 /* s = -(u+x)^2 */\r\n+        secp256k1_fe_mul(&m, &u, &x);                   /* m = u*x */\r\n+        secp256k1_fe_add(&s, &m);                       /* s = -(u^2 + u*x + x^2) */\r\n+\r\n+        /* Note that at this point, s = 0 is impossible. If it were the case:\r\n+         *             s = -(u^2 + u*x + x^2) = 0\r\n+         * =>                 u^2 + u*x + x^2 = 0\r\n+         * =>   (u + 2*x) * (u^2 + u*x + x^2) = 0\r\n          * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\r\n-         * => (x + u)^3 + x^3 = 0\r\n-         * => x^3 = -(x + u)^3\r\n-         * => x^3 + B = (-u - x)^3 + B\r\n+         * =>                 (x + u)^3 + x^3 = 0\r\n+         * =>                             x^3 = -(x + u)^3\r\n+         * =>                         x^3 + B = (-u - x)^3 + B\r\n          *\r\n-         * However, We know x^3 + B is square (because x is on the curve) and\r\n+         * However, we know x^3 + B is square (because x is on the curve) and\r\n          * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\r\n          * test above would have failed). This is a contradiction, and thus the\r\n          * assumption s=0 is false. */\r\n@@ -237,15 +237,15 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n         /* If s is not square, fail. We have not fully computed s yet, but s is square iff\r\n          * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\r\n          * nonzero). */\r\n-        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\r\n-        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\r\n-        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\r\n-        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\r\n+        secp256k1_fe_sqr(&g, &u);                       /* g = u^2 */\r\n+        secp256k1_fe_mul(&g, &g, &u);                   /* g = u^3 */\r\n+        secp256k1_fe_add_int(&g, SECP256K1_B);          /* g = u^3+7 */\r\n+        secp256k1_fe_mul(&m, &s, &g);                   /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\r\n         if (!secp256k1_fe_is_square_var(&m)) return 0;\r\n \r\n         /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\r\n-        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\r\n-        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\r\n+        secp256k1_fe_inv_var(&s, &s);                   /* s = -1/(u^2 + u*x + x^2) [no div by 0] */\r\n+        secp256k1_fe_mul(&s, &s, &g);                   /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\r\n \r\n         /* Let v = x. */\r\n         v = x;\r\n@@ -253,61 +253,60 @@ static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_\r\n         /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\r\n \r\n         /* Let s = x-u. */\r\n-        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\r\n-        s = m; /* s = -u */\r\n-        secp256k1_fe_add(&s, &x); /* s = x-u */\r\n+        secp256k1_fe_negate(&m, &u, 1);                 /* m = -u */\r\n+        s = m;                                          /* s = -u */\r\n+        secp256k1_fe_add(&s, &x);                       /* s = x-u */\r\n \r\n         /* If s is not square, fail. */\r\n         if (!secp256k1_fe_is_square_var(&s)) return 0;\r\n \r\n         /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\r\n-        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\r\n-        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\r\n-        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\r\n-        secp256k1_fe_normalize_weak(&g);\r\n-        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\r\n-        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\r\n-        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\r\n-        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\r\n-        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\r\n-        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\r\n+        secp256k1_fe_sqr(&g, &u);                       /* g = u^2 */\r\n+        secp256k1_fe_mul(&q, &s, &g);                   /* q = s*u^2 */\r\n+        secp256k1_fe_mul_int(&q, 3);                    /* q = 3*s*u^2 */\r\n+        secp256k1_fe_mul(&g, &g, &u);                   /* g = u^3 */\r\n+        secp256k1_fe_mul_int(&g, 4);                    /* g = 4*u^3 */\r\n+        secp256k1_fe_add_int(&g, 4 * SECP256K1_B);      /* g = 4*(u^3+7) */\r\n+        secp256k1_fe_add(&q, &g);                       /* q = 4*(u^3+7)+3*s*u^2 */\r\n+        secp256k1_fe_mul(&q, &q, &s);                   /* q = s*(4*(u^3+7)+3*u^2*s) */\r\n+        secp256k1_fe_negate(&q, &q, 1);                 /* q = -s*(4*(u^3+7)+3*u^2*s) */\r\n         if (!secp256k1_fe_is_square_var(&q)) return 0;\r\n-        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\r\n+        ret = secp256k1_fe_sqrt(&r, &q);                /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\r\n         VERIFY_CHECK(ret);\r\n \r\n         /* If (c & 1) = 1 and r = 0, fail. */\r\n         if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\r\n \r\n-        /* If s=0, fail. */\r\n+        /* If s = 0, fail. */\r\n         if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\r\n \r\n-        /* Let v=(r/s-u)/2. */\r\n-        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\r\n-        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\r\n-        secp256k1_fe_add(&v, &m); /* v=r/s-u */\r\n-        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\r\n+        /* Let v = (r/s-u)/2. */\r\n+        secp256k1_fe_inv_var(&v, &s);                   /* v = 1/s [no div by 0] */\r\n+        secp256k1_fe_mul(&v, &v, &r);                   /* v = r/s */\r\n+        secp256k1_fe_add(&v, &m);                       /* v = r/s-u */\r\n+        secp256k1_fe_half(&v);                          /* v = (r/s-u)/2 */\r\n     }\r\n \r\n-    /* Let w=sqrt(s). */\r\n-    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\r\n+    /* Let w = sqrt(s). */\r\n+    ret = secp256k1_fe_sqrt(&m, &s);                    /* m = sqrt(s) = w */\r\n     VERIFY_CHECK(ret);\r\n \r\n     /* Return logic. */\r\n     if ((c & 5) == 0 || (c & 5) == 5) {\r\n-        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\r\n+        secp256k1_fe_negate(&m, &m, 1);                 /* m = -w */\r\n     }\r\n     /* Now m = {-w if c&5=0 or c&5=5; w otherwise}. */\r\n     secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\r\n     /* u = {c4 if c&1=1; c3 otherwise}*u */\r\n-    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\r\n+    secp256k1_fe_add(&u, &v);                           /* u = {c4 if c&1=1; c3 otherwise}*u + v */\r\n     secp256k1_fe_mul(t, &m, &u);\r\n     return 1;\r\n }\r\n \r\n /** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\r\n  *\r\n- * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\r\n- * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\r\n+ * hasher is a SHA256 object to which an incrementing 4-byte counter is written to generate randomness.\r\n+ * Writing 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\r\n  * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\r\n static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\r\n     secp256k1_sha256 hash = *hasher;\r\ndiff --git a/src/tests.c b/src/tests.c\r\nindex 3ce87bfe..8ada3f86 100644\r\n--- a/src/tests.c\r\n+++ b/src/tests.c\r\n@@ -3945,7 +3945,7 @@ static void test_ge(void) {\r\n         free(ge_set_all);\r\n     }\r\n \r\n-    /* Test all elements have X coordinates on the curve. */\r\n+    /* Test that all elements have X coordinates on the curve. */\r\n     for (i = 1; i < 4 * runs + 1; i++) {\r\n         secp256k1_fe n;\r\n         CHECK(secp256k1_ge_x_on_curve_var(&ge[i].x));\r\n@@ -3954,7 +3954,7 @@ static void test_ge(void) {\r\n         CHECK(secp256k1_ge_x_frac_on_curve_var(&n, &zf));\r\n     }\r\n \r\n-    /* Test correspondence secp256k1_ge_x{,_frac}_on_curve_var with ge_set_xo. */\r\n+    /* Test correspondence of secp256k1_ge_x{,_frac}_on_curve_var with ge_set_xo. */\r\n     {\r\n         secp256k1_fe n;\r\n         secp256k1_ge q;\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1598984713",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 9580954996,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAI7EcV0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9580954996",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:10:43Z"
    },
    {
      "event": "subscribed",
      "id": 9580955009,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAI7EcWB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9580955009",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:10:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9581103003,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI7FAeb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581103003",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:23:50Z"
    },
    {
      "event": "commented",
      "id": 1599010349,
      "node_id": "IC_kwDOAP4Jqs5fTvYt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1599010349",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:24:15Z",
      "updated_at": "2023-06-20T15:24:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Addressed comments by @theStack and @real-or-random:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_ellswift.h b/include/secp256k1_ellswift.h\r\nindex d20fc0cc..3851f930 100644\r\n--- a/include/secp256k1_ellswift.h\r\n+++ b/include/secp256k1_ellswift.h\r\n@@ -145,7 +145,7 @@ SECP256K1_API int secp256k1_ellswift_decode(\r\n  * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\r\n  * key as entropy for the encoding (supplemented with auxrnd32, if provided).\r\n  *\r\n- * Like secp256k1_ellswift_encode, this function does not guaranteed that the\r\n+ * Like secp256k1_ellswift_encode, this function does not guarantee that the\r\n  * computed encoding is stable across versions of the library, even if all\r\n  * arguments (including auxrnd32) are the same.\r\n  */\r\ndiff --git a/src/modules/ellswift/bench_impl.h b/src/modules/ellswift/bench_impl.h\r\nindex 1b0ce6a7..b16a3a36 100644\r\n--- a/src/modules/ellswift/bench_impl.h\r\n+++ b/src/modules/ellswift/bench_impl.h\r\n@@ -94,7 +94,6 @@ void run_ellswift_bench(int iters, int argc, char **argv) {\r\n \r\n     /* create a context with signing capabilities */\r\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\r\n-    memset(data.rnd64, 11, sizeof(data.rnd64));\r\n \r\n     if (d || have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"encode\") || have_flag(argc, argv, \"ellswift_encode\")) run_benchmark(\"ellswift_encode\", bench_ellswift_encode, bench_ellswift_setup, NULL, &data, 10, iters);\r\n     if (d || have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"decode\") || have_flag(argc, argv, \"ellswift_decode\")) run_benchmark(\"ellswift_decode\", bench_ellswift_decode, bench_ellswift_setup, NULL, &data, 10, iters);\r\ndiff --git a/src/modules/ellswift/main_impl.h b/src/modules/ellswift/main_impl.h\r\nindex 103ab40b..374c70cd 100644\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -427,6 +427,7 @@ int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64\r\n         return 1;\r\n     }\r\n     /* Only reached in case the provided pubkey is invalid. */\r\n+    memset(ell64, 0, 64);\r\n     return 0;\r\n }\r\n ```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1599010349",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "mentioned",
      "id": 9581107972,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAI7FBsE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581107972",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:24:16Z"
    },
    {
      "event": "subscribed",
      "id": 9581107996,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAI7FBsc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581107996",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:24:16Z"
    },
    {
      "event": "mentioned",
      "id": 9581108016,
      "node_id": "MEE_lADOAP4Jqs5OUBcRzwAAAAI7FBsw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581108016",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:24:16Z"
    },
    {
      "event": "subscribed",
      "id": 9581108035,
      "node_id": "SE_lADOAP4Jqs5OUBcRzwAAAAI7FBtD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581108035",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:24:16Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM0NzkxN2JiZDYyYzQ4OGZiMTY4NDMxMTY5YzFmZmU3ODA1NjJkYTE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c47917bbd62c488fb168431169c1ffe780562da1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c47917bbd62c488fb168431169c1ffe780562da1",
      "tree": {
        "sha": "b5c904fd8708179fe944ff093c999b6acb224482",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b5c904fd8708179fe944ff093c999b6acb224482"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e",
          "sha": "79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e"
        }
      ],
      "message": "Add ellswift module implementing ElligatorSwift\n\nThe scheme implemented is described below, and largely follows the paper\n\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\",\nby Chavez-Saab, Rodriguez-Henriquez, and Tibouchi\n(https://eprint.iacr.org/2022/759).\n\nA new 64-byte public key format is introduced, with the property that *every*\n64-byte array is an encoding for a non-infinite curve point. Each curve point\nhas roughly 2^256 distinct encodings. This permits disguising public keys as\nuniformly random bytes.\n\nThe new API functions:\n* secp256k1_ellswift_encode: convert a normal public key to an ellswift 64-byte\n  public key, using additional entropy to pick among the many possible\n  encodings.\n* secp256k1_ellswift_decode: convert an ellswift 64-byte public key to a normal\n  public key.\n* secp256k1_ellswift_create: a faster and safer equivalent to calling\n  secp256k1_ec_pubkey_create + secp256k1_ellswift_encode.\n* secp256k1_ellswift_xdh: x-only ECDH directly on ellswift 64-byte public keys,\n  where the key encodings are fed to the hash function.\n\nThe scheme itself is documented in secp256k1_ellswift.h.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T20:18:40Z"
      },
      "sha": "c47917bbd62c488fb168431169c1ffe780562da1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk2OTVkZWIzNTFlNzc0MmY3OGRjNGVkNzJkZWE2NjU1ZGNmNmJiMGU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9695deb351e7742f78dc4ed72dea6655dcf6bb0e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9695deb351e7742f78dc4ed72dea6655dcf6bb0e",
      "tree": {
        "sha": "b526ed3d8b86adf351c0cc3c77bc8f0bc4a4ca03",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b526ed3d8b86adf351c0cc3c77bc8f0bc4a4ca03"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c47917bbd62c488fb168431169c1ffe780562da1",
          "sha": "c47917bbd62c488fb168431169c1ffe780562da1",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c47917bbd62c488fb168431169c1ffe780562da1"
        }
      ],
      "message": "Add tests for ellswift module\n\nThese include both test vectors taken from BIP324, as randomized unit tests.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T19:59:33Z"
      },
      "sha": "9695deb351e7742f78dc4ed72dea6655dcf6bb0e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGRmNjMzY2RlYmExMzNhOTQ2OGM0M2YwNTUxMjJiMDdiZjEwMmRkMmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/df633cdeba133a9468c43f055122b07bf102dd2d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/df633cdeba133a9468c43f055122b07bf102dd2d",
      "tree": {
        "sha": "c9b93b2b801c0685563dce5088e062f1bc901fd5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c9b93b2b801c0685563dce5088e062f1bc901fd5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9695deb351e7742f78dc4ed72dea6655dcf6bb0e",
          "sha": "9695deb351e7742f78dc4ed72dea6655dcf6bb0e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9695deb351e7742f78dc4ed72dea6655dcf6bb0e"
        }
      ],
      "message": "Add _prefix and _bip324 ellswift_xdh hash functions",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-05-05T08:37:30Z"
      },
      "sha": "df633cdeba133a9468c43f055122b07bf102dd2d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDJkMWQ0MWFjZjg1YTM4NWJlNmM0MzYzMDdlYjgyNjEyMmMyMTg0NmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2d1d41acf85a385be6c436307eb826122c21846f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2d1d41acf85a385be6c436307eb826122c21846f",
      "tree": {
        "sha": "48d9111e0f7852467406864157396ea84d1493cd",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/48d9111e0f7852467406864157396ea84d1493cd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/df633cdeba133a9468c43f055122b07bf102dd2d",
          "sha": "df633cdeba133a9468c43f055122b07bf102dd2d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/df633cdeba133a9468c43f055122b07bf102dd2d"
        }
      ],
      "message": "Add ctime tests for ellswift module",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T19:52:12Z"
      },
      "sha": "2d1d41acf85a385be6c436307eb826122c21846f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDFiY2VhOGM1N2YzZjIzMmM4ZTkxZDllYjNhYWQ1MjI3NjZkMTMwMjY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1bcea8c57f3f232c8e91d9eb3aad522766d13026",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1bcea8c57f3f232c8e91d9eb3aad522766d13026",
      "tree": {
        "sha": "11a5028275342c53c4c344def1cceb0cc1190d6a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/11a5028275342c53c4c344def1cceb0cc1190d6a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2d1d41acf85a385be6c436307eb826122c21846f",
          "sha": "2d1d41acf85a385be6c436307eb826122c21846f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2d1d41acf85a385be6c436307eb826122c21846f"
        }
      ],
      "message": "Add benchmarks for ellswift module",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T20:21:54Z"
      },
      "sha": "1bcea8c57f3f232c8e91d9eb3aad522766d13026"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDRmMDkxODQ3YzIwYzllOWRkM2NlY2UyZThiNjI1NDkyNzhlNTAyOGI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4f091847c20c9e9dd3cece2e8b62549278e5028b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4f091847c20c9e9dd3cece2e8b62549278e5028b",
      "tree": {
        "sha": "cbecf3db543175daad469c4c657ba01a518a6371",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/cbecf3db543175daad469c4c657ba01a518a6371"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1bcea8c57f3f232c8e91d9eb3aad522766d13026",
          "sha": "1bcea8c57f3f232c8e91d9eb3aad522766d13026",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1bcea8c57f3f232c8e91d9eb3aad522766d13026"
        }
      ],
      "message": "Add ellswift testing to CI",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-04T20:21:25Z"
      },
      "sha": "4f091847c20c9e9dd3cece2e8b62549278e5028b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDkwZTM2MGFjYzI1MTFmMzEzOTY0ZTM5NDAwNWJhZmIzNzdiNGYxOTE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/90e360acc2511f313964e394005bafb377b4f191",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/90e360acc2511f313964e394005bafb377b4f191",
      "tree": {
        "sha": "3be4ef021ce1bfdcd662648a2dbc03ab1264aa5a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3be4ef021ce1bfdcd662648a2dbc03ab1264aa5a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4f091847c20c9e9dd3cece2e8b62549278e5028b",
          "sha": "4f091847c20c9e9dd3cece2e8b62549278e5028b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4f091847c20c9e9dd3cece2e8b62549278e5028b"
        }
      ],
      "message": "Add doc/ellswift.md with ElligatorSwift explanation",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-06-20T15:31:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-23T18:19:15Z"
      },
      "sha": "90e360acc2511f313964e394005bafb377b4f191"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9581202792,
      "node_id": "HRFPE_lADOAP4Jqs5OUBcRzwAAAAI7FY1o",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9581202792",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:32:12Z"
    },
    {
      "event": "commented",
      "id": 1599029055,
      "node_id": "IC_kwDOAP4Jqs5fTz8_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1599029055",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T15:32:30Z",
      "updated_at": "2023-06-20T15:32:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "And dropped some trailing spaces:\r\n\r\n```diff\r\ndiff --git a/src/modules/ellswift/main_impl.h b/src/modules/ellswift/main_impl.h\r\nindex 374c70cd..00bb8a3d 100644\r\n--- a/src/modules/ellswift/main_impl.h\r\n+++ b/src/modules/ellswift/main_impl.h\r\n@@ -98,14 +98,14 @@ static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe\r\n         /* Recompute p = g+s */\r\n         p = g;                                                   /* p = g */\r\n         secp256k1_fe_add(&p, &s);                                /* p = g+s */\r\n-    }                                              \r\n+    }\r\n     secp256k1_fe_mul(&d, &s, &l);                                /* d = s*u^2 */\r\n     secp256k1_fe_mul_int(&d, 3);                                 /* d = 3*s*u^2 */\r\n     secp256k1_fe_sqr(&l, &p);                                    /* l = (g+s)^2 */\r\n     secp256k1_fe_negate(&l, &l, 1);                              /* l = -(g+s)^2 */\r\n     secp256k1_fe_mul(&n, &d, &u1);                               /* n = 3*s*u^3 */\r\n     secp256k1_fe_add(&n, &l);                                    /* n = 3*s*u^3-(g+s)^2 */\r\n-    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {              \r\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\r\n         /* Return x3 = n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\r\n         *xn = n;\r\n         *xd = d;\r\n```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1599029055",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "commented",
      "id": 1599367416,
      "node_id": "IC_kwDOAP4Jqs5fVGj4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1599367416",
      "actor": {
        "login": "Davidson-Souza",
        "id": 40968167,
        "node_id": "MDQ6VXNlcjQwOTY4MTY3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40968167?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Davidson-Souza",
        "html_url": "https://github.com/Davidson-Souza",
        "followers_url": "https://api.github.com/users/Davidson-Souza/followers",
        "following_url": "https://api.github.com/users/Davidson-Souza/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Davidson-Souza/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Davidson-Souza/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Davidson-Souza/subscriptions",
        "organizations_url": "https://api.github.com/users/Davidson-Souza/orgs",
        "repos_url": "https://api.github.com/users/Davidson-Souza/repos",
        "events_url": "https://api.github.com/users/Davidson-Souza/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Davidson-Souza/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T19:14:33Z",
      "updated_at": "2023-06-20T19:14:33Z",
      "author_association": "NONE",
      "body": "tACK 90e360a. Full testing backlog:\r\n\r\n- Iterated through the implementation, checking all the math (the verbose comments helped a lot!)\r\n- Indepently generated all constants using python/sage (Python 3.10.10 and SageMath version 9.8, Release Date: 2023-02-11)\r\n- A \"manual mutation test\" for the valgrind ctime tests, adding some dummy, secret dependent branching, it indeed causes memcheck to complain about uninitialized values. Using `VALGRIND_MAKE_MEM_DEFINED` silences those warnings, as expected.\r\n- Executed all tests, including the memcheck ones (OS and hardware below). Compilation using both gcc and clang, configure script bellow.\r\n- The documentation is sound and very helpful\r\n\r\n## Test environments:\r\nConfig script: `[CC=clang] ./configure --with-valgrind=yes --enable-module-ecdh --enable-module-ellswift --enable-experimental --no-recursion`\r\n\r\nMachine 1: Arch Linux on a AMD Ryze 5 (Linux 6.1.21-hardened1-1-hardened #1 SMP PREEMPT_DYNAMIC x86_64 GNU/Linux )\r\ngcc version 12.2.1 20230201  \r\nclang version 14.0.7\r\nGNU libc stable release version 2.37.\r\nvalgrind-3.20.0\r\n\r\nMachine 2: Raspbian on a Raspbery Pi 4b (Linux raspberrypi 6.1.21-v8+ #1642 SMP PREEMPT aarch64 GNU/Linux)\r\ngcc version 10.2.1 20210110 (Debian 10.2.1-6)\r\nDebian clang version 11.0.1-2\r\nvalgrind-3.16.1\r\n(Debian GLIBC 2.31-13+rpt2+rpi1+deb11u5) stable release version 2.31\r\n\r\n## Benchmarks (only for the new module)\r\nMachine 1, clang\r\n```\r\nellswift_encode               ,    23.8       ,    24.1       ,    24.9    \r\nellswift_decode               ,    10.9       ,    11.4       ,    11.6    \r\nellswift_keygen               ,    55.3       ,    58.8       ,    61.7    \r\nellswift_ecdh                 ,    63.3       ,    64.1       ,    65.3 \r\n```\r\nMachine 1, gcc\r\n```\r\nellswift_encode               ,    22.6       ,    22.7       ,    22.9    \r\nellswift_decode               ,    10.7       ,    10.8       ,    11.0    \r\nellswift_keygen               ,    54.3       ,    54.7       ,    55.9    \r\nellswift_ecdh                 ,    62.7       ,    63.2       ,    64.1\r\n```\r\nMachine 2, clang\r\n```\r\nellswift_encode               ,    63.7       ,    63.7       ,    63.8    \r\nellswift_decode               ,    33.7       ,    33.8       ,    34.0    \r\nellswift_keygen               ,   177.0       ,   177.0       ,   178.0    \r\nellswift_ecdh                 ,   233.0       ,   234.0       ,   234.0\r\n```\r\nMachine 2, gcc\r\n```\r\nellswift_encode               ,    66.4       ,    66.4       ,    66.5    \r\nellswift_decode               ,    34.9       ,    34.9       ,    34.9    \r\nellswift_keygen               ,   182.0       ,   182.0       ,   183.0    \r\nellswift_ecdh                 ,   230.0       ,   231.0       ,   231.0  \r\n```",
      "user": {
        "login": "Davidson-Souza",
        "id": 40968167,
        "node_id": "MDQ6VXNlcjQwOTY4MTY3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40968167?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Davidson-Souza",
        "html_url": "https://github.com/Davidson-Souza",
        "followers_url": "https://api.github.com/users/Davidson-Souza/followers",
        "following_url": "https://api.github.com/users/Davidson-Souza/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Davidson-Souza/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Davidson-Souza/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Davidson-Souza/subscriptions",
        "organizations_url": "https://api.github.com/users/Davidson-Souza/orgs",
        "repos_url": "https://api.github.com/users/Davidson-Souza/repos",
        "events_url": "https://api.github.com/users/Davidson-Souza/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Davidson-Souza/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1599367416",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "reviewed",
      "id": 1489155963,
      "node_id": "PRR_kwDOAP4Jqs5Ywrd7",
      "url": null,
      "actor": null,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 90e360acc2511f313964e394005bafb377b4f191",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1489155963",
      "submitted_at": "2023-06-20T21:51:23Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "reviewed",
      "id": 1490512979,
      "node_id": "PRR_kwDOAP4Jqs5Y12xT",
      "url": null,
      "actor": null,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 90e360acc2511f313964e394005bafb377b4f191",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1490512979",
      "submitted_at": "2023-06-21T11:40:55Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "merged",
      "id": 9594683831,
      "node_id": "ME_lADOAP4Jqs5OUBcRzwAAAAI740G3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9594683831",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "705ce7ed8c1557a31e1bfc99be06082c5098d9f5",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/705ce7ed8c1557a31e1bfc99be06082c5098d9f5",
      "created_at": "2023-06-21T14:37:00Z"
    },
    {
      "event": "closed",
      "id": 9594683934,
      "node_id": "CE_lADOAP4Jqs5OUBcRzwAAAAI740Ie",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9594683934",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-21T14:37:00Z"
    },
    {
      "event": "commented",
      "id": 1600961512,
      "node_id": "IC_kwDOAP4Jqs5fbLvo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1600961512",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-21T14:37:44Z",
      "updated_at": "2023-06-21T14:37:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "This has been merged as it received adequate reviews and enough ACKs (as discussed in IRC). Post-merge ACKs are still welcome. If any issues still arise, they can be addressed in follow-up PRs.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1600961512",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "labeled",
      "id": 9594874766,
      "node_id": "LE_lADOAP4Jqs5OUBcRzwAAAAI75iuO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9594874766",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-21T14:51:30Z",
      "label": {
        "name": "needs-changelog",
        "color": "DBD8F4"
      }
    },
    {
      "event": "referenced",
      "id": 9595553747,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI78IfT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9595553747",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "901336eee751de088465e313dd8b500dfaf462b2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/901336eee751de088465e313dd8b500dfaf462b2",
      "created_at": "2023-06-21T15:44:14Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-21T17:05:41Z",
      "updated_at": "2023-06-21T17:05:41Z",
      "source": {
        "issue": {
          "id": 1767773789,
          "node_id": "PR_kwDOAP4Jqs5TjqMW",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1354",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1354/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1354/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1354/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1354",
          "number": 1354,
          "state": "closed",
          "state_reason": null,
          "title": "Add ellswift to CHANGELOG",
          "body": "A follow-up with a CHANGELOG entry for #1129.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 165020207,
              "node_id": "MDU6TGFiZWwxNjUwMjAyMDc=",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/documentation",
              "name": "documentation",
              "description": "",
              "color": "C5DEF5",
              "default": true
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1354",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1354",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1354.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1354.patch"
          },
          "closed_at": "2023-06-25T07:49:51Z",
          "created_at": "2023-06-21T14:43:28Z",
          "updated_at": "2023-06-25T07:49:51Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1489988983,
      "node_id": "PRR_kwDOAP4Jqs5Yz213",
      "url": null,
      "actor": null,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#pullrequestreview-1489988983",
      "submitted_at": "2023-06-23T18:58:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
    },
    {
      "event": "referenced",
      "id": 9629003956,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI97vC0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9629003956",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ac43613d250d1734b7fa5cfac643623e26aeff70",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/ac43613d250d1734b7fa5cfac643623e26aeff70",
      "created_at": "2023-06-25T07:49:50Z"
    },
    {
      "event": "unlabeled",
      "id": 9629004155,
      "node_id": "UNLE_lADOAP4Jqs5OUBcRzwAAAAI97vF7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9629004155",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-25T07:50:00Z",
      "label": {
        "name": "needs-changelog",
        "color": "DBD8F4"
      }
    },
    {
      "event": "referenced",
      "id": 9630799183,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI-ClVP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9630799183",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0c9f6b6ea25fcf99fa283b772968cad421fc7109",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/0c9f6b6ea25fcf99fa283b772968cad421fc7109",
      "created_at": "2023-06-25T20:21:02Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-25T20:23:13Z",
      "updated_at": "2023-06-25T20:23:13Z",
      "source": {
        "issue": {
          "id": 1773475479,
          "node_id": "PR_kwDOAP4Jqs5T2pwF",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1357",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1357/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1357/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1357/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1357",
          "number": 1357,
          "state": "closed",
          "state_reason": null,
          "title": "tests: refactor: take use of `secp256k1_ge_x_on_curve_var`",
          "body": "The recently merged ellswift PR (#1129) introduced a helper `secp256k1_ge_x_on_curve_var` to check if a given X coordinate is on the curve (i.e. the expression x^3 + 7 is square, see commit 79e5b2a8b80f507e2c9936ff1c4e2fb39bc66a4e). This can be used for code deduplication in the `ecmult_const_mult_xonly` test.\r\n\r\n(Found this instance via `$ git grep add_int.*SECP256K1_B`, I think it's the only one where the helper can be used.)",
          "user": {
            "login": "theStack",
            "id": 91535,
            "node_id": "MDQ6VXNlcjkxNTM1",
            "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/theStack",
            "html_url": "https://github.com/theStack",
            "followers_url": "https://api.github.com/users/theStack/followers",
            "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
            "organizations_url": "https://api.github.com/users/theStack/orgs",
            "repos_url": "https://api.github.com/users/theStack/repos",
            "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/theStack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5492448291,
              "node_id": "LA_kwDOAP4Jqs8AAAABR2AcIw",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/refactor/smell",
              "name": "refactor/smell",
              "description": "",
              "color": "FBCA04",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1357",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1357",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1357.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1357.patch"
          },
          "closed_at": "2023-06-27T07:37:56Z",
          "created_at": "2023-06-25T20:23:13Z",
          "updated_at": "2023-06-27T08:34:01Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 9630810431,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI-CoE_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9630810431",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "7d8d5c86df8b27b45e80ed50341dd0ce64546c0f",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/7d8d5c86df8b27b45e80ed50341dd0ce64546c0f",
      "created_at": "2023-06-25T20:27:32Z"
    },
    {
      "event": "referenced",
      "id": 9644028643,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI-1DLj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9644028643",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "679f825ba3aae45af4476f357a67f8e6ec9483e2",
      "commit_url": "https://api.github.com/repos/bitcoin-core/gui/commits/679f825ba3aae45af4476f357a67f8e6ec9483e2",
      "created_at": "2023-06-26T21:08:37Z"
    },
    {
      "event": "referenced",
      "id": 9648235103,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAI_FGJf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9648235103",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4494a369b6abfebfd9a674f752e881088ee3a4b6",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/4494a369b6abfebfd9a674f752e881088ee3a4b6",
      "created_at": "2023-06-27T07:37:56Z"
    },
    {
      "event": "commented",
      "id": 1610147512,
      "node_id": "IC_kwDOAP4Jqs5f-Oa4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1610147512",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-27T20:10:21Z",
      "updated_at": "2023-06-27T20:10:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "post-merge ACK 90e360a. \r\nrereviewed the code and skimmed through the swiftEC paper.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#issuecomment-1610147512",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1129"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-28T21:15:33Z",
      "updated_at": "2023-06-28T21:15:33Z",
      "source": {
        "issue": {
          "id": 1777183597,
          "node_id": "PR_kwDOAP4Jqs5UDDg3",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1362",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1362/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1362/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1362/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1362",
          "number": 1362,
          "state": "closed",
          "state_reason": null,
          "title": "build: Improvements to symbol visibility logic on Windows",
          "body": "This is a somewhat more elaborate alternative to #1346.\r\n\r\nAs I said there:\r\n> Many hours of researching and experimenting went into that piece of code, so I'll probably follow up with a PR that adds extensive comments.",
          "user": {
            "login": "real-or-random",
            "id": 1071625,
            "node_id": "MDQ6VXNlcjEwNzE2MjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/real-or-random",
            "html_url": "https://github.com/real-or-random",
            "followers_url": "https://api.github.com/users/real-or-random/followers",
            "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
            "organizations_url": "https://api.github.com/users/real-or-random/orgs",
            "repos_url": "https://api.github.com/users/real-or-random/repos",
            "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/real-or-random/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 165020207,
              "node_id": "MDU6TGFiZWwxNjUwMjAyMDc=",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/documentation",
              "name": "documentation",
              "description": "",
              "color": "C5DEF5",
              "default": true
            },
            {
              "id": 4975362431,
              "node_id": "LA_kwDOAP4Jqs8AAAABKI4Bfw",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/build",
              "name": "build",
              "description": "",
              "color": "2F66C4",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 18,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1362",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1362",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1362.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1362.patch"
          },
          "closed_at": "2023-06-29T15:54:44Z",
          "created_at": "2023-06-27T15:01:15Z",
          "updated_at": "2023-06-29T15:54:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 9696152427,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAJB74tr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9696152427",
      "actor": {
        "login": "vmta",
        "id": 23269741,
        "node_id": "MDQ6VXNlcjIzMjY5NzQx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23269741?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vmta",
        "html_url": "https://github.com/vmta",
        "followers_url": "https://api.github.com/users/vmta/followers",
        "following_url": "https://api.github.com/users/vmta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vmta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vmta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vmta/subscriptions",
        "organizations_url": "https://api.github.com/users/vmta/orgs",
        "repos_url": "https://api.github.com/users/vmta/repos",
        "events_url": "https://api.github.com/users/vmta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vmta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8f03457eede9abfd1d7a0d26abc379a710e16755",
      "commit_url": "https://api.github.com/repos/umkoin/umkoin/commits/8f03457eede9abfd1d7a0d26abc379a710e16755",
      "created_at": "2023-07-01T12:32:45Z"
    },
    {
      "event": "referenced",
      "id": 9883547465,
      "node_id": "REFE_lADOAP4Jqs5OUBcRzwAAAAJNGvdJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9883547465",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "270d2b37b88170cb5d7723354952128c6423f43d",
      "commit_url": "https://api.github.com/repos/hebasto/secp256k1-CMake-example/commits/270d2b37b88170cb5d7723354952128c6423f43d",
      "created_at": "2023-07-21T09:48:28Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-26T15:25:12Z",
      "updated_at": "2023-07-26T15:25:12Z",
      "source": {
        "issue": {
          "id": 1822660290,
          "node_id": "PR_kwDOAjZbZs5WdKS7",
          "url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/257",
          "repository_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp",
          "labels_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/257/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/257/comments",
          "events_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/257/events",
          "html_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/257",
          "number": 257,
          "state": "closed",
          "state_reason": null,
          "title": "Upstream PRs 1314, 1317, 1318, 1316, 1327, 1310, 1328, 1333, 1330, 1334, 1337, 1341, 1339, 1350, 1349, 1338, 1129, 1347, 1336, 1295, 1354, 1355, 1356",
          "body": "[bitcoin-core/secp256k1#1314]: release cleanup: bump version after 0.3.2\r\n[bitcoin-core/secp256k1#1317]: Make fe_cmov take max of magnitudes\r\n[bitcoin-core/secp256k1#1318]: build: Enable -DVERIFY for precomputation binaries\r\n[bitcoin-core/secp256k1#1316]: Do not invoke fe_is_zero on failed set_b32_limit\r\n[bitcoin-core/secp256k1#1327]: ci: Move wine prefix to /tmp to avoid error D8037 in cl.exe\r\n[bitcoin-core/secp256k1#1310]: Refine release process\r\n[bitcoin-core/secp256k1#1328]: build: Bump MSVC warning level up to W3\r\n[bitcoin-core/secp256k1#1333]: test: Warn if both `VERIFY` and `COVERAGE` are defined\r\n[bitcoin-core/secp256k1#1330]: refactor: take use of `secp256k1_scalar_{zero,one}` constants\r\n[bitcoin-core/secp256k1#1334]: fix input range comment for `secp256k1_fe_add_int`\r\n[bitcoin-core/secp256k1#1337]: ci: Fix error D8037 in `cl.exe` (attempt 2)\r\n[bitcoin-core/secp256k1#1341]: docs: correct `pubkey` param descriptions for `secp256k1_keypair_{xonly_,}pub`\r\n[bitcoin-core/secp256k1#1339]: scalar: refactor: use `secp256k1_{read,write}_be32` helpers\r\n[bitcoin-core/secp256k1#1350]: scalar: introduce and use `secp256k1_{read,write}_be64` helpers\r\n[bitcoin-core/secp256k1#1349]: Normalize ge produced from secp256k1_pubkey_load\r\n[bitcoin-core/secp256k1#1338]: Drop no longer needed `#include \"../include/secp256k1.h\"`\r\n[bitcoin-core/secp256k1#1129]: ElligatorSwift + integrated x-only DH\r\n[bitcoin-core/secp256k1#1347]: field: Document return value of fe_sqrt()\r\n[bitcoin-core/secp256k1#1336]: Use `__shiftright128` intrinsic in `secp256k1_u128_rshift` on MSVC\r\n[bitcoin-core/secp256k1#1295]: abi: Use dllexport for mingw builds\r\n[bitcoin-core/secp256k1#1354]: Add ellswift to CHANGELOG\r\n[bitcoin-core/secp256k1#1355]: Fix a typo in the error message\r\n[bitcoin-core/secp256k1#1356]: ci: Adjust Docker image to Debian 12 \"bookworm\"\r\n\r\nThis PR can be recreated with `./contrib/sync-upstream.sh -b sync-upstream range 799f4eec`.\r\nTip: Use `git show --remerge-diff` to show the changes manually added to the merge commit.",
          "user": {
            "login": "jonasnick",
            "id": 2582071,
            "node_id": "MDQ6VXNlcjI1ODIwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonasnick",
            "html_url": "https://github.com/jonasnick",
            "followers_url": "https://api.github.com/users/jonasnick/followers",
            "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
            "organizations_url": "https://api.github.com/users/jonasnick/orgs",
            "repos_url": "https://api.github.com/users/jonasnick/repos",
            "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonasnick/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/pulls/257",
            "html_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/257",
            "diff_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/257.diff",
            "patch_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/257.patch"
          },
          "closed_at": "2023-07-27T18:40:39Z",
          "created_at": "2023-07-26T15:25:11Z",
          "updated_at": "2023-07-27T18:40:40Z"
        },
        "type": "issue"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/927405587",
      "pull_request_review_id": 1047553401,
      "id": 927405587,
      "node_id": "PRRC_kwDOAP4Jqs43RxYT",
      "diff_hunk": "@@ -271,6 +276,8 @@ task:\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n+    ELLSWIFT: yes\n+    ELLSWIFT: yes",
      "path": ".cirrus.yml",
      "position": null,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "duplicate line",
      "created_at": "2022-07-22T08:12:52Z",
      "updated_at": "2022-07-22T08:28:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r927405587",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/927405587"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 279,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/927410144",
      "pull_request_review_id": 1047553401,
      "id": 927410144,
      "node_id": "PRRC_kwDOAP4Jqs43Ryfg",
      "diff_hunk": "@@ -590,4 +678,69 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1, or x must be 0. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    VERIFY_CHECK(g.v[0] >= 0 && g.v[1] >= 0 && g.v[2] >= 0 && g.v[3] >= 0 && g.v[4] >= 0);\n+\n+    /* The loop below does not converge for input g=0. Deal with this case specifically. */\n+    if (!(g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4])) return 0;\n+\n+    /* Do up to 25 iterations of 62 posdivsteps (up to 1550 steps; more is extremely rare) each until f=1.\n+     * In VERIFY mode use a lower number of iterations (744, close to the median 756), so failure actually occurs. */\n+#ifdef VERIFY\n+    for (count = 0; count < 12; ++count) {\n+#else\n+    for (count = 0; count < 25; ++count) {\n+#endif",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 130,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe introduce a constant for the max count? having unmatched `{` or `}` in `#ifdef` is hard to read and confuses editors. ",
      "created_at": "2022-07-22T08:18:13Z",
      "updated_at": "2022-07-22T08:28:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r927410144",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/927410144"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 703,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/932322252",
      "pull_request_review_id": 1054240770,
      "id": 932322252,
      "node_id": "PRRC_kwDOAP4Jqs43khvM",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let p = u^3 + t^2 + 7\n+ * - Let m = u^3 - t^2 + 7\n+ * - Let v = (C * m / p - 1) * u / 2\n+ * - Let w = p / (C * t * u)\n+ * - Let x1 = v\n+ * - Let x2 = -u - v\n+ * - Let x3 = u + w^2\n+ * - Return the first of [x3,x2,x1] that is an X coordinate on the curve\n+ *   (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:         pointer to a context object, initialized for signing.\n+ *  Out:     ell64:       pointer to a 64-byte area to receive the ElligatorSwift public key\n+ *  In:      seckey32:    pointer to a 32-byte secret key.\n+ *           auxrand32:   (optional) pointer to 32 bytes of additional randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create followed\n+ * by secp256k1_ellswift_encode. It is safer, as it can use the secret key as\n+ * entropy for the encoding. That means that if the secret key itself is\n+ * unpredictable, no additional auxrand32 is needed to achieve indistinguishability\n+ * of the encoding.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Diffie-Hellman.\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:   a pointer to the 64-byte ElligatorSquare public key received from the other party.\n+ *           ours64:     a pointer to the 64-byte ElligatorSquare public key sent to the other party.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 148,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/ElligatorSquare/ElligatorSwift in `theirs64` and `ours64`?",
      "created_at": "2022-07-28T14:46:24Z",
      "updated_at": "2022-07-28T14:51:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r932322252",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/932322252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 147,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014468429",
      "pull_request_review_id": 1169195023,
      "id": 1014468429,
      "node_id": "PRRC_kwDOAP4Jqs48d49N",
      "diff_hunk": "@@ -271,6 +276,8 @@ task:\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n+    ELLSWIFT: yes\n+    ELLSWIFT: yes",
      "path": ".cirrus.yml",
      "position": null,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": 927405587,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2022-11-04T21:08:42Z",
      "updated_at": "2022-11-04T21:08:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1014468429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014468429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 279,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014486298",
      "pull_request_review_id": 1169219958,
      "id": 1014486298,
      "node_id": "PRRC_kwDOAP4Jqs48d9Ua",
      "diff_hunk": "@@ -590,4 +678,69 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1, or x must be 0. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    VERIFY_CHECK(g.v[0] >= 0 && g.v[1] >= 0 && g.v[2] >= 0 && g.v[3] >= 0 && g.v[4] >= 0);\n+\n+    /* The loop below does not converge for input g=0. Deal with this case specifically. */\n+    if (!(g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4])) return 0;\n+\n+    /* Do up to 25 iterations of 62 posdivsteps (up to 1550 steps; more is extremely rare) each until f=1.\n+     * In VERIFY mode use a lower number of iterations (744, close to the median 756), so failure actually occurs. */\n+#ifdef VERIFY\n+    for (count = 0; count < 12; ++count) {\n+#else\n+    for (count = 0; count < 25; ++count) {\n+#endif",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 130,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": 927410144,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in #979.",
      "created_at": "2022-11-04T21:44:51Z",
      "updated_at": "2022-11-04T21:44:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1014486298",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014486298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 703,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014486430",
      "pull_request_review_id": 1169220070,
      "id": 1014486430,
      "node_id": "PRRC_kwDOAP4Jqs48d9We",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let p = u^3 + t^2 + 7\n+ * - Let m = u^3 - t^2 + 7\n+ * - Let v = (C * m / p - 1) * u / 2\n+ * - Let w = p / (C * t * u)\n+ * - Let x1 = v\n+ * - Let x2 = -u - v\n+ * - Let x3 = u + w^2\n+ * - Return the first of [x3,x2,x1] that is an X coordinate on the curve\n+ *   (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:         pointer to a context object, initialized for signing.\n+ *  Out:     ell64:       pointer to a 64-byte area to receive the ElligatorSwift public key\n+ *  In:      seckey32:    pointer to a 32-byte secret key.\n+ *           auxrand32:   (optional) pointer to 32 bytes of additional randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create followed\n+ * by secp256k1_ellswift_encode. It is safer, as it can use the secret key as\n+ * entropy for the encoding. That means that if the secret key itself is\n+ * unpredictable, no additional auxrand32 is needed to achieve indistinguishability\n+ * of the encoding.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Diffie-Hellman.\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:   a pointer to the 64-byte ElligatorSquare public key received from the other party.\n+ *           ours64:     a pointer to the 64-byte ElligatorSquare public key sent to the other party.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 148,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "34227ad26038c54a7b42c54bfd008121a3ca8fb5",
      "in_reply_to_id": 932322252,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2022-11-04T21:45:01Z",
      "updated_at": "2022-11-04T21:45:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1014486430",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1014486430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 147,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174576725",
      "pull_request_review_id": 1396905813,
      "id": 1174576725,
      "node_id": "PRRC_kwDOAP4Jqs5GAp5V",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 125,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\r\n    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\r\n```",
      "created_at": "2023-04-23T12:57:17Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174576725",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174576725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 124,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174632390",
      "pull_request_review_id": 1396905813,
      "id": 1174632390,
      "node_id": "PRRC_kwDOAP4Jqs5GA3fG",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {\n+    (void)ours64;\n+    (void)theirs64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, rnd32);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ours64 argument. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64b, ell64a, sec32a, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+    }",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 289,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`sec32a` isn't used after being flipped. Also, the second memcmp doesn't really seem to increase test coverage, since `ell64a` has already been flipped. We would want to use the unchanged `ell64a` in the second xdh call to check ir changing `sec64b` results in a different share.",
      "created_at": "2023-04-23T19:34:09Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174632390",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174632390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633202",
      "pull_request_review_id": 1396905813,
      "id": 1174633202,
      "node_id": "PRRC_kwDOAP4Jqs5GA3ry",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */\n+\n+    /* Compute ElligatorSwift encoding and construct output. */\n+    secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+    secp256k1_fe_get_b32(ell64, &u);\n+    secp256k1_fe_get_b32(ell64 + 32, &t);\n+\n+    secp256k1_memczero(ell64, 64, !ret);\n+    secp256k1_scalar_clear(&seckey_scalar);\n+\n+    return ret;\n+}\n+\n+int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe u, t;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&u, ell64);\n+    secp256k1_fe_normalize_var(&u);\n+    secp256k1_fe_set_b32(&t, ell64 + 32);\n+    secp256k1_fe_normalize_var(&t);\n+    secp256k1_ellswift_swiftec_var(&p, &u, &t);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    return 1;\n+}\n+\n+static int ellswift_xdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 425,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It looks like this default hasher is incompatible with the reference implementation's in [BIP 324](https://github.com/bitcoin/bips/blob/master/bip-0324/reference.py#L589). It uses a tagged hash and does not sort. Is this intentional? If not, would it make sense to add static test vectors for XDH?",
      "created_at": "2023-04-23T19:41:09Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174633202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 499,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633338",
      "pull_request_review_id": 1396905813,
      "id": 1174633338,
      "node_id": "PRRC_kwDOAP4Jqs5GA3t6",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 11,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: maybe mention compatibility with BIP 324 here (if it is compatible)",
      "created_at": "2023-04-23T19:42:26Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174633338",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 10,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633419",
      "pull_request_review_id": 1396905813,
      "id": 1174633419,
      "node_id": "PRRC_kwDOAP4Jqs5GA3vL",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 27,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: mention that these static test vectors are from BIP 324",
      "created_at": "2023-04-23T19:43:11Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174633419",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 24,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633592",
      "pull_request_review_id": 1396905813,
      "id": 1174633592,
      "node_id": "PRRC_kwDOAP4Jqs5GA3x4",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 55,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Afaict we don't use this equation for `x1`. So we could just continue to write `x1=-(x2+u)`.",
      "created_at": "2023-04-23T19:44:44Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174633592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633901",
      "pull_request_review_id": 1396905813,
      "id": 1174633901,
      "node_id": "PRRC_kwDOAP4Jqs5GA32t",
      "diff_hunk": "@@ -225,5 +248,10 @@ int main(int argc, char** argv) {\n     run_schnorrsig_bench(iters, argc, argv);\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    /* ElligatorSwift benchmarks */\n+    run_ellswift_bench(iters, argc, argv);\n+#endif",
      "path": "src/bench.c",
      "position": 109,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The bench help text misses the ellswift module.",
      "created_at": "2023-04-23T19:47:15Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174633901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174633901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": 273,
      "original_start_line": 251,
      "start_side": "RIGHT",
      "line": 276,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174634988",
      "pull_request_review_id": 1396905813,
      "id": 1174634988,
      "node_id": "PRRC_kwDOAP4Jqs5GA4Hs",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems like `(u^2 + u*x + x^2)` can be 0. Should we VERIFY_CHECK this or do we assume `u` to be uniformly random (if so, we may want to mention this in the function doc)?",
      "created_at": "2023-04-23T19:56:45Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174634988",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174634988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174635643",
      "pull_request_review_id": 1396905813,
      "id": 1174635643,
      "node_id": "PRRC_kwDOAP4Jqs5GA4R7",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 29,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we not abort here because we want to decode any t and u?",
      "created_at": "2023-04-23T20:02:01Z",
      "updated_at": "2023-04-24T18:57:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1174635643",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1174635643"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175293329",
      "pull_request_review_id": 1396905813,
      "id": 1175293329,
      "node_id": "PRRC_kwDOAP4Jqs5GDY2R",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 252,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The function calls inside both `VERIFY_CHECK`s should be moved outside because `--coverage` makes `VERIFY_CHECK` no-ops.",
      "created_at": "2023-04-24T13:34:08Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175293329",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175293329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175431132",
      "pull_request_review_id": 1396905813,
      "id": 1175431132,
      "node_id": "PRRC_kwDOAP4Jqs5GD6fc",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 317,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wouldn't it be better to VERIFY_CHECK instead of continuing? We can't test the branch and it impacts our coverage metric.",
      "created_at": "2023-04-24T15:07:34Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175431132",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175431132"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 316,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175450137",
      "pull_request_review_id": 1396905813,
      "id": 1175450137,
      "node_id": "PRRC_kwDOAP4Jqs5GD_IZ",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 395,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why hash ZERO here?",
      "created_at": "2023-04-24T15:22:05Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175450137",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175450137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175451796",
      "pull_request_review_id": 1396905813,
      "id": 1175451796,
      "node_id": "PRRC_kwDOAP4Jqs5GD_iU",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 344,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why do we pad the prefix instead of using the regular sha256 padding? ",
      "created_at": "2023-04-24T15:23:20Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175451796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175451796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175466162",
      "pull_request_review_id": 1396905813,
      "id": 1175466162,
      "node_id": "PRRC_kwDOAP4Jqs5GEDCy",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 85,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is \"unpredictable\" sufficiently clear for a user? Maybe \"chosen uniformly at random\".",
      "created_at": "2023-04-24T15:34:05Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175466162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175466162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175474232",
      "pull_request_review_id": 1396905813,
      "id": 1175474232,
      "node_id": "PRRC_kwDOAP4Jqs5GEFA4",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:         pointer to a context object, initialized for signing.\n+ *  Out:     ell64:       pointer to a 64-byte area to receive the ElligatorSwift public key\n+ *  In:      seckey32:    pointer to a 32-byte secret key.\n+ *           auxrand32:   (optional) pointer to 32 bytes of additional randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create followed\n+ * by secp256k1_ellswift_encode. It is safer, as it can use the secret key as\n+ * entropy for the encoding. That means that if the secret key itself is\n+ * unpredictable, no additional auxrand32 is needed to achieve indistinguishability\n+ * of the encoding.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 126,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This sounds like auxrand32 is not needed, but in general, wouldn't it be better to provide it? If you encode your public key in two different context, you presumably want the encodings to look be different. On the other hand, given the two encodings, it's anyway easy to distinguish them from pseudorandomness because they decode to the same pubkey.",
      "created_at": "2023-04-24T15:40:29Z",
      "updated_at": "2023-04-24T18:57:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1175474232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1175474232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 124,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1176359928",
      "pull_request_review_id": 1399675292,
      "id": 1176359928,
      "node_id": "PRRC_kwDOAP4Jqs5GHdP4",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 29,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174635643,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, it avoids the need for a caller to have special cases; literally any 64 byte value decodes to a valid non-infinity point on the curve.",
      "created_at": "2023-04-25T11:08:20Z",
      "updated_at": "2023-04-25T11:08:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1176359928",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1176359928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1176399209",
      "pull_request_review_id": 1399741089,
      "id": 1176399209,
      "node_id": "PRRC_kwDOAP4Jqs5GHm1p",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is not possible, because if $u^2 + ux + x^2 = 0$, then $m = -(u^3 + 7)(u^2 + ux + x^2) = 0$ as well, and the `secp256k1_fe_is_square_var(&m)` check above would have failed.\r\n\r\nI believe there is a more fundamental reason too; in the more abstract scheme this division by zero can only occur when the curve has a point for which $g(x) = 0$ (which implies an even-ordered curve), and that case needs to be excluded for other reasons too then (there are some comments in the doc about this too).",
      "created_at": "2023-04-25T11:49:45Z",
      "updated_at": "2023-04-25T11:49:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1176399209",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1176399209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177608173",
      "pull_request_review_id": 1401572120,
      "id": 1177608173,
      "node_id": "PRRC_kwDOAP4Jqs5GMN_t",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */\n+\n+    /* Compute ElligatorSwift encoding and construct output. */\n+    secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+    secp256k1_fe_get_b32(ell64, &u);\n+    secp256k1_fe_get_b32(ell64 + 32, &t);\n+\n+    secp256k1_memczero(ell64, 64, !ret);\n+    secp256k1_scalar_clear(&seckey_scalar);\n+\n+    return ret;\n+}\n+\n+int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe u, t;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&u, ell64);\n+    secp256k1_fe_normalize_var(&u);\n+    secp256k1_fe_set_b32(&t, ell64 + 32);\n+    secp256k1_fe_normalize_var(&t);\n+    secp256k1_ellswift_swiftec_var(&p, &u, &t);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    return 1;\n+}\n+\n+static int ellswift_xdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 425,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633202,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not compatible indeed, because the BIP324 hasher uses BIP340 tag \"bip324_ellswift_xonly_ecdh\". For the module I wanted something more generic, so used this simpler default.\r\n\r\nIf we keep that, we should indeed have some tests covering this exact hasher too.\r\n\r\nAlternatives are:\r\n* Not having any pre-implemented hashers (and no default, so always requiring the fn pointer).\r\n* Implementing the BIP324 hasher in this module (but maybe not as the only implemented hasher, as otherwise other prospective other protocols may be encouraged to use that one too).\r\n* Have both a generic hasher and a BIP324 hasher.\r\n\r\nThe sorting step makes the interface a bit simpler, as the hasher doesn't need to be aware of which side is who, and I see now downside to it. However, in BIP324 we chose not to do that.\r\n\r\nOpinions welcome.",
      "created_at": "2023-04-26T09:30:28Z",
      "updated_at": "2023-04-26T09:30:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1177608173",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177608173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 499,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177924223",
      "pull_request_review_id": 1402061359,
      "id": 1177924223,
      "node_id": "PRRC_kwDOAP4Jqs5GNbJ_",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see why the `if (!secp256k1_fe_is_square_var(&m)) { return 0; }` path can catch this. `secp256k1_fe_is_square_var` returns 1 on input 0.",
      "created_at": "2023-04-26T13:57:20Z",
      "updated_at": "2023-04-26T13:57:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1177924223",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177924223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177938041",
      "pull_request_review_id": 1402084077,
      "id": 1177938041,
      "node_id": "PRRC_kwDOAP4Jqs5GNeh5",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */\n+\n+    /* Compute ElligatorSwift encoding and construct output. */\n+    secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+    secp256k1_fe_get_b32(ell64, &u);\n+    secp256k1_fe_get_b32(ell64 + 32, &t);\n+\n+    secp256k1_memczero(ell64, 64, !ret);\n+    secp256k1_scalar_clear(&seckey_scalar);\n+\n+    return ret;\n+}\n+\n+int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe u, t;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&u, ell64);\n+    secp256k1_fe_normalize_var(&u);\n+    secp256k1_fe_set_b32(&t, ell64 + 32);\n+    secp256k1_fe_normalize_var(&t);\n+    secp256k1_ellswift_swiftec_var(&p, &u, &t);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    return 1;\n+}\n+\n+static int ellswift_xdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 425,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633202,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I didn't consider that you don't want people to reuse the BIP 324 hasher for domain separation reasons. In that case it makes sense to have both (and add the BIP 324 hasher including XDH test vectors in a separate PR).\r\n\r\nHowever, the existing default hasher does not solve the domain separation problem. Maybe we could change the hasher to not ignore data and encourage callers to use this for domain separation?",
      "created_at": "2023-04-26T14:07:15Z",
      "updated_at": "2023-04-26T14:07:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1177938041",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177938041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 499,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177978167",
      "pull_request_review_id": 1402146171,
      "id": 1177978167,
      "node_id": "PRRC_kwDOAP4Jqs5GNoU3",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You're right. m is reused with a different meaning still.\n\nThe other part still holds: a division by zero is only possible if a point for which g(x)=0 exists on the curve, which is not the case for secp256k1. But this is rather nontrivial to prove.",
      "created_at": "2023-04-26T14:36:20Z",
      "updated_at": "2023-04-26T14:36:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1177978167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1177978167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178823209",
      "pull_request_review_id": 1403507650,
      "id": 1178823209,
      "node_id": "PRRC_kwDOAP4Jqs5GQ2op",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 125,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174576725,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-04-27T08:46:30Z",
      "updated_at": "2023-04-27T08:46:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178823209",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178823209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 124,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178823615",
      "pull_request_review_id": 1403508655,
      "id": 1178823615,
      "node_id": "PRRC_kwDOAP4Jqs5GQ2u_",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {\n+    (void)ours64;\n+    (void)theirs64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, rnd32);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ours64 argument. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64b, ell64a, sec32a, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+    }",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 289,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174632390,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I think my intent was to apply the flipping to the other side. I've done that now.",
      "created_at": "2023-04-27T08:46:53Z",
      "updated_at": "2023-04-27T08:46:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178823615",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178823615"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825014",
      "pull_request_review_id": 1403511798,
      "id": 1178825014,
      "node_id": "PRRC_kwDOAP4Jqs5GQ3E2",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */\n+\n+    /* Compute ElligatorSwift encoding and construct output. */\n+    secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+    secp256k1_fe_get_b32(ell64, &u);\n+    secp256k1_fe_get_b32(ell64 + 32, &t);\n+\n+    secp256k1_memczero(ell64, 64, !ret);\n+    secp256k1_scalar_clear(&seckey_scalar);\n+\n+    return ret;\n+}\n+\n+int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe u, t;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&u, ell64);\n+    secp256k1_fe_normalize_var(&u);\n+    secp256k1_fe_set_b32(&t, ell64 + 32);\n+    secp256k1_fe_normalize_var(&t);\n+    secp256k1_ellswift_swiftec_var(&p, &u, &t);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    return 1;\n+}\n+\n+static int ellswift_xdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 425,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633202,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point. Providing a default hasher that supports some degree of domain separation may be useful. We should discuss this more.",
      "created_at": "2023-04-27T08:48:02Z",
      "updated_at": "2023-04-27T08:48:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178825014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 499,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825450",
      "pull_request_review_id": 1403512894,
      "id": 1178825450,
      "node_id": "PRRC_kwDOAP4Jqs5GQ3Lq",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 11,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633338,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sounds reasonable, but punting on this until the default hasher / BIP324 hasher issue is resolved.",
      "created_at": "2023-04-27T08:48:27Z",
      "updated_at": "2023-04-27T08:48:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178825450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 10,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825594",
      "pull_request_review_id": 1403513250,
      "id": 1178825594,
      "node_id": "PRRC_kwDOAP4Jqs5GQ3N6",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 27,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633419,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-04-27T08:48:35Z",
      "updated_at": "2023-04-27T08:48:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178825594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 24,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825873",
      "pull_request_review_id": 1403513900,
      "id": 1178825873,
      "node_id": "PRRC_kwDOAP4Jqs5GQ3SR",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 55,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633592,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, done.",
      "created_at": "2023-04-27T08:48:48Z",
      "updated_at": "2023-04-27T08:48:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178825873",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178825873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178826112",
      "pull_request_review_id": 1403514457,
      "id": 1178826112,
      "node_id": "PRRC_kwDOAP4Jqs5GQ3WA",
      "diff_hunk": "@@ -225,5 +248,10 @@ int main(int argc, char** argv) {\n     run_schnorrsig_bench(iters, argc, argv);\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    /* ElligatorSwift benchmarks */\n+    run_ellswift_bench(iters, argc, argv);\n+#endif",
      "path": "src/bench.c",
      "position": 109,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633901,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-04-27T08:49:01Z",
      "updated_at": "2023-04-27T08:49:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178826112",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178826112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": 273,
      "original_start_line": 251,
      "start_side": "RIGHT",
      "line": 276,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178828315",
      "pull_request_review_id": 1403519851,
      "id": 1178828315,
      "node_id": "PRRC_kwDOAP4Jqs5GQ34b",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, that's not correct either, I misremembered what the reason is for this not being possible. The reason is that $u^2 + ux + x^2 = 0$ implies that $x^3 + 7 = (-u-x)^3 + 7$; that's a contradiction because the left hand is square ($x$ is on the curve) but the right hand is non-square ($-u-x$ is not on the curve, or we would have bailed out already). I've added this proof as a comment to the code.",
      "created_at": "2023-04-27T08:50:55Z",
      "updated_at": "2023-04-27T08:50:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178828315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178828315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178830126",
      "pull_request_review_id": 1403524334,
      "id": 1178830126,
      "node_id": "PRRC_kwDOAP4Jqs5GQ4Uu",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 252,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175293329,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-04-27T08:52:27Z",
      "updated_at": "2023-04-27T08:52:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1178830126",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1178830126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179136771",
      "pull_request_review_id": 1404012579,
      "id": 1179136771,
      "node_id": "PRRC_kwDOAP4Jqs5GSDMD",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 317,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175431132,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-04-27T13:12:08Z",
      "updated_at": "2023-04-27T13:12:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1179136771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179136771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 316,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179138162",
      "pull_request_review_id": 1404014860,
      "id": 1179138162,
      "node_id": "PRRC_kwDOAP4Jqs5GSDhy",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 395,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175450137,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The earlier code here required hash buffers that had very strict size requirements, and this was just padding. I've now relaxed the requirements, added rationale for it, and moved some of the code to a new function. Please have a look to see if it's clear now.",
      "created_at": "2023-04-27T13:13:17Z",
      "updated_at": "2023-04-27T13:13:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1179138162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179138162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179139060",
      "pull_request_review_id": 1404016302,
      "id": 1179139060,
      "node_id": "PRRC_kwDOAP4Jqs5GSDv0",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 344,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175451796,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We were not; this is just a domain separation prefix. There is still the normal SHA256 padding (applied by `secp256k1_sha256_finalize`).",
      "created_at": "2023-04-27T13:14:00Z",
      "updated_at": "2023-04-27T13:14:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1179139060",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1179139060"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181106299",
      "pull_request_review_id": 1407006683,
      "id": 1181106299,
      "node_id": "PRRC_kwDOAP4Jqs5GZkB7",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 344,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175451796,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've switched to BIP340-style tagged hashes for domain separation now.",
      "created_at": "2023-04-29T17:31:13Z",
      "updated_at": "2023-04-29T17:31:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1181106299",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181106299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181131518",
      "pull_request_review_id": 1407028767,
      "id": 1181131518,
      "node_id": "PRRC_kwDOAP4Jqs5GZqL-",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 85,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175466162,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've rewritten this, and added more comments.",
      "created_at": "2023-04-29T21:36:30Z",
      "updated_at": "2023-04-29T21:36:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1181131518",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181131518"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181132121",
      "pull_request_review_id": 1407029206,
      "id": 1181132121,
      "node_id": "PRRC_kwDOAP4Jqs5GZqVZ",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:         pointer to a context object, initialized for signing.\n+ *  Out:     ell64:       pointer to a 64-byte area to receive the ElligatorSwift public key\n+ *  In:      seckey32:    pointer to a 32-byte secret key.\n+ *           auxrand32:   (optional) pointer to 32 bytes of additional randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create followed\n+ * by secp256k1_ellswift_encode. It is safer, as it can use the secret key as\n+ * entropy for the encoding. That means that if the secret key itself is\n+ * unpredictable, no additional auxrand32 is needed to achieve indistinguishability\n+ * of the encoding.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 126,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175474232,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the public keys being sent are distinguishable from uniformly random, the result will inevitable by distinguishable already (and you shouldn't be using ellswift in the first place probably). I think mentioning the \"if the secret key itself is indistinguishable\" was more confusing than useful as a result.\r\n\r\nBut more exactly, there are two properties one may hope to aim for with the encoding functions in this module:\r\n* Statistically close to uniform: actual (information theoretical) uniformity would probably require ~384 bits of entropy as input (clearly not supported by these functions), and also internal RNGs that can use that. The 256 bits that can be provided do get you a decent part of the way there.\r\n* Computational indistinguishability from uniform. For this ~128 bits suffices for `secp256k1_ellswift_encode`, and 0 bits suffices for `secp256k1_ellswift_create` (assuming uniformly random public keys with unknown private keys).\r\n\r\nI've added more comments to recommend 256 bits of entropy in both cases, without going into too much technical detail.",
      "created_at": "2023-04-29T21:43:38Z",
      "updated_at": "2023-04-29T21:43:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1181132121",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181132121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 124,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181478706",
      "pull_request_review_id": 1407471651,
      "id": 1181478706,
      "node_id": "PRRC_kwDOAP4Jqs5Ga-8y",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 167,
      "original_position": 166,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Self-nit: this is actually unnecessary.\r\n\r\nBoth (current) call sites for the encoder logic do encode a known Y coordinate parity, which means that c=0 to c=3 would suffice (the additional conditional negation based on bit 4 in c is used, but then effectively replaced by whatever makes the y parity match the t parity).\r\n\r\nTogether, that does mean a slightly simpler structure is possible:\r\n* `secp256k1_ellswift_xswiftec_inv_var` only takes c=0 through c=3, and always outputs an encoding which represents a Y coordinate that's deterministic.\r\n* `secp256k1_ellswift_xelligatorswift_var` can use a branch pool consisting of 128 2-bit values rather than 64 4-bit values (of which one bit is ignored).\r\n* `secp256k1_ellswift_xelligatorswift_var` can be merged into `secp256k1_ellswift_elligatorswift_var` (as the X-only version would on itself not yield a uniform distribution anymore).\r\n\r\nOpinions?",
      "created_at": "2023-05-01T09:18:21Z",
      "updated_at": "2023-05-01T09:18:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1181478706",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1181478706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 167,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183494347",
      "pull_request_review_id": 1410582658,
      "id": 1183494347,
      "node_id": "PRRC_kwDOAP4Jqs5GirDL",
      "diff_hunk": "@@ -726,4 +726,30 @@ static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n #endif\n }\n \n+static int secp256k1_ge_x_on_curve_var(const secp256k1_fe *x)\n+{\n+    secp256k1_fe c;\n+    secp256k1_fe_sqr(&c, x);\n+    secp256k1_fe_mul(&c, &c, x);\n+    secp256k1_fe_add_int(&c, SECP256K1_B);\n+    return secp256k1_fe_is_square_var(&c);\n+}\n+\n+static int secp256k1_ge_x_frac_on_curve_var(const secp256k1_fe *xn, const secp256k1_fe *xd) {\n+    /* We want to determine whether (xn/xd) is on the curve.\n+     *\n+     * (xn/xd)^3 + 7 is square <=> xd*xn^3 + 7*xd^4 is square (multiplying by xd^4, a square).\n+     */\n+     secp256k1_fe r, t;\n+     secp256k1_fe_mul(&r, xd, xn); /* r = xd*xn */\n+     secp256k1_fe_sqr(&t, xn); /* t = xn^2 */\n+     secp256k1_fe_mul(&r, &r, &t); /* r = xd*xn^3 */\n+     secp256k1_fe_sqr(&t, xd); /* t = xd^2 */\n+     secp256k1_fe_sqr(&t, &t); /* t = xd^4 */\n+     VERIFY_CHECK(SECP256K1_B <= 8);",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 24,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "961baf4e93e8eda747cc2aead9f0aa758f3e4493",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think this is at least misleading. The magnitude bound is 32, so \r\n```suggestion\r\n     VERIFY_CHECK(SECP256K1_B <= 31);\r\n```\r\nshould suffice With B=31, `t` will have magnitude 31 after the next line, and then `r` will have 1+31 = 32, which is fine because `secp256k1_fe_is_square_var` doesn't have a magnitude precondition.\r\n\r\nI plan to include this in a bunch of fixups you'll be able to cherry-pick. (But feel free to go ahead and just fix it.)",
      "created_at": "2023-05-03T10:13:19Z",
      "updated_at": "2023-05-03T14:32:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183494347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183494347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 749,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183777035",
      "pull_request_review_id": 1411045434,
      "id": 1183777035,
      "node_id": "PRRC_kwDOAP4Jqs5GjwEL",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "08ed2b426458099de7a8421b9bbb8da334db8925",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should talk about whether we want this to be experimental.\r\n\r\n(And if the answer yes, a check for `--enable-experimental` is missing.)",
      "created_at": "2023-05-03T14:34:31Z",
      "updated_at": "2023-05-03T15:37:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183777035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183777035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183860002",
      "pull_request_review_id": 1411045434,
      "id": 1183860002,
      "node_id": "PRRC_kwDOAP4Jqs5GkEUi",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 76,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know we have this also in the module ECDH, but what's the purpose for exporting a variable for the default? I think in case of ECDH, a hash function that can change due to an API change is exactly not what you want as a user, because it breaks interop. \r\n\r\nOf course, us changing this variable will be a breaking API change. But the way I imagine a change of defaults (if it will ever occur), is not changing `secp256k1_ellswift_xdh_hash_function_default` (and the behavior of `NULL`), because that's just hard breaking. I imagine we'd instead rather deprecate `secp256k1_ellswift_xdh` and add a new function with a different default hash.\r\n\r\nSo, I don't see much value in adding this default variable as another layer of abstraction. If the user wants to call the hash function explicitly, they could still call `secp256k1_ellswift_xdh_hash_function_sha256` (and be sure what they get!).\r\n\r\n(Now that I think about it, having this in the ECDH module may have originated from the way we do this for nonce functions. But in that case, it makes much more sense, and we could swap out the hash function under the hood without any change in interop.) ",
      "created_at": "2023-05-03T15:35:32Z",
      "updated_at": "2023-05-03T15:37:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183860002",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183860002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 75,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183921533",
      "pull_request_review_id": 1406521434,
      "id": 1183921533,
      "node_id": "PRRC_kwDOAP4Jqs5GkTV9",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 344,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175451796,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry, what I meant was that we were padding manually up to blocksize - 9 (as well as using regular padding) for some reason. According to the other comment that was for old code reasons.",
      "created_at": "2023-05-03T16:21:35Z",
      "updated_at": "2023-05-03T19:29:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183921533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183921533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183922513",
      "pull_request_review_id": 1406521434,
      "id": 1183922513,
      "node_id": "PRRC_kwDOAP4Jqs5GkTlR",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I checked for a large number of X coordinates that `VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));` can't happen but\r\n\r\n> if u^2 + u*x + x^2 = 0, then x^3 + 7 = (-u-x)^3 + 7.\r\n\r\nhow does this follow exactly?\r\n",
      "created_at": "2023-05-03T16:22:23Z",
      "updated_at": "2023-05-03T19:29:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183922513",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183922513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183932592",
      "pull_request_review_id": 1406521434,
      "id": 1183932592,
      "node_id": "PRRC_kwDOAP4Jqs5GkWCw",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {\n+    (void)ours64;\n+    (void)theirs64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, rnd32);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ours64 argument. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64b, ell64a, sec32a, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+    }",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 289,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174632390,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think the last test adds any real test coverage since `ell64a` was already flipped, so of course `share32a` will be unequal to `share32b`. What we could do is let the last `_xdh` write into `share32b` instead of `share32a`. Then we've isolated the flipping of `sec32a`.",
      "created_at": "2023-05-03T16:31:00Z",
      "updated_at": "2023-05-03T19:29:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183932592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183932592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183965957",
      "pull_request_review_id": 1406521434,
      "id": 1183965957,
      "node_id": "PRRC_kwDOAP4Jqs5GkeMF",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 85,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175466162,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks good.",
      "created_at": "2023-05-03T16:58:38Z",
      "updated_at": "2023-05-03T19:29:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1183965957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1183965957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184085877",
      "pull_request_review_id": 1406521434,
      "id": 1184085877,
      "node_id": "PRRC_kwDOAP4Jqs5Gk7d1",
      "diff_hunk": "@@ -225,5 +248,10 @@ int main(int argc, char** argv) {\n     run_schnorrsig_bench(iters, argc, argv);\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    /* ElligatorSwift benchmarks */\n+    run_ellswift_bench(iters, argc, argv);\n+#endif",
      "path": "src/bench.c",
      "position": 109,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633901,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It looks like the bench help still misses the ellswift module (see `void help(...)` at the start of bench.c)\r\n",
      "created_at": "2023-05-03T18:10:17Z",
      "updated_at": "2023-05-03T19:29:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184085877",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184085877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": 273,
      "original_start_line": 251,
      "start_side": "RIGHT",
      "line": 276,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184154265",
      "pull_request_review_id": 1406521434,
      "id": 1184154265,
      "node_id": "PRRC_kwDOAP4Jqs5GlMKZ",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 388,
      "original_position": 378,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: should we add a test for both midstate init functions similar to https://github.com/bitcoin-core/secp256k1/blob/master/src/modules/schnorrsig/tests_impl.h#L50?",
      "created_at": "2023-05-03T19:22:11Z",
      "updated_at": "2023-05-03T19:29:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184154265",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184154265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 388,
      "original_line": 388,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184157240",
      "pull_request_review_id": 1406521434,
      "id": 1184157240,
      "node_id": "PRRC_kwDOAP4Jqs5GlM44",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ent32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || ent32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        secp256k1_fe_get_b32(p33 + 1, &p.x);\n+        p33[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        secp256k1_sha256_write(&hash, ent32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_create\". */\n+static void secp256k1_ellswift_sha256_init_create(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd29e1bf5ul;\n+    hash->s[1] = 0xf7025f42ul;\n+    hash->s[2] = 0x9b024773ul;\n+    hash->s[3] = 0x094cb7d5ul;\n+    hash->s[4] = 0xe59ed789ul;\n+    hash->s[5] = 0x03bc9786ul;\n+    hash->s[6] = 0x68335b35ul;\n+    hash->s[7] = 0x4e363b53ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *auxrand32) {\n+    secp256k1_ge p;\n+    secp256k1_fe t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state. The used RNG is H(privkey [|| auxrand32] || cnt++), using BIP340 tagged\n+     * hash with tag \"secp256k1_ellswift_create\". */\n+    secp256k1_ellswift_sha256_init_create(&hash);\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    if (auxrand32) secp256k1_sha256_write(&hash, auxrand32, 32);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 461,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "since `hash` contains the plain `seckey32` in its buffer, wouldn't it be more robust to declassify the hash output in `secp256k1_ellswift_xelligatorswift_var`?",
      "created_at": "2023-05-03T19:23:59Z",
      "updated_at": "2023-05-03T19:29:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184157240",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184157240"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184161053",
      "pull_request_review_id": 1406521434,
      "id": 1184161053,
      "node_id": "PRRC_kwDOAP4Jqs5GlN0d",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 395,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175450137,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": " It's clear now.",
      "created_at": "2023-05-03T19:26:12Z",
      "updated_at": "2023-05-03T19:29:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184161053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184161053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184162489",
      "pull_request_review_id": 1406521434,
      "id": 1184162489,
      "node_id": "PRRC_kwDOAP4Jqs5GlOK5",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/* Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:         pointer to a context object, initialized for signing.\n+ *  Out:     ell64:       pointer to a 64-byte area to receive the ElligatorSwift public key\n+ *  In:      seckey32:    pointer to a 32-byte secret key.\n+ *           auxrand32:   (optional) pointer to 32 bytes of additional randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create followed\n+ * by secp256k1_ellswift_encode. It is safer, as it can use the secret key as\n+ * entropy for the encoding. That means that if the secret key itself is\n+ * unpredictable, no additional auxrand32 is needed to achieve indistinguishability\n+ * of the encoding.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 126,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1175474232,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the context. The new docs sound good to me.",
      "created_at": "2023-05-03T19:27:06Z",
      "updated_at": "2023-05-03T19:29:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184162489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184162489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 124,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184610328",
      "pull_request_review_id": 1412396738,
      "id": 1184610328,
      "node_id": "PRRC_kwDOAP4Jqs5Gm7gY",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "$(x^3 + B) - ((-u-x)^3 + B) = u^3 + 3 u^2 x + 3 u x^2 + 2 x^3 = (u + 2 x) (u^2 + u x + x^2)$.\r\n\r\nSo if $u^2 + u x + x^2 = 0$, then $x^3 + B = (-u-x)^3 + B$.",
      "created_at": "2023-05-04T06:54:15Z",
      "updated_at": "2023-05-04T07:04:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184610328",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184610328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184690564",
      "pull_request_review_id": 1412552119,
      "id": 1184690564,
      "node_id": "PRRC_kwDOAP4Jqs5GnPGE",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation, and tested against paper author's code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {\n+    (void)ours64;\n+    (void)theirs64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, rnd32);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ours64 argument. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64b, ell64a, sec32a, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, NULL, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+    }",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 289,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174632390,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, done.",
      "created_at": "2023-05-04T08:18:15Z",
      "updated_at": "2023-05-04T08:18:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184690564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184690564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184699380",
      "pull_request_review_id": 1412566040,
      "id": 1184699380,
      "node_id": "PRRC_kwDOAP4Jqs5GnRP0",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 76,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1183860002,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You're right. It's a bad idea to provide any kind of default, the hasher is part of the scheme's definition, and users ought to be explicit about that.\r\n\r\nMy current thinking is the following:\r\n* A generic BIP340-tagged-hash based hasher, which takes some encoded tag through `data`, and sorts the ours/theirs encodings lexicographically (so it's usable in contexts where there is no clear first/second participant). Not sure how to encode the tag though... could be just a C-style string (`strlen`...) or some fixed length.\r\n* A BIP324-compatible hasher, which takes initiator/responder int as data.\r\n\r\nI find it a bit unfortunate that one hasher can't be used for everything. A possibility would be to use a more complex encoding which provides both tag and order through `data`, but that'd restrict the hasher to situations where the participants have a well-defined ordering.",
      "created_at": "2023-05-04T08:25:39Z",
      "updated_at": "2023-05-04T08:25:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184699380",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184699380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 75,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184722694",
      "pull_request_review_id": 1412610709,
      "id": 1184722694,
      "node_id": "PRRC_kwDOAP4Jqs5GnW8G",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ent32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || ent32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        secp256k1_fe_get_b32(p33 + 1, &p.x);\n+        p33[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        secp256k1_sha256_write(&hash, ent32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_create\". */\n+static void secp256k1_ellswift_sha256_init_create(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd29e1bf5ul;\n+    hash->s[1] = 0xf7025f42ul;\n+    hash->s[2] = 0x9b024773ul;\n+    hash->s[3] = 0x094cb7d5ul;\n+    hash->s[4] = 0xe59ed789ul;\n+    hash->s[5] = 0x03bc9786ul;\n+    hash->s[6] = 0x68335b35ul;\n+    hash->s[7] = 0x4e363b53ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *auxrand32) {\n+    secp256k1_ge p;\n+    secp256k1_fe t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state. The used RNG is H(privkey [|| auxrand32] || cnt++), using BIP340 tagged\n+     * hash with tag \"secp256k1_ellswift_create\". */\n+    secp256k1_ellswift_sha256_init_create(&hash);\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    if (auxrand32) secp256k1_sha256_write(&hash, auxrand32, 32);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 461,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1184157240,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fair point, but this would require passing down `ctx` several layers down the stack. Do you think that's worth it?",
      "created_at": "2023-05-04T08:44:01Z",
      "updated_at": "2023-05-04T08:44:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184722694",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184722694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184726443",
      "pull_request_review_id": 1412617970,
      "id": 1184726443,
      "node_id": "PRRC_kwDOAP4Jqs5GnX2r",
      "diff_hunk": "@@ -726,4 +726,30 @@ static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n #endif\n }\n \n+static int secp256k1_ge_x_on_curve_var(const secp256k1_fe *x)\n+{\n+    secp256k1_fe c;\n+    secp256k1_fe_sqr(&c, x);\n+    secp256k1_fe_mul(&c, &c, x);\n+    secp256k1_fe_add_int(&c, SECP256K1_B);\n+    return secp256k1_fe_is_square_var(&c);\n+}\n+\n+static int secp256k1_ge_x_frac_on_curve_var(const secp256k1_fe *xn, const secp256k1_fe *xd) {\n+    /* We want to determine whether (xn/xd) is on the curve.\n+     *\n+     * (xn/xd)^3 + 7 is square <=> xd*xn^3 + 7*xd^4 is square (multiplying by xd^4, a square).\n+     */\n+     secp256k1_fe r, t;\n+     secp256k1_fe_mul(&r, xd, xn); /* r = xd*xn */\n+     secp256k1_fe_sqr(&t, xn); /* t = xn^2 */\n+     secp256k1_fe_mul(&r, &r, &t); /* r = xd*xn^3 */\n+     secp256k1_fe_sqr(&t, xd); /* t = xd^2 */\n+     secp256k1_fe_sqr(&t, &t); /* t = xd^4 */\n+     VERIFY_CHECK(SECP256K1_B <= 8);",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 24,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "961baf4e93e8eda747cc2aead9f0aa758f3e4493",
      "in_reply_to_id": 1183494347,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-04T08:47:13Z",
      "updated_at": "2023-05-04T08:47:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184726443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184726443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 749,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184726647",
      "pull_request_review_id": 1412618444,
      "id": 1184726647,
      "node_id": "PRRC_kwDOAP4Jqs5GnX53",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "08ed2b426458099de7a8421b9bbb8da334db8925",
      "in_reply_to_id": 1183777035,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good question.",
      "created_at": "2023-05-04T08:47:24Z",
      "updated_at": "2023-05-04T08:47:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184726647",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184726647"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184727466",
      "pull_request_review_id": 1412619718,
      "id": 1184727466,
      "node_id": "PRRC_kwDOAP4Jqs5GnYGq",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 388,
      "original_position": 378,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1184154265,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in a separate commit.",
      "created_at": "2023-05-04T08:48:05Z",
      "updated_at": "2023-05-04T08:48:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184727466",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184727466"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 388,
      "original_line": 388,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184730093",
      "pull_request_review_id": 1412622965,
      "id": 1184730093,
      "node_id": "PRRC_kwDOAP4Jqs5GnYvt",
      "diff_hunk": "@@ -225,5 +248,10 @@ int main(int argc, char** argv) {\n     run_schnorrsig_bench(iters, argc, argv);\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    /* ElligatorSwift benchmarks */\n+    run_ellswift_bench(iters, argc, argv);\n+#endif",
      "path": "src/bench.c",
      "position": 109,
      "original_position": 60,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633901,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh! I had added help text for the case where one of the ellswift keywords was provided without the module being compiled in, but not the normal help text. Done now (also for the `ec_keygen` bench from the first commit).",
      "created_at": "2023-05-04T08:50:03Z",
      "updated_at": "2023-05-04T08:50:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184730093",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184730093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": 273,
      "original_start_line": 251,
      "start_side": "RIGHT",
      "line": 276,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184734187",
      "pull_request_review_id": 1412635406,
      "id": 1184734187,
      "node_id": "PRRC_kwDOAP4Jqs5GnZvr",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174634988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added this as more elaborate comment to the code.",
      "created_at": "2023-05-04T08:53:26Z",
      "updated_at": "2023-05-04T08:53:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1184734187",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1184734187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1185911987",
      "pull_request_review_id": 1414501432,
      "id": 1185911987,
      "node_id": "PRRC_kwDOAP4Jqs5Gr5Sz",
      "diff_hunk": "@@ -121,6 +123,22 @@ static void bench_sign_run(void* arg, int iters) {\n     }\n }\n \n+static void bench_keygen_run(void *arg, int iters) {\n+    int i;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char pub33[33];\n+        size_t len = 33;\n+        secp256k1_pubkey pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->key));\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, pub33, &len, &pubkey, SECP256K1_EC_COMPRESSED));\n+        memcpy(data->key, pub33 + 1, 32);\n+        data->key[17] ^= i;",
      "path": "src/bench.c",
      "position": null,
      "original_position": 24,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "84a735dd67d531d10633e7d21647ea12f68687df",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "84a735d: curious to know why we do this? `data->key` would be different everytime because of memcpy in previous line. (maybe this creates even more diffusion?)",
      "created_at": "2023-05-05T10:00:25Z",
      "updated_at": "2023-05-09T08:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1185911987",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1185911987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1185932386",
      "pull_request_review_id": 1414501432,
      "id": 1185932386,
      "node_id": "PRRC_kwDOAP4Jqs5Gr-Ri",
      "diff_hunk": "@@ -207,6 +226,7 @@ int main(int argc, char** argv) {\n     if (d || have_flag(argc, argv, \"ecdsa\") || have_flag(argc, argv, \"verify\") || have_flag(argc, argv, \"ecdsa_verify\")) run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n \n     if (d || have_flag(argc, argv, \"ecdsa\") || have_flag(argc, argv, \"sign\") || have_flag(argc, argv, \"ecdsa_sign\")) run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"ec\") || have_flag(argc, argv, \"keygen\") || have_flag(argc, argv, \"ec_keygen\")) run_benchmark(\"ec_keygen\", bench_keygen_run, bench_sign_setup, NULL, &data, 10, iters);",
      "path": "src/bench.c",
      "position": null,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "84a735dd67d531d10633e7d21647ea12f68687df",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "84a735d: is it important to set up `data->key` and `data->msg`(not used) using `bench_sign_setup` every time in the count loop?\r\n(just wondering, i tried NULL instead of `bench_sign_setup` and didn't notice any difference in benchmarking results)",
      "created_at": "2023-05-05T10:24:44Z",
      "updated_at": "2023-05-09T08:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1185932386",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1185932386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186650655",
      "pull_request_review_id": 1414501432,
      "id": 1186650655,
      "node_id": "PRRC_kwDOAP4Jqs5Gutof",
      "diff_hunk": "@@ -3909,6 +3914,29 @@ static void test_ge(void) {\n         free(ge_set_all);\n     }\n \n+    /* Test all elements have X coordinates on the curve. */\n+    for (i = 1; i < 4 * runs + 1; i++) {\n+        secp256k1_fe n;\n+        CHECK(secp256k1_ge_x_on_curve_var(&ge[i].x));\n+        /* And the same holds after random rescaling. */\n+        secp256k1_fe_mul(&n, &zf, &ge[i].x);\n+        CHECK(secp256k1_ge_x_frac_on_curve_var(&n, &zf));\n+    }\n+\n+    /* Test correspondence secp256k1_ge_x{,_frac}_on_curve_var with ge_set_xo. */\n+    {\n+        secp256k1_fe n;\n+        secp256k1_ge q;\n+        int ret_on_curve, ret_frac_on_curve, ret_set_xo;\n+        secp256k1_fe_mul(&n, &zf, &r);\n+        ret_on_curve = secp256k1_ge_x_on_curve_var(&r);\n+        ret_frac_on_curve = secp256k1_ge_x_frac_on_curve_var(&n, &zf);\n+        ret_set_xo = secp256k1_ge_set_xo_var(&q, &r, 0);\n+        CHECK(ret_on_curve == ret_frac_on_curve);\n+        CHECK(ret_on_curve == ret_set_xo);\n+        if (ret_set_xo) CHECK(secp256k1_fe_equal_var(&r, &q.x));",
      "path": "src/tests.c",
      "position": 63,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54a33377f6613f99f957aedae4c7d7660dad81b3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c2dc037: this CHECK would pass when `ret_set_xo=0` also since the x coordinate assignment happens before 0 or 1 is returned in `secp256k1_ge_set_xo_var()`.",
      "created_at": "2023-05-06T06:55:36Z",
      "updated_at": "2023-05-09T08:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186650655",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186650655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3968,
      "original_line": 3968,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186657105",
      "pull_request_review_id": 1414501432,
      "id": 1186657105,
      "node_id": "PRRC_kwDOAP4Jqs5GuvNR",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6128b71: micro nit - s/hashing/hash",
      "created_at": "2023-05-06T07:29:37Z",
      "updated_at": "2023-05-09T08:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186657105",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186657105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186659212",
      "pull_request_review_id": 1414501432,
      "id": 1186659212,
      "node_id": "PRRC_kwDOAP4Jqs5GuvuM",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** The default secp256k1_ellswift_xdh_hash_function, currently\n+    secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 124,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6128b71: s/area/array",
      "created_at": "2023-05-06T07:47:34Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186659212",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186659212"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186659554",
      "pull_request_review_id": 1414501432,
      "id": 1186659554,
      "node_id": "PRRC_kwDOAP4Jqs5Guvzi",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** The default secp256k1_ellswift_xdh_hash_function, currently\n+    secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 123,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6128b71: signing not needed i think",
      "created_at": "2023-05-06T07:50:38Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186659554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186659554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186703090",
      "pull_request_review_id": 1414501432,
      "id": 1186703090,
      "node_id": "PRRC_kwDOAP4Jqs5Gu6by",
      "diff_hunk": "@@ -0,0 +1,563 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 128,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6128b71:\r\n```suggestion\r\n    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\r\n```",
      "created_at": "2023-05-06T14:12:47Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186703090",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186703090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186705361",
      "pull_request_review_id": 1414501432,
      "id": 1186705361,
      "node_id": "PRRC_kwDOAP4Jqs5Gu6_R",
      "diff_hunk": "@@ -260,6 +266,7 @@ message(\"  ECDH ................................ ${SECP256K1_ENABLE_MODULE_ECDH}\n message(\"  ECDSA pubkey recovery ............... ${SECP256K1_ENABLE_MODULE_RECOVERY}\")\n message(\"  extrakeys ........................... ${SECP256K1_ENABLE_MODULE_EXTRAKEYS}\")\n message(\"  schnorrsig .......................... ${SECP256K1_ENABLE_MODULE_SCHNORRSIG}\")\n+message(\"  ElligatorSwift....................... ${SECP256K1_ENABLE_MODULE_ELLSWIFT}\")",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 17,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6128b71: micro nit\r\n```suggestion\r\nmessage(\"  ElligatorSwift ...................... ${SECP256K1_ENABLE_MODULE_ELLSWIFT}\")\r\n```",
      "created_at": "2023-05-06T14:32:19Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186705361",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186705361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186710000",
      "pull_request_review_id": 1415787783,
      "id": 1186710000,
      "node_id": "PRRC_kwDOAP4Jqs5Gu8Hw",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ent32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || ent32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        secp256k1_fe_get_b32(p33 + 1, &p.x);\n+        p33[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        secp256k1_sha256_write(&hash, ent32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_create\". */\n+static void secp256k1_ellswift_sha256_init_create(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd29e1bf5ul;\n+    hash->s[1] = 0xf7025f42ul;\n+    hash->s[2] = 0x9b024773ul;\n+    hash->s[3] = 0x094cb7d5ul;\n+    hash->s[4] = 0xe59ed789ul;\n+    hash->s[5] = 0x03bc9786ul;\n+    hash->s[6] = 0x68335b35ul;\n+    hash->s[7] = 0x4e363b53ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *auxrand32) {\n+    secp256k1_ge p;\n+    secp256k1_fe t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state. The used RNG is H(privkey [|| auxrand32] || cnt++), using BIP340 tagged\n+     * hash with tag \"secp256k1_ellswift_create\". */\n+    secp256k1_ellswift_sha256_init_create(&hash);\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    if (auxrand32) secp256k1_sha256_write(&hash, auxrand32, 32);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 461,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1184157240,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added some padding after the private key. This means the key material stays much shorter in the hashing buffer, and makes it perhaps more acceptable to declassify the hash state.",
      "created_at": "2023-05-06T15:14:49Z",
      "updated_at": "2023-05-06T15:14:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186710000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186710000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186710064",
      "pull_request_review_id": 1415787814,
      "id": 1186710064,
      "node_id": "PRRC_kwDOAP4Jqs5Gu8Iw",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first of [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any inputs u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used for hashing the shared X coordinate along\n+ *  with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sorted([ours64, theirs64]), and\n+ *  ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** A default secp256k1_ellswift_xdh_hash_function, currently secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 76,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1183860002,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've implemented this.",
      "created_at": "2023-05-06T15:15:10Z",
      "updated_at": "2023-05-06T15:15:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186710064",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186710064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 75,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186735879",
      "pull_request_review_id": 1415810324,
      "id": 1186735879,
      "node_id": "PRRC_kwDOAP4Jqs5GvCcH",
      "diff_hunk": "@@ -0,0 +1,491 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinare, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - ...\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=(c0*u*(g-s)/(g+s)-u)/2.\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*g*s */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*g*s */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+\n+    /* Normalize. */\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    if (!(c & 2)) {\n+        /* If -u-x is a valid X coordinate, fail. */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0; /* test if -u-x on curve */\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square. */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        VERIFY_CHECK(secp256k1_fe_sqrt(&r, &q)); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    VERIFY_CHECK(secp256k1_fe_sqrt(&m, &s)); /* m = sqrt(s) = w */\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x.\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to to\n+ * generate randomness for the rejection sampling in this function. Its size plus\n+ * 4 (for the counter) plus 9 (for the SHA256 padding) must be a multiple of 64\n+ * for efficiency reasons.\n+ */\n+static void secp256k1_ellswift_xelligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from\n+     * SHA256(hasher || cnt) for consecutive values of cnt. cnt==0\n+     * is first used to populate a pool of 64 4-bit branch values. The 64 cnt\n+     * values that follow are used to generate field elements u. cnt==65 (and\n+     * multiples thereof) are used to repopulate the pool and start over, if\n+     * that were ever necessary. */\n+    uint32_t cnt = 0;\n+    VERIFY_CHECK((hasher->bytes + 4 + 9) % 64 == 0);\n+    while (1) {\n+        int branch;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, branch_hash);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        {\n+            secp256k1_sha256 hash = *hasher;\n+            unsigned char buf4[4];\n+            unsigned char u32[32];\n+            buf4[0] = cnt;\n+            buf4[1] = cnt >> 8;\n+            buf4[2] = cnt >> 16;\n+            buf4[3] = cnt >> 24;\n+            ++cnt;\n+            secp256k1_sha256_write(&hash, buf4, 4);\n+            secp256k1_sha256_finalize(&hash, u32);\n+            if (!secp256k1_fe_set_b32(u, u32)) continue;\n+            if (secp256k1_fe_is_zero(u)) continue;\n+        }\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P. */\n+static void secp256k1_ellswift_elligatorswift_var(secp256k1_fe *u, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        static const unsigned char PREFIX[128 - 9 - 4 - 32 - 33] = \"secp256k1_ellswift_encode\";\n+        secp256k1_fe u, t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state */\n+        secp256k1_sha256_initialize(&hash);\n+        secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+        secp256k1_fe_get_b32(p33, &p.x);\n+        p33[32] = secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        VERIFY_CHECK(hash.bytes == 128 - 9 - 4);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+        secp256k1_fe_get_b32(ell64, &u);\n+        secp256k1_fe_get_b32(ell64 + 32, &t);\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    secp256k1_fe u, t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    static const unsigned char PREFIX[32] = \"secp256k1_ellswift_create\";\n+    static const unsigned char ZERO[32] = {0};\n+    int ret = 0;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state */\n+    secp256k1_sha256_initialize(&hash);\n+    secp256k1_sha256_write(&hash, PREFIX, sizeof(PREFIX));\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    secp256k1_sha256_write(&hash, rnd32 ? rnd32 : ZERO, 32);\n+    secp256k1_sha256_write(&hash, ZERO, 32 - 9 - 4);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */\n+\n+    /* Compute ElligatorSwift encoding and construct output. */\n+    secp256k1_ellswift_elligatorswift_var(&u, &t, &p, &hash);\n+    secp256k1_fe_get_b32(ell64, &u);\n+    secp256k1_fe_get_b32(ell64 + 32, &t);\n+\n+    secp256k1_memczero(ell64, 64, !ret);\n+    secp256k1_scalar_clear(&seckey_scalar);\n+\n+    return ret;\n+}\n+\n+int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe u, t;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&u, ell64);\n+    secp256k1_fe_normalize_var(&u);\n+    secp256k1_fe_set_b32(&t, ell64 + 32);\n+    secp256k1_fe_normalize_var(&t);\n+    secp256k1_ellswift_swiftec_var(&p, &u, &t);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    return 1;\n+}\n+\n+static int ellswift_xdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *ours64, const unsigned char *theirs64, void *data) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 425,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633202,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is addressed now: https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186710064",
      "created_at": "2023-05-06T19:14:51Z",
      "updated_at": "2023-05-06T19:14:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186735879",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186735879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 499,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186783120",
      "pull_request_review_id": 1414501432,
      "id": 1186783120,
      "node_id": "PRRC_kwDOAP4Jqs5GvN-Q",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any other order requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2).$\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. The division in the first branch in fact cannot occur at all, $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs (besides division by zero).\n+For cryptographically sized curves, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targetted uniformly by the",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 318,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "77d2ece87020f4967e1e41dfb34b9a37c24a5ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8183a34: s/targetted/targeted",
      "created_at": "2023-05-07T05:03:23Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186783120",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186783120"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186783260",
      "pull_request_review_id": 1414501432,
      "id": 1186783260,
      "node_id": "PRRC_kwDOAP4Jqs5GvOAc",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 38,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "77d2ece87020f4967e1e41dfb34b9a37c24a5ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8183a34: s/uniformy/uniformly",
      "created_at": "2023-05-07T05:05:04Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1186783260",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1186783260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1187277320",
      "pull_request_review_id": 1416527777,
      "id": 1187277320,
      "node_id": "PRRC_kwDOAP4Jqs5GxGoI",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key.\n+ *           auxrand32:  (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrand32 contains 32 uniformly random bytes, though\n+ * it optional (and does result in encodings that are indistinguishable from\n+ * uniform without any auxrand32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrand32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:  a pointer to the 64-byte ElligatorSwift public key\n+ *                      received from the other party.\n+ *           ours64:    a pointer to the 64-byte ElligatorSwift public key\n+ *                      sent to the other party.\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)\n+ *           hashfp:    pointer to a hash function. If NULL,\n+ *                      secp256k1_ellswift_xdh_hash_function_default is used\n+ *                      (in which case, 32 bytes will be written to output).",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 153,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6128b71166da64f6859c21885e8699cdaafccf3a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since `hashfp` is not allowed to be NULL (as indicated by `SECP256K1_ARG_NONNULL(6)` below and `ARG_CHECK(hashfp != NULL);` in the implementation), the second sentence is obsolete:\r\n```suggestion\r\n *           hashfp:    pointer to a hash function.\r\n```",
      "created_at": "2023-05-08T10:17:38Z",
      "updated_at": "2023-05-08T10:37:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1187277320",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1187277320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 151,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1187281119",
      "pull_request_review_id": 1416527777,
      "id": 1187281119,
      "node_id": "PRRC_kwDOAP4Jqs5GxHjf",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key.\n+ *           auxrand32:  (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrand32 contains 32 uniformly random bytes, though\n+ * it optional (and does result in encodings that are indistinguishable from\n+ * uniform without any auxrand32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrand32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:  a pointer to the 64-byte ElligatorSwift public key\n+ *                      received from the other party.\n+ *           ours64:    a pointer to the 64-byte ElligatorSwift public key\n+ *                      sent to the other party.\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)\n+ *           hashfp:    pointer to a hash function. If NULL,\n+ *                      secp256k1_ellswift_xdh_hash_function_default is used\n+ *                      (in which case, 32 bytes will be written to output).\n+ *           data:      arbitrary data pointer passed through to hashfp (ignored\n+ *                      by secp256k1_ellswift_xdh_hash_function_default).",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 155,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6128b71166da64f6859c21885e8699cdaafccf3a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems like `secp256k1_ellswift_xdh_hash_function_default` doesn't exist anymore:\r\n```suggestion\r\n *           data:      arbitrary data pointer passed through to hashfp.\r\n```",
      "created_at": "2023-05-08T10:22:28Z",
      "updated_at": "2023-05-08T10:37:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1187281119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1187281119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188241618",
      "pull_request_review_id": 1418041677,
      "id": 1188241618,
      "node_id": "PRRC_kwDOAP4Jqs5G0yDS",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key.\n+ *           auxrand32:  (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrand32 contains 32 uniformly random bytes, though\n+ * it optional (and does result in encodings that are indistinguishable from\n+ * uniform without any auxrand32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrand32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:  a pointer to the 64-byte ElligatorSwift public key\n+ *                      received from the other party.\n+ *           ours64:    a pointer to the 64-byte ElligatorSwift public key\n+ *                      sent to the other party.\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)\n+ *           hashfp:    pointer to a hash function. If NULL,\n+ *                      secp256k1_ellswift_xdh_hash_function_default is used\n+ *                      (in which case, 32 bytes will be written to output).",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 153,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6128b71166da64f6859c21885e8699cdaafccf3a",
      "in_reply_to_id": 1187277320,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-09T07:27:37Z",
      "updated_at": "2023-05-09T07:27:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188241618",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188241618"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 151,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188241733",
      "pull_request_review_id": 1418041891,
      "id": 1188241733,
      "node_id": "PRRC_kwDOAP4Jqs5G0yFF",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key.\n+ *           auxrand32:  (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrand32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrand32 contains 32 uniformly random bytes, though\n+ * it optional (and does result in encodings that are indistinguishable from\n+ * uniform without any auxrand32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrand32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrand32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      theirs64:  a pointer to the 64-byte ElligatorSwift public key\n+ *                      received from the other party.\n+ *           ours64:    a pointer to the 64-byte ElligatorSwift public key\n+ *                      sent to the other party.\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)\n+ *           hashfp:    pointer to a hash function. If NULL,\n+ *                      secp256k1_ellswift_xdh_hash_function_default is used\n+ *                      (in which case, 32 bytes will be written to output).\n+ *           data:      arbitrary data pointer passed through to hashfp (ignored\n+ *                      by secp256k1_ellswift_xdh_hash_function_default).",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 155,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6128b71166da64f6859c21885e8699cdaafccf3a",
      "in_reply_to_id": 1187281119,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-09T07:27:46Z",
      "updated_at": "2023-05-09T07:27:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188241733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188241733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188269769",
      "pull_request_review_id": 1414501432,
      "id": 1188269769,
      "node_id": "PRRC_kwDOAP4Jqs5G047J",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any other order requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2).$\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. The division in the first branch in fact cannot occur at all, $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs (besides division by zero).\n+For cryptographically sized curves, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targetted uniformly by the\n+    encoder anyway as there will generally be more than 8.\n+  * When $g(x) = 0$, the same $t$ would be produced as in the $x_3$ branch (where $c \\in \\\\{2, 3, 6, 7\\\\}$) which we give precedence\n+    as it can deal with $g(u)=0$.\n+    This is again only possible on even-ordered curves.\n+* In the branch for $x_3$ (where $c \\in \\\\{2, 3, 6, 7\\\\}$):\n+  * When $u = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 324,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8183a34: should be v = -u -v?",
      "created_at": "2023-05-09T07:55:05Z",
      "updated_at": "2023-05-09T08:29:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188269769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188269769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188382298",
      "pull_request_review_id": 1418257967,
      "id": 1188382298,
      "node_id": "PRRC_kwDOAP4Jqs5G1UZa",
      "diff_hunk": "@@ -0,0 +1,186 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  H_tag(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. H_tag is the BIP340 tagged\n+ *  hash function whose tag is the zero-terminated C string pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_tagged;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(init_pubkey || resp_pubkey || x32), where H_tag is\n+ *  the BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\",\n+ *  and init_pubkey is ours64 if *(int*)data is true and theirs64 otherwise.\n+ *  resp_pubkey is the other key. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: this confused me because `must` and `must not` sound like necessary requirements. It's fine to use some hardened derivation of the secret key as rnd32 (which is not independent of the pubkey) and it's fine to derive rnd32 deterministically from pubkey and some secret data.",
      "created_at": "2023-05-09T09:32:14Z",
      "updated_at": "2023-05-09T09:32:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188382298",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188382298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188398639",
      "pull_request_review_id": 1418284891,
      "id": 1188398639,
      "node_id": "PRRC_kwDOAP4Jqs5G1YYv",
      "diff_hunk": "@@ -3909,6 +3914,29 @@ static void test_ge(void) {\n         free(ge_set_all);\n     }\n \n+    /* Test all elements have X coordinates on the curve. */\n+    for (i = 1; i < 4 * runs + 1; i++) {\n+        secp256k1_fe n;\n+        CHECK(secp256k1_ge_x_on_curve_var(&ge[i].x));\n+        /* And the same holds after random rescaling. */\n+        secp256k1_fe_mul(&n, &zf, &ge[i].x);\n+        CHECK(secp256k1_ge_x_frac_on_curve_var(&n, &zf));\n+    }\n+\n+    /* Test correspondence secp256k1_ge_x{,_frac}_on_curve_var with ge_set_xo. */\n+    {\n+        secp256k1_fe n;\n+        secp256k1_ge q;\n+        int ret_on_curve, ret_frac_on_curve, ret_set_xo;\n+        secp256k1_fe_mul(&n, &zf, &r);\n+        ret_on_curve = secp256k1_ge_x_on_curve_var(&r);\n+        ret_frac_on_curve = secp256k1_ge_x_frac_on_curve_var(&n, &zf);\n+        ret_set_xo = secp256k1_ge_set_xo_var(&q, &r, 0);\n+        CHECK(ret_on_curve == ret_frac_on_curve);\n+        CHECK(ret_on_curve == ret_set_xo);\n+        if (ret_set_xo) CHECK(secp256k1_fe_equal_var(&r, &q.x));",
      "path": "src/tests.c",
      "position": 63,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54a33377f6613f99f957aedae4c7d7660dad81b3",
      "in_reply_to_id": 1186650655,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would, but I don't think a caller should assume anything about the behavior of `secp256k1_ge_set_xo_var`'s output in case failure is returned. It's of course just an internal function, and there are no API guarantees or anything to account for, but I still think it's better design to avoid that.",
      "created_at": "2023-05-09T09:45:40Z",
      "updated_at": "2023-05-09T09:45:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188398639",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188398639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3968,
      "original_line": 3968,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188409827",
      "pull_request_review_id": 1418302489,
      "id": 1188409827,
      "node_id": "PRRC_kwDOAP4Jqs5G1bHj",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any other order requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2).$\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. The division in the first branch in fact cannot occur at all, $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs (besides division by zero).\n+For cryptographically sized curves, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targetted uniformly by the\n+    encoder anyway as there will generally be more than 8.\n+  * When $g(x) = 0$, the same $t$ would be produced as in the $x_3$ branch (where $c \\in \\\\{2, 3, 6, 7\\\\}$) which we give precedence\n+    as it can deal with $g(u)=0$.\n+    This is again only possible on even-ordered curves.\n+* In the branch for $x_3$ (where $c \\in \\\\{2, 3, 6, 7\\\\}$):\n+  * When $u = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 324,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": 1188269769,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice catch. Fixed.",
      "created_at": "2023-05-09T09:54:57Z",
      "updated_at": "2023-05-09T09:54:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188409827",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188409827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410009",
      "pull_request_review_id": 1418302831,
      "id": 1188410009,
      "node_id": "PRRC_kwDOAP4Jqs5G1bKZ",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 38,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "77d2ece87020f4967e1e41dfb34b9a37c24a5ce5",
      "in_reply_to_id": 1186783260,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-09T09:55:07Z",
      "updated_at": "2023-05-09T09:55:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188410009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410176",
      "pull_request_review_id": 1418303059,
      "id": 1188410176,
      "node_id": "PRRC_kwDOAP4Jqs5G1bNA",
      "diff_hunk": "@@ -0,0 +1,476 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformy random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any other order requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}.$\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2).$\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. The division in the first branch in fact cannot occur at all, $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs (besides division by zero).\n+For cryptographically sized curves, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targetted uniformly by the",
      "path": "doc/ellswift.md",
      "position": null,
      "original_position": 318,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "77d2ece87020f4967e1e41dfb34b9a37c24a5ce5",
      "in_reply_to_id": 1186783120,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-09T09:55:14Z",
      "updated_at": "2023-05-09T09:55:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188410176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410439",
      "pull_request_review_id": 1418303455,
      "id": 1188410439,
      "node_id": "PRRC_kwDOAP4Jqs5G1bRH",
      "diff_hunk": "@@ -260,6 +266,7 @@ message(\"  ECDH ................................ ${SECP256K1_ENABLE_MODULE_ECDH}\n message(\"  ECDSA pubkey recovery ............... ${SECP256K1_ENABLE_MODULE_RECOVERY}\")\n message(\"  extrakeys ........................... ${SECP256K1_ENABLE_MODULE_EXTRAKEYS}\")\n message(\"  schnorrsig .......................... ${SECP256K1_ENABLE_MODULE_SCHNORRSIG}\")\n+message(\"  ElligatorSwift....................... ${SECP256K1_ENABLE_MODULE_ELLSWIFT}\")",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 17,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186705361,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Was already fixed, I think?",
      "created_at": "2023-05-09T09:55:27Z",
      "updated_at": "2023-05-09T09:55:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188410439",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410621",
      "pull_request_review_id": 1418303765,
      "id": 1188410621,
      "node_id": "PRRC_kwDOAP4Jqs5G1bT9",
      "diff_hunk": "@@ -0,0 +1,563 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 128,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186703090,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice. Fixed.",
      "created_at": "2023-05-09T09:55:36Z",
      "updated_at": "2023-05-09T09:55:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188410621",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188410621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411068",
      "pull_request_review_id": 1418304507,
      "id": 1188411068,
      "node_id": "PRRC_kwDOAP4Jqs5G1ba8",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** The default secp256k1_ellswift_xdh_hash_function, currently\n+    secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 123,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186659554,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, this predated the context relaxations. Fixed.",
      "created_at": "2023-05-09T09:55:58Z",
      "updated_at": "2023-05-09T09:55:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188411068",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411436",
      "pull_request_review_id": 1418305054,
      "id": 1188411436,
      "node_id": "PRRC_kwDOAP4Jqs5G1bgs",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_sha256;\n+\n+/** The default secp256k1_ellswift_xdh_hash_function, currently\n+    secp256k1_ellswift_xdh_hash_function_sha256. */\n+SECP256K1_API extern const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_default;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object, initialized for signing.\n+ *  Out:     ell64:      pointer to a 64-byte area to receive the ElligatorSwift",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 124,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186659212,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a strange typo. Fixed.",
      "created_at": "2023-05-09T09:56:15Z",
      "updated_at": "2023-05-09T09:56:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188411436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411583",
      "pull_request_review_id": 1418305292,
      "id": 1188411583,
      "node_id": "PRRC_kwDOAP4Jqs5G1bi_",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186657105,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-09T09:56:23Z",
      "updated_at": "2023-05-09T09:56:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188411583",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411772",
      "pull_request_review_id": 1418305609,
      "id": 1188411772,
      "node_id": "PRRC_kwDOAP4Jqs5G1bl8",
      "diff_hunk": "@@ -207,6 +226,7 @@ int main(int argc, char** argv) {\n     if (d || have_flag(argc, argv, \"ecdsa\") || have_flag(argc, argv, \"verify\") || have_flag(argc, argv, \"ecdsa_verify\")) run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n \n     if (d || have_flag(argc, argv, \"ecdsa\") || have_flag(argc, argv, \"sign\") || have_flag(argc, argv, \"ecdsa_sign\")) run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"ec\") || have_flag(argc, argv, \"keygen\") || have_flag(argc, argv, \"ec_keygen\")) run_benchmark(\"ec_keygen\", bench_keygen_run, bench_sign_setup, NULL, &data, 10, iters);",
      "path": "src/bench.c",
      "position": null,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "84a735dd67d531d10633e7d21647ea12f68687df",
      "in_reply_to_id": 1185932386,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fair point, I've introduce a separate `bench_keygen_setup`. I've also merged the different bench data types, because the former code was possibly illegally casting `bench_verify_data*` to `bench_sign_data*`.",
      "created_at": "2023-05-09T09:56:32Z",
      "updated_at": "2023-05-09T09:56:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188411772",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188411772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188412156",
      "pull_request_review_id": 1418306174,
      "id": 1188412156,
      "node_id": "PRRC_kwDOAP4Jqs5G1br8",
      "diff_hunk": "@@ -121,6 +123,22 @@ static void bench_sign_run(void* arg, int iters) {\n     }\n }\n \n+static void bench_keygen_run(void *arg, int iters) {\n+    int i;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char pub33[33];\n+        size_t len = 33;\n+        secp256k1_pubkey pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->key));\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, pub33, &len, &pubkey, SECP256K1_EC_COMPRESSED));\n+        memcpy(data->key, pub33 + 1, 32);\n+        data->key[17] ^= i;",
      "path": "src/bench.c",
      "position": null,
      "original_position": 24,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "84a735dd67d531d10633e7d21647ea12f68687df",
      "in_reply_to_id": 1185911987,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think my reasoning may have been that I wanted to avoid using just valid X coordinates as private keys, but that really doesn't add anything. Removed.",
      "created_at": "2023-05-09T09:56:48Z",
      "updated_at": "2023-05-09T09:56:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188412156",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188412156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188427598",
      "pull_request_review_id": 1418335109,
      "id": 1188427598,
      "node_id": "PRRC_kwDOAP4Jqs5G1fdO",
      "diff_hunk": "@@ -0,0 +1,186 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  H_tag(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. H_tag is the BIP340 tagged\n+ *  hash function whose tag is the zero-terminated C string pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_tagged;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(init_pubkey || resp_pubkey || x32), where H_tag is\n+ *  the BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\",\n+ *  and init_pubkey is ours64 if *(int*)data is true and theirs64 otherwise.\n+ *  resp_pubkey is the other key. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": 1188382298,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How about: \"must not be a deterministic function of just the public key\"?",
      "created_at": "2023-05-09T10:04:38Z",
      "updated_at": "2023-05-09T10:04:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188427598",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188427598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188436954",
      "pull_request_review_id": 1418331163,
      "id": 1188436954,
      "node_id": "PRRC_kwDOAP4Jqs5G1hva",
      "diff_hunk": "@@ -0,0 +1,589 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 402,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "97eefc4d500a705514dd27106689970484453f17",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `ent32` arg is called `rnd32` in the include file",
      "created_at": "2023-05-09T10:12:46Z",
      "updated_at": "2023-05-09T10:19:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188436954",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188436954"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188441862",
      "pull_request_review_id": 1418331163,
      "id": 1188441862,
      "node_id": "PRRC_kwDOAP4Jqs5G1i8G",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 11,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633338,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could mention now that it's compatible with BIP 324 if the BIP 324 hasher is used.",
      "created_at": "2023-05-09T10:17:10Z",
      "updated_at": "2023-05-09T10:19:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188441862",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188441862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 10,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188443082",
      "pull_request_review_id": 1418331163,
      "id": 1188443082,
      "node_id": "PRRC_kwDOAP4Jqs5G1jPK",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible, because if -(u^2 + u*x + x^2) = 0, then\n+         * x^3 + B = (-u-x)^3 + B. We know x^3 + B is square (because x is on the curve), yet we\n+         * also know that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m) test\n+         * above would have failed). This is a contradiction. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ent32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p33[33];\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || ent32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        secp256k1_fe_get_b32(p33 + 1, &p.x);\n+        p33[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_sha256_write(&hash, p33, sizeof(p33));\n+        secp256k1_sha256_write(&hash, ent32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_create\". */\n+static void secp256k1_ellswift_sha256_init_create(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd29e1bf5ul;\n+    hash->s[1] = 0xf7025f42ul;\n+    hash->s[2] = 0x9b024773ul;\n+    hash->s[3] = 0x094cb7d5ul;\n+    hash->s[4] = 0xe59ed789ul;\n+    hash->s[5] = 0x03bc9786ul;\n+    hash->s[6] = 0x68335b35ul;\n+    hash->s[7] = 0x4e363b53ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *auxrand32) {\n+    secp256k1_ge p;\n+    secp256k1_fe t;\n+    secp256k1_sha256 hash;\n+    secp256k1_scalar seckey_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    memset(ell64, 0, 64);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    /* Compute (affine) public key */\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */\n+    secp256k1_fe_normalize_var(&p.x);\n+    secp256k1_fe_normalize_var(&p.y);\n+\n+    /* Set up hasher state. The used RNG is H(privkey [|| auxrand32] || cnt++), using BIP340 tagged\n+     * hash with tag \"secp256k1_ellswift_create\". */\n+    secp256k1_ellswift_sha256_init_create(&hash);\n+    secp256k1_sha256_write(&hash, seckey32, 32);\n+    if (auxrand32) secp256k1_sha256_write(&hash, auxrand32, 32);\n+    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* hasher gets to declassify private key */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 461,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1184157240,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks good!",
      "created_at": "2023-05-09T10:18:20Z",
      "updated_at": "2023-05-09T10:19:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188443082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188443082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188486983",
      "pull_request_review_id": 1418426512,
      "id": 1188486983,
      "node_id": "PRRC_kwDOAP4Jqs5G1t9H",
      "diff_hunk": "@@ -0,0 +1,186 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  H_tag(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. H_tag is the BIP340 tagged\n+ *  hash function whose tag is the zero-terminated C string pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_tagged;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(init_pubkey || resp_pubkey || x32), where H_tag is\n+ *  the BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\",\n+ *  and init_pubkey is ours64 if *(int*)data is true and theirs64 otherwise.\n+ *  resp_pubkey is the other key. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": 1188382298,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've made some edits here.",
      "created_at": "2023-05-09T10:58:31Z",
      "updated_at": "2023-05-09T10:58:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188486983",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188486983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188487350",
      "pull_request_review_id": 1418427088,
      "id": 1188487350,
      "node_id": "PRRC_kwDOAP4Jqs5G1uC2",
      "diff_hunk": "@@ -0,0 +1,589 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        (void)secp256k1_fe_set_b32(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *ent32) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 402,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "97eefc4d500a705514dd27106689970484453f17",
      "in_reply_to_id": 1188436954,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've renamed it consistently to `rnd32` and `auxrnd32` everywhere.",
      "created_at": "2023-05-09T10:58:52Z",
      "updated_at": "2023-05-09T10:58:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188487350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188487350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188566125",
      "pull_request_review_id": 1418581817,
      "id": 1188566125,
      "node_id": "PRRC_kwDOAP4Jqs5G2BRt",
      "diff_hunk": "@@ -0,0 +1,186 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * public keys in 64-byte objects which are indistinguishable from\n+ * uniformly random.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hashing the shared\n+ *  X coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ours64:     pointer to the 64-byte encoded public key we sent\n+ *                       to the other party (will not be NULL)\n+ *           theirs64:   pointer to the 64-byte encoded public key we received\n+ *                       from the other party (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ours64,\n+  const unsigned char *theirs64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  H_tag(key1 || key2 || x32), where (key1, key2) = sort([ours64, theirs64]),\n+ *  and ignores data. The sorting is lexicographic. H_tag is the BIP340 tagged\n+ *  hash function whose tag is the zero-terminated C string pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_tagged;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(init_pubkey || resp_pubkey || x32), where H_tag is\n+ *  the BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\",\n+ *  and init_pubkey is ours64 if *(int*)data is true and theirs64 otherwise.\n+ *  resp_pubkey is the other key. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must be independent of pubkey. In\n+ * particular, it must not be derived deterministically from pubkey.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "8183a34037fd89422f0fa755c226a8b7f4b0308b",
      "in_reply_to_id": 1188382298,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":+1: ",
      "created_at": "2023-05-09T13:03:26Z",
      "updated_at": "2023-05-09T13:03:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188566125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188566125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188644761",
      "pull_request_review_id": 1418704970,
      "id": 1188644761,
      "node_id": "PRRC_kwDOAP4Jqs5G2UeZ",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "08ed2b426458099de7a8421b9bbb8da334db8925",
      "in_reply_to_id": 1183777035,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm fine with the module being non-experimental. If it happens that we have to change the API, we can make a new (minor) release.",
      "created_at": "2023-05-09T13:57:37Z",
      "updated_at": "2023-05-09T13:57:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188644761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188644761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188659205",
      "pull_request_review_id": 1418729566,
      "id": 1188659205,
      "node_id": "PRRC_kwDOAP4Jqs5G2YAF",
      "diff_hunk": "@@ -171,4 +178,28 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n+\n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, ellswift);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_bip324, &ret);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_tagged, \"bench_test\");",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "9a9900ed998b213d457df945ff7fcfb141499589",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CI fails because we need to `s/_tagged/_prefix`.",
      "created_at": "2023-05-09T14:07:23Z",
      "updated_at": "2023-05-09T14:07:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188659205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188659205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188661695",
      "pull_request_review_id": 1418733035,
      "id": 1188661695,
      "node_id": "PRRC_kwDOAP4Jqs5G2Ym_",
      "diff_hunk": "@@ -171,4 +178,28 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n+\n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, ellswift);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_bip324, &ret);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_tagged, \"bench_test\");",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "9a9900ed998b213d457df945ff7fcfb141499589",
      "in_reply_to_id": 1188659205,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "... and change the data to be 64 bytes",
      "created_at": "2023-05-09T14:08:56Z",
      "updated_at": "2023-05-09T14:09:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1188661695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1188661695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189029829",
      "pull_request_review_id": 1419297638,
      "id": 1189029829,
      "node_id": "PRRC_kwDOAP4Jqs5G3yfF",
      "diff_hunk": "@@ -121,6 +123,22 @@ static void bench_sign_run(void* arg, int iters) {\n     }\n }\n \n+static void bench_keygen_run(void *arg, int iters) {\n+    int i;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char pub33[33];\n+        size_t len = 33;\n+        secp256k1_pubkey pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->key));\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, pub33, &len, &pubkey, SECP256K1_EC_COMPRESSED));\n+        memcpy(data->key, pub33 + 1, 32);\n+        data->key[17] ^= i;",
      "path": "src/bench.c",
      "position": null,
      "original_position": 24,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "84a735dd67d531d10633e7d21647ea12f68687df",
      "in_reply_to_id": 1185911987,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh, interesting.",
      "created_at": "2023-05-09T19:08:08Z",
      "updated_at": "2023-05-09T19:08:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189029829",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189029829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189029947",
      "pull_request_review_id": 1419297774,
      "id": 1189029947,
      "node_id": "PRRC_kwDOAP4Jqs5G3yg7",
      "diff_hunk": "@@ -260,6 +266,7 @@ message(\"  ECDH ................................ ${SECP256K1_ENABLE_MODULE_ECDH}\n message(\"  ECDSA pubkey recovery ............... ${SECP256K1_ENABLE_MODULE_RECOVERY}\")\n message(\"  extrakeys ........................... ${SECP256K1_ENABLE_MODULE_EXTRAKEYS}\")\n message(\"  schnorrsig .......................... ${SECP256K1_ENABLE_MODULE_SCHNORRSIG}\")\n+message(\"  ElligatorSwift....................... ${SECP256K1_ENABLE_MODULE_ELLSWIFT}\")",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 17,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186705361,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "doesn't look like it. (there's a single space after schnorrsig/extrakeys etc.. but not after ElligatorSwift.)",
      "created_at": "2023-05-09T19:08:15Z",
      "updated_at": "2023-05-09T19:08:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189029947",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189029947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189378470",
      "pull_request_review_id": 1419808474,
      "id": 1189378470,
      "node_id": "PRRC_kwDOAP4Jqs5G5Hmm",
      "diff_hunk": "@@ -3909,6 +3914,29 @@ static void test_ge(void) {\n         free(ge_set_all);\n     }\n \n+    /* Test all elements have X coordinates on the curve. */\n+    for (i = 1; i < 4 * runs + 1; i++) {\n+        secp256k1_fe n;\n+        CHECK(secp256k1_ge_x_on_curve_var(&ge[i].x));\n+        /* And the same holds after random rescaling. */\n+        secp256k1_fe_mul(&n, &zf, &ge[i].x);\n+        CHECK(secp256k1_ge_x_frac_on_curve_var(&n, &zf));\n+    }\n+\n+    /* Test correspondence secp256k1_ge_x{,_frac}_on_curve_var with ge_set_xo. */\n+    {\n+        secp256k1_fe n;\n+        secp256k1_ge q;\n+        int ret_on_curve, ret_frac_on_curve, ret_set_xo;\n+        secp256k1_fe_mul(&n, &zf, &r);\n+        ret_on_curve = secp256k1_ge_x_on_curve_var(&r);\n+        ret_frac_on_curve = secp256k1_ge_x_frac_on_curve_var(&n, &zf);\n+        ret_set_xo = secp256k1_ge_set_xo_var(&q, &r, 0);\n+        CHECK(ret_on_curve == ret_frac_on_curve);\n+        CHECK(ret_on_curve == ret_set_xo);\n+        if (ret_set_xo) CHECK(secp256k1_fe_equal_var(&r, &q.x));",
      "path": "src/tests.c",
      "position": 63,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54a33377f6613f99f957aedae4c7d7660dad81b3",
      "in_reply_to_id": 1186650655,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh! true, it's possible the function behaves unpredictably in a different environment. agree with keeping it as it is.",
      "created_at": "2023-05-10T05:35:37Z",
      "updated_at": "2023-05-10T05:35:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189378470",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189378470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3968,
      "original_line": 3968,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189491280",
      "pull_request_review_id": 1419972630,
      "id": 1189491280,
      "node_id": "PRRC_kwDOAP4Jqs5G5jJQ",
      "diff_hunk": "@@ -142,6 +150,19 @@ static const struct ellswift_decode_test ellswift_decode_tests[] = {\n     {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n };\n \n+/* Set of expected ellswift_xdh BIP324 shared secrets, given private key, encodings, initiating,\n+ * taken from the BIP324 test vectors. Created using an independent implementation, and tested\n+ * against the paper authors' decoding code. */",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 154,
      "original_position": 21,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "ad60aaef5f1728ab3f38446c90fe064e07f9e1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4c758e4: just clarifying that you meant testing the decoding part of xdh with the paper author's code?",
      "created_at": "2023-05-10T07:48:04Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189491280",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189491280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189504027",
      "pull_request_review_id": 1419972630,
      "id": 1189504027,
      "node_id": "PRRC_kwDOAP4Jqs5G5mQb",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 2,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "dba66c9d8a87fe65a7d276b2632a276cb7f135cb",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78 :P",
      "created_at": "2023-05-10T07:59:04Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189504027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189504027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189949897",
      "pull_request_review_id": 1420705905,
      "id": 1189949897,
      "node_id": "PRRC_kwDOAP4Jqs5G7THJ",
      "diff_hunk": "@@ -171,4 +178,28 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n+\n+#ifdef ENABLE_MODULE_ELLSWIFT\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ellswift_create(ctx, ellswift, key, ellswift);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_bip324, &ret);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_DEFINED(&ellswift, sizeof(ellswift));\n+    ret = secp256k1_ellswift_xdh(ctx, msg, ellswift, ellswift, key, secp256k1_ellswift_xdh_hash_function_tagged, \"bench_test\");",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 45,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "9a9900ed998b213d457df945ff7fcfb141499589",
      "in_reply_to_id": 1188659205,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-10T13:54:32Z",
      "updated_at": "2023-05-10T13:54:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189949897",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189949897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189950309",
      "pull_request_review_id": 1420706586,
      "id": 1189950309,
      "node_id": "PRRC_kwDOAP4Jqs5G7TNl",
      "diff_hunk": "@@ -260,6 +266,7 @@ message(\"  ECDH ................................ ${SECP256K1_ENABLE_MODULE_ECDH}\n message(\"  ECDSA pubkey recovery ............... ${SECP256K1_ENABLE_MODULE_RECOVERY}\")\n message(\"  extrakeys ........................... ${SECP256K1_ENABLE_MODULE_EXTRAKEYS}\")\n message(\"  schnorrsig .......................... ${SECP256K1_ENABLE_MODULE_SCHNORRSIG}\")\n+message(\"  ElligatorSwift....................... ${SECP256K1_ENABLE_MODULE_ELLSWIFT}\")",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 17,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "213927943d6dc8ce0442b0e185099d6885c70aea",
      "in_reply_to_id": 1186705361,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed now.",
      "created_at": "2023-05-10T13:54:50Z",
      "updated_at": "2023-05-10T13:54:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189950309",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189950309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189952900",
      "pull_request_review_id": 1420710533,
      "id": 1189952900,
      "node_id": "PRRC_kwDOAP4Jqs5G7T2E",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "08ed2b426458099de7a8421b9bbb8da334db8925",
      "in_reply_to_id": 1183777035,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We decided to not make it experimental. If anything, the most likely place where API changes may be expected still is in the hashers, but adding new hashers while deprecating but maintaining the old ones isn't a high burden.",
      "created_at": "2023-05-10T13:56:38Z",
      "updated_at": "2023-05-10T13:56:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189952900",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189952900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189955782",
      "pull_request_review_id": 1420714913,
      "id": 1189955782,
      "node_id": "PRRC_kwDOAP4Jqs5G7UjG",
      "diff_hunk": "@@ -0,0 +1,170 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as\n+ * a version of x-only ECDH using it.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 11,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54fff1ddc578e4263760e4d7121257b413a29b55",
      "in_reply_to_id": 1174633338,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-10T13:58:35Z",
      "updated_at": "2023-05-10T13:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189955782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189955782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 10,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189957192",
      "pull_request_review_id": 1420717223,
      "id": 1189957192,
      "node_id": "PRRC_kwDOAP4Jqs5G7U5I",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s)\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)+u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 167,
      "original_position": 166,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "974d00c8e10e8da125285e3a535f4de3e52f3c1c",
      "in_reply_to_id": 1181478706,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Decided not to do this, because the performance gains are tiny (saves one field negation), but is further removed from the explanation (and probably simpler described as-is).",
      "created_at": "2023-05-10T13:59:31Z",
      "updated_at": "2023-05-10T13:59:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1189957192",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1189957192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 167,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190085950",
      "pull_request_review_id": 1419972630,
      "id": 1190085950,
      "node_id": "PRRC_kwDOAP4Jqs5G70U-",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 53,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78: wow! `enc_bitmap = 0x77` and 6 distinct t values? :0\r\n\r\n(4 distinct v,w pairs => 8 distinct t, do some of them end up invalid for some reason?)",
      "created_at": "2023-05-10T15:31:47Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1190085950",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190085950"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190936480",
      "pull_request_review_id": 1419972630,
      "id": 1190936480,
      "node_id": "PRRC_kwDOAP4Jqs5G_D-g",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 147,
      "original_position": 147,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "b4191137773a7ca441c6c4e51448e3000d590bd5",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1c369b8: should we normalize x before passing it to `secp256k1_ge_set_xo_var` where there's an `x**3` computation?\r\n\r\ni haven't understood why we normalize at some places and not at others. what's the worst that could happen if we forget to normalize?\r\n\r\nI understood that normalization is making the the field element into a form which is less than `p` + making sure less than 1 magnitude. I tried following the details of how normalization is implemented in the codebase but wasn't able to make progress.",
      "created_at": "2023-05-11T10:01:30Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1190936480",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190936480"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190971066",
      "pull_request_review_id": 1419972630,
      "id": 1190971066,
      "node_id": "PRRC_kwDOAP4Jqs5G_Ma6",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 169,
      "original_position": 169,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "b4191137773a7ca441c6c4e51448e3000d590bd5",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1c369b8: would ensuring that this is called with valid x coordinates be desirable/too strict? the call site would use pubkeys and so valid x coordinates anyways. just curious about how functions are designed here.",
      "created_at": "2023-05-11T10:32:12Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1190971066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1190971066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191598414",
      "pull_request_review_id": 1419972630,
      "id": 1191598414,
      "node_id": "PRRC_kwDOAP4Jqs5HBllO",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 208,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78: micro nit: maybe call rnd32, rnd32a, rnd32b as auxrnd32 in the tests if you do end up touching this commit again.",
      "created_at": "2023-05-11T19:21:45Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1191598414",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191598414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191896014",
      "pull_request_review_id": 1419972630,
      "id": 1191896014,
      "node_id": "PRRC_kwDOAP4Jqs5HCuPO",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 358,
      "original_position": 286,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78: `secp256k1_ellswift_xdh` would successfully compute even if ell64 and secret key are invalid right? confused because it's `ret` check here when ell64 has changed but `!ret` check when secret key has changed.",
      "created_at": "2023-05-12T04:33:34Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1191896014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191896014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 358,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191896924",
      "pull_request_review_id": 1419972630,
      "id": 1191896924,
      "node_id": "PRRC_kwDOAP4Jqs5HCudc",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 290,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78: would it be worth having another variable to store the original share32 value and then comparing the new value with the original one? (share32a has already changed at this point - so doesn't make sense comparing them i think)",
      "created_at": "2023-05-12T04:35:59Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1191896924",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1191896924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 344,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1192102799",
      "pull_request_review_id": 1419972630,
      "id": 1192102799,
      "node_id": "PRRC_kwDOAP4Jqs5HDguP",
      "diff_hunk": "@@ -495,6 +495,53 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\n     return 1;\n }\n \n+static int ellswift_xdh_hash_function_prefix(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    secp256k1_sha256 sha;\n+\n+    (void)data;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4c758e426eaf05032e2eead0055b5f2a55504bce",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4c758e4: noticed this `(void)variable;` pattern used in many files - this seems to be done when the `variable` isn't used later on in the function. but `data` is used later on in the function here. curious to know what this statement actually does?",
      "created_at": "2023-05-12T08:56:52Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1192102799",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1192102799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1192112759",
      "pull_request_review_id": 1419972630,
      "id": 1192112759,
      "node_id": "PRRC_kwDOAP4Jqs5HDjJ3",
      "diff_hunk": "@@ -0,0 +1,316 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 248,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6048c780b2f22fac667d98b1769735bd0d09a97f",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "6048c78: micro nit: s/ell/ell64",
      "created_at": "2023-05-12T09:05:41Z",
      "updated_at": "2023-05-12T10:54:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1192112759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1192112759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193145329",
      "pull_request_review_id": 1425549143,
      "id": 1193145329,
      "node_id": "PRRC_kwDOAP4Jqs5HHfPx",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 147,
      "original_position": 147,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "b4191137773a7ca441c6c4e51448e3000d590bd5",
      "in_reply_to_id": 1190936480,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> should we normalize x before passing it to secp256k1_ge_set_xo_var where there's an x**3 computation?\r\n\r\n> i haven't understood why we normalize at some places and not at others.\r\n\r\nNo, the requirements are roughly:\r\n* Magnitude can never exceed 32 (for all field operations)\r\n* On input to `mul` or `sqr`, magnitude cannot exceed 8.\r\n* `add` and `negate` increase magnitude, so things that involve additions/negations usually want magnitude 1.\r\n* `is_odd` and `is_equal` need full normalization (because they operate on canonical integer representation)\r\n\r\nSince #1066, all those rules should be explained exactly in `field.h` (and checked programmatically in the wrappers in `field_impl.h`).\r\n\r\n> what's the worst that could happen if we forget to normalize?\r\n\r\nWell if we actually forget and as a result violate normalization/magnitude constraints, in production non-`VERIFY` code, the computation will just be wrong. Very bad.\r\n\r\nBut it's also extremely easy to verify: the magnitude/normalization properties of field values (almost) never depend on runtime values; they're just a function of what operations have been performed. And in `VERIFY` mode, the normalization and magnitude values are tracked and checked explicitly, so if all code paths are exercised in the tests, it shouldn't be possible to trigger a violation.",
      "created_at": "2023-05-14T13:13:06Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193145329",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193145329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204694",
      "pull_request_review_id": 1425549143,
      "id": 1193204694,
      "node_id": "PRRC_kwDOAP4Jqs5HHtvW",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 169,
      "original_position": 169,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "b4191137773a7ca441c6c4e51448e3000d590bd5",
      "in_reply_to_id": 1190971066,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, added in a `VERIFY_CHECK`.",
      "created_at": "2023-05-14T20:29:01Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193204694",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204829",
      "pull_request_review_id": 1425549143,
      "id": 1193204829,
      "node_id": "PRRC_kwDOAP4Jqs5HHtxd",
      "diff_hunk": "@@ -495,6 +495,53 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\n     return 1;\n }\n \n+static int ellswift_xdh_hash_function_prefix(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    secp256k1_sha256 sha;\n+\n+    (void)data;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4c758e426eaf05032e2eead0055b5f2a55504bce",
      "in_reply_to_id": 1192102799,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a standard pattern to silence the compiler's \"variable may be unused\" warning; it has no actual effect on the compiled code. In this case, it's because we intentionally ignore a variable.",
      "created_at": "2023-05-14T20:30:28Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193204829",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204870",
      "pull_request_review_id": 1425549143,
      "id": 1193204870,
      "node_id": "PRRC_kwDOAP4Jqs5HHtyG",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 2,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "dba66c9d8a87fe65a7d276b2632a276cb7f135cb",
      "in_reply_to_id": 1189504027,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed all copyright notices, as @real-or-random has suggested before.",
      "created_at": "2023-05-14T20:30:56Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193204870",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193204870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205194",
      "pull_request_review_id": 1425549143,
      "id": 1193205194,
      "node_id": "PRRC_kwDOAP4Jqs5HHt3K",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 53,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1190085950,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can look at the BIP324 test vector where this actually comes from: line 19 in https://github.com/bitcoin/bips/blob/master/bip-0324/xswiftec_inv_test_vectors.csv. The comment explains exactly what happens in each of the 8 c branches:\r\n\r\n> `case0:ok;case1:ok;case2:info[q=0]&info[X=0]&ok;case3:info[q=0]&bad[r=0];case4:ok;case5:ok;case6:info[q=0]&info[X=0]&ok;case7:info[q=0]&bad[r=0]`\r\n\r\nIt's a bit dense, but it means that the c=3 and c=7 don't output anything because of \"r=0\". If you recall, that conditions is there because in this case, the c=2 and c=3 (and also, c=6 and c=7) branches would output the same result. The \"no r=0\" rule invalidates one of the two to make sure this t value isn't twice as likely to be produced as others (not that this actually matters of course, the odds of hitting an r=0 in the first place are negligible, but having this rule makes everything exhaustively testable in tiny curves too).",
      "created_at": "2023-05-14T20:33:21Z",
      "updated_at": "2023-05-14T21:07:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193205194",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205214",
      "pull_request_review_id": 1425549143,
      "id": 1193205214,
      "node_id": "PRRC_kwDOAP4Jqs5HHt3e",
      "diff_hunk": "@@ -142,6 +150,19 @@ static const struct ellswift_decode_test ellswift_decode_tests[] = {\n     {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n };\n \n+/* Set of expected ellswift_xdh BIP324 shared secrets, given private key, encodings, initiating,\n+ * taken from the BIP324 test vectors. Created using an independent implementation, and tested\n+ * against the paper authors' decoding code. */",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 154,
      "original_position": 21,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "ad60aaef5f1728ab3f38446c90fe064e07f9e1ba",
      "in_reply_to_id": 1189491280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, clarified.",
      "created_at": "2023-05-14T20:33:39Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193205214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205438",
      "pull_request_review_id": 1425549143,
      "id": 1193205438,
      "node_id": "PRRC_kwDOAP4Jqs5HHt6-",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 208,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1191598414,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-14T20:35:57Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193205438",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205438"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205754",
      "pull_request_review_id": 1425549143,
      "id": 1193205754,
      "node_id": "PRRC_kwDOAP4Jqs5HHt_6",
      "diff_hunk": "@@ -0,0 +1,316 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 248,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "6048c780b2f22fac667d98b1769735bd0d09a97f",
      "in_reply_to_id": 1192112759,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-14T20:38:37Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193205754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205981",
      "pull_request_review_id": 1425549143,
      "id": 1193205981,
      "node_id": "PRRC_kwDOAP4Jqs5HHuDd",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 358,
      "original_position": 286,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1191896014,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, checking if the encoding matches would be expensive, and shouldn't be needed (if the other side is honest the shared secret will never match if the encoding is wrong, and if both sides are dishonest we don't care about security).",
      "created_at": "2023-05-14T20:40:00Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193205981",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193205981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 358,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193208804",
      "pull_request_review_id": 1425549143,
      "id": 1193208804,
      "node_id": "PRRC_kwDOAP4Jqs5HHuvk",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 290,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1191896924,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea. Done, and also added more tests of this type (checking with different encoding of the same key, and checking swapping of the two sides).",
      "created_at": "2023-05-14T21:03:12Z",
      "updated_at": "2023-05-14T21:03:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1193208804",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1193208804"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 344,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194618340",
      "pull_request_review_id": 1427731966,
      "id": 1194618340,
      "node_id": "PRRC_kwDOAP4Jqs5HNG3k",
      "diff_hunk": "@@ -208,6 +221,15 @@ int main(int argc, char** argv) {\n     }\n #endif\n \n+#ifndef ENABLE_MODULE_ELLSWIFT\n+    if (have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"ellswift_encode\") || have_flag(argc, argv, \"ellswift_decode\") ||\n+        have_flag(argc, argv, \"encode\") || have_flag(argc, argv, \"decode\")) {\n+        fprintf(stderr, \"./bench: ElligatorSwift smodule not enabled.\\n\");",
      "path": "src/bench.c",
      "position": null,
      "original_position": 43,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "54107db: nit: s/smodule/module",
      "created_at": "2023-05-16T05:21:03Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1194618340",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194618340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194621009",
      "pull_request_review_id": 1427731966,
      "id": 1194621009,
      "node_id": "PRRC_kwDOAP4Jqs5HNHhR",
      "diff_hunk": "@@ -208,6 +221,15 @@ int main(int argc, char** argv) {\n     }\n #endif\n \n+#ifndef ENABLE_MODULE_ELLSWIFT\n+    if (have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"ellswift_encode\") || have_flag(argc, argv, \"ellswift_decode\") ||\n+        have_flag(argc, argv, \"encode\") || have_flag(argc, argv, \"decode\")) {",
      "path": "src/bench.c",
      "position": null,
      "original_position": 42,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "54107db: \"ellswift_keygen\" and \"ellswift_ecdh\" too?",
      "created_at": "2023-05-16T05:25:46Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1194621009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194621009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194938931",
      "pull_request_review_id": 1427731966,
      "id": 1194938931,
      "node_id": "PRRC_kwDOAP4Jqs5HOVIz",
      "diff_hunk": "@@ -0,0 +1,107 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+#define SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point[256];\n+    unsigned char rnd64[64];\n+} bench_ellswift_data;\n+\n+static void bench_ellswift_setup(void *arg) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+    static const unsigned char init[64] = {\n+        0x78, 0x1f, 0xb7, 0xd4, 0x67, 0x7f, 0x08, 0x68,\n+        0xdb, 0xe3, 0x1d, 0x7f, 0x1b, 0xb0, 0xf6, 0x9e,\n+        0x0a, 0x64, 0xca, 0x32, 0x9e, 0xc6, 0x20, 0x79,\n+        0x03, 0xf3, 0xd0, 0x46, 0x7a, 0x0f, 0xd2, 0x21,\n+        0xb0, 0x2c, 0x46, 0xd8, 0xba, 0xca, 0x26, 0x4f,\n+        0x8f, 0x8c, 0xd4, 0xdd, 0x2d, 0x04, 0xbe, 0x30,\n+        0x48, 0x51, 0x1e, 0xd4, 0x16, 0xfd, 0x42, 0x85,\n+        0x62, 0xc9, 0x02, 0xf9, 0x89, 0x84, 0xff, 0xdc\n+    };\n+    memcpy(data->rnd64, init, 64);\n+    for (i = 0; i < 256; ++i) {\n+        int j;\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &data->point[i], data->rnd64));\n+        for (j = 0; j < 64; ++j) {\n+            data->rnd64[j] += 1;\n+        }\n+    }\n+    CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[255], init + 16));\n+}\n+\n+static void bench_ellswift_encode(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[i & 255], data->rnd64 + 16));\n+    }\n+}\n+\n+static void bench_ellswift_create(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char buf[64];\n+        CHECK(secp256k1_ellswift_create(data->ctx, buf, data->rnd64, data->rnd64 + 32));\n+        memcpy(data->rnd64, buf, 64);\n+    }\n+}\n+\n+static void bench_ellswift_decode(void *arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    size_t len;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &out, data->rnd64) == 1);\n+        len = 33;\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->rnd64 + (i % 32), &len, &out, SECP256K1_EC_COMPRESSED));\n+    }\n+}\n+\n+static void bench_ellswift_xdh(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        int party = i & 1;\n+        CHECK(secp256k1_ellswift_xdh(data->ctx,\n+                                     data->rnd64 + (i % 33),\n+                                     data->rnd64,\n+                                     data->rnd64,\n+                                     data->rnd64 + ((i + 16) % 33),\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL) == 1);\n+    }\n+}\n+\n+void run_ellswift_bench(int iters, int argc, char **argv) {\n+    bench_ellswift_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with signing capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);",
      "path": "src/modules/ellswift/bench_impl.h",
      "position": null,
      "original_position": 96,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "54107db: code comments say this is a deprecated context flag. should it be `SECP256K1_CONTEXT_NONE` instead? ",
      "created_at": "2023-05-16T10:13:06Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1194938931",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1194938931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196167066",
      "pull_request_review_id": 1427731966,
      "id": 1196167066,
      "node_id": "PRRC_kwDOAP4Jqs5HTA-a",
      "diff_hunk": "@@ -0,0 +1,541 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 409,
      "original_position": 411,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "231bb73: when does `sizeof(secp256k1_ge_storage) != 64` happen inside `secp256k1_pubkey_load`? \r\n\r\n(normalisation happens when size=64 but not when size!=64. and we need normalisation here)",
      "created_at": "2023-05-17T08:52:58Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196167066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196167066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196688561",
      "pull_request_review_id": 1427731966,
      "id": 1196688561,
      "node_id": "PRRC_kwDOAP4Jqs5HVASx",
      "diff_hunk": "@@ -462,6 +462,7 @@ int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64\n \n     /* Compute (affine) public key */\n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 466,
      "original_position": 4,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "70d80aef2f456e1f5b92366f68af805a2acc4882",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "70d80ae: why don't variables in the `ellswift_xdh` code which interact with private key not use `secp256k1_declassify`? i don't understand the context for what kind of memory needs to be marked as not secret here.",
      "created_at": "2023-05-17T15:15:40Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196688561",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196688561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 466,
      "original_line": 466,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196695695",
      "pull_request_review_id": 1427731966,
      "id": 1196695695,
      "node_id": "PRRC_kwDOAP4Jqs5HVCCP",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 53,
      "original_position": 46,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1190085950,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh, the exactly 0, 4, or 8 t values were before the special cases were factored in! thanks, understood it now.",
      "created_at": "2023-05-17T15:21:09Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196695695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196695695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696052",
      "pull_request_review_id": 1427731966,
      "id": 1196696052,
      "node_id": "PRRC_kwDOAP4Jqs5HVCH0",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 147,
      "original_position": 147,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "b4191137773a7ca441c6c4e51448e3000d590bd5",
      "in_reply_to_id": 1190936480,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thank you for explaining, went through the implementation again and i understand why/where normalisation is done much better now! (have a related question which i've posted below)\r\n",
      "created_at": "2023-05-17T15:21:25Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196696052",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696284",
      "pull_request_review_id": 1427731966,
      "id": 1196696284,
      "node_id": "PRRC_kwDOAP4Jqs5HVCLc",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": 358,
      "original_position": 286,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1191896014,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh, makes sense! missed the part about both sides being dishonest before.",
      "created_at": "2023-05-17T15:21:36Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196696284",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 358,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696429",
      "pull_request_review_id": 1427731966,
      "id": 1196696429,
      "node_id": "PRRC_kwDOAP4Jqs5HVCNt",
      "diff_hunk": "@@ -0,0 +1,315 @@\n+/***********************************************************************\n+ * Copyright (c) 2022 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested against paper author's\n+ * code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char rnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(rnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? rnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        secp256k1_fe_set_b32(&share_x, share32);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char rnd32a[32], rnd32b[32], sec32a[32], sec32b[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64];\n+        unsigned char share32a[32], share32b[32];\n+        int ret;\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(rnd32a);\n+        secp256k1_testrand256_test(rnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, rnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, rnd32b);\n+        CHECK(ret);\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) == 0);\n+        /* Verify that the shared secret doesn't match if a secret key or remote pubkey changes. */\n+        secp256k1_testrand_flip(ell64a, 64);\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(share32a, share32b, 32) != 0);\n+        secp256k1_testrand_flip(sec32a, 32);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(!ret || secp256k1_memcmp_var(share32a, share32b, 32) != 0);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 290,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "f243b80b5b3cf5a73e63a20f516ea56938e2b43d",
      "in_reply_to_id": 1191896924,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "new tests look good!",
      "created_at": "2023-05-17T15:21:43Z",
      "updated_at": "2023-05-17T15:22:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196696429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 344,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696620",
      "pull_request_review_id": 1427731966,
      "id": 1196696620,
      "node_id": "PRRC_kwDOAP4Jqs5HVCQs",
      "diff_hunk": "@@ -495,6 +495,53 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\n     return 1;\n }\n \n+static int ellswift_xdh_hash_function_prefix(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    secp256k1_sha256 sha;\n+\n+    (void)data;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4c758e426eaf05032e2eead0055b5f2a55504bce",
      "in_reply_to_id": 1192102799,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "interesting! but data is being used 2 lines below?",
      "created_at": "2023-05-17T15:21:51Z",
      "updated_at": "2023-05-17T15:22:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196696620",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196696620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196742196",
      "pull_request_review_id": 1431057928,
      "id": 1196742196,
      "node_id": "PRRC_kwDOAP4Jqs5HVNY0",
      "diff_hunk": "@@ -208,6 +221,15 @@ int main(int argc, char** argv) {\n     }\n #endif\n \n+#ifndef ENABLE_MODULE_ELLSWIFT\n+    if (have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"ellswift_encode\") || have_flag(argc, argv, \"ellswift_decode\") ||\n+        have_flag(argc, argv, \"encode\") || have_flag(argc, argv, \"decode\")) {\n+        fprintf(stderr, \"./bench: ElligatorSwift smodule not enabled.\\n\");",
      "path": "src/bench.c",
      "position": null,
      "original_position": 43,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": 1194618340,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-17T15:57:31Z",
      "updated_at": "2023-05-17T16:18:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196742196",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196742196"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196742301",
      "pull_request_review_id": 1431057928,
      "id": 1196742301,
      "node_id": "PRRC_kwDOAP4Jqs5HVNad",
      "diff_hunk": "@@ -208,6 +221,15 @@ int main(int argc, char** argv) {\n     }\n #endif\n \n+#ifndef ENABLE_MODULE_ELLSWIFT\n+    if (have_flag(argc, argv, \"ellswift\") || have_flag(argc, argv, \"ellswift_encode\") || have_flag(argc, argv, \"ellswift_decode\") ||\n+        have_flag(argc, argv, \"encode\") || have_flag(argc, argv, \"decode\")) {",
      "path": "src/bench.c",
      "position": null,
      "original_position": 42,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": 1194621009,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-17T15:57:36Z",
      "updated_at": "2023-05-17T16:18:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196742301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196742301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196743329",
      "pull_request_review_id": 1431057928,
      "id": 1196743329,
      "node_id": "PRRC_kwDOAP4Jqs5HVNqh",
      "diff_hunk": "@@ -0,0 +1,107 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+#define SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point[256];\n+    unsigned char rnd64[64];\n+} bench_ellswift_data;\n+\n+static void bench_ellswift_setup(void *arg) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+    static const unsigned char init[64] = {\n+        0x78, 0x1f, 0xb7, 0xd4, 0x67, 0x7f, 0x08, 0x68,\n+        0xdb, 0xe3, 0x1d, 0x7f, 0x1b, 0xb0, 0xf6, 0x9e,\n+        0x0a, 0x64, 0xca, 0x32, 0x9e, 0xc6, 0x20, 0x79,\n+        0x03, 0xf3, 0xd0, 0x46, 0x7a, 0x0f, 0xd2, 0x21,\n+        0xb0, 0x2c, 0x46, 0xd8, 0xba, 0xca, 0x26, 0x4f,\n+        0x8f, 0x8c, 0xd4, 0xdd, 0x2d, 0x04, 0xbe, 0x30,\n+        0x48, 0x51, 0x1e, 0xd4, 0x16, 0xfd, 0x42, 0x85,\n+        0x62, 0xc9, 0x02, 0xf9, 0x89, 0x84, 0xff, 0xdc\n+    };\n+    memcpy(data->rnd64, init, 64);\n+    for (i = 0; i < 256; ++i) {\n+        int j;\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &data->point[i], data->rnd64));\n+        for (j = 0; j < 64; ++j) {\n+            data->rnd64[j] += 1;\n+        }\n+    }\n+    CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[255], init + 16));\n+}\n+\n+static void bench_ellswift_encode(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[i & 255], data->rnd64 + 16));\n+    }\n+}\n+\n+static void bench_ellswift_create(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char buf[64];\n+        CHECK(secp256k1_ellswift_create(data->ctx, buf, data->rnd64, data->rnd64 + 32));\n+        memcpy(data->rnd64, buf, 64);\n+    }\n+}\n+\n+static void bench_ellswift_decode(void *arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    size_t len;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &out, data->rnd64) == 1);\n+        len = 33;\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->rnd64 + (i % 32), &len, &out, SECP256K1_EC_COMPRESSED));\n+    }\n+}\n+\n+static void bench_ellswift_xdh(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        int party = i & 1;\n+        CHECK(secp256k1_ellswift_xdh(data->ctx,\n+                                     data->rnd64 + (i % 33),\n+                                     data->rnd64,\n+                                     data->rnd64,\n+                                     data->rnd64 + ((i + 16) % 33),\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL) == 1);\n+    }\n+}\n+\n+void run_ellswift_bench(int iters, int argc, char **argv) {\n+    bench_ellswift_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with signing capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);",
      "path": "src/modules/ellswift/bench_impl.h",
      "position": null,
      "original_position": 96,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "54107dbd907b37455b6fa717b9417dd0305750b2",
      "in_reply_to_id": 1194938931,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-17T15:58:24Z",
      "updated_at": "2023-05-17T16:18:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196743329",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196743329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196750494",
      "pull_request_review_id": 1431057928,
      "id": 1196750494,
      "node_id": "PRRC_kwDOAP4Jqs5HVPae",
      "diff_hunk": "@@ -0,0 +1,541 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 409,
      "original_position": 411,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": 1196167066,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting!\r\n\r\nI believe the practical answer to \"when does `sizeof(secp256k1_ge_storage) != 64` happen?\" is \"Never\". It's there because there is no guarantee about alignment requirements (or even sizes of types like `uint64_t`) in compilers, which may cause `secp256k1_ge_storage` to be bigger than just the sum of the data sizes. However, it's unlikely that we'll ever hit such a compiler.\r\n\r\nTo prepare for that, perhaps we want a normalize call inside `secp256k1_pubkey_load`, so that this cost is not born by the callers of that function (given that it's unlikely to matter for real environments).",
      "created_at": "2023-05-17T16:03:34Z",
      "updated_at": "2023-05-17T16:18:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196750494",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196750494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196774357",
      "pull_request_review_id": 1431057928,
      "id": 1196774357,
      "node_id": "PRRC_kwDOAP4Jqs5HVVPV",
      "diff_hunk": "@@ -462,6 +462,7 @@ int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64\n \n     /* Compute (affine) public key */\n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 466,
      "original_position": 4,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "70d80aef2f456e1f5b92366f68af805a2acc4882",
      "in_reply_to_id": 1196688561,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the ctime tests, any computation that depends on a marked-secret variable will get marked as secret as well (automatically). Passing marked-secret variable to functions that branch or make memory accesses dependent on them is illegal.\r\n\r\nSo in short, declassify needs to happen when we have a variable that is:\r\n* (1) Automatically marked a secret (because of a dependency on secret ones). If not, declassify has no effect.\r\n* (2) Isn't actually secret (in the sense that we're ok with leaking it to attackers). If not, declassify risks actually letting a relevant leak go undetected.\r\n* (3) Is used as input to a non-constant time function. If not, it's not leaked anyway, and it being classified or not doesn't matter.\r\n\r\nIn this code that is the case:\r\n* (1) The public key is computed as a function of the provided private key (which is secret) so it gets automatically marked as secret too.\r\n* (2) The public key is obviously not actually secret - it's a public key, and we'll likely even send it over the wire in a ellswift/ecdh use case.\r\n* (3) The ellswift encoding function is not constant time in the input X and Y coordinates, so we'd hit a violation if we didn't declassify.\r\n\r\nIn `secp256k1_ellswift_xdh`, lots of variables are secret:\r\n* The secret key (because duh)\r\n* The shared X coordinate `px` that comes out of `secp256k1_ecmult_const_xonly`, because it depends on the secret key, and it shouldn't be declassified because it's actually secret (attacker could figure out the shared secret based on it).\r\n* The shared secret that comes out of the hash function.\r\n\r\nIt works, because all the functions operating on these secret variables are actually constant time in them (and have to be, because they're designed to operate on secrets).",
      "created_at": "2023-05-17T16:17:27Z",
      "updated_at": "2023-05-17T16:18:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196774357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196774357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 466,
      "original_line": 466,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196936490",
      "pull_request_review_id": 1431356190,
      "id": 1196936490,
      "node_id": "PRRC_kwDOAP4Jqs5HV80q",
      "diff_hunk": "@@ -0,0 +1,541 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 409,
      "original_position": 411,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": 1196167066,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nice, fascinated by the level of details!",
      "created_at": "2023-05-17T18:53:24Z",
      "updated_at": "2023-05-17T18:53:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196936490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196936490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196936716",
      "pull_request_review_id": 1431356436,
      "id": 1196936716,
      "node_id": "PRRC_kwDOAP4Jqs5HV84M",
      "diff_hunk": "@@ -462,6 +462,7 @@ int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64\n \n     /* Compute (affine) public key */\n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);\n+    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 466,
      "original_position": 4,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "70d80aef2f456e1f5b92366f68af805a2acc4882",
      "in_reply_to_id": 1196688561,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thanks for the detailed explanation! understood when declassify needs to be used now.",
      "created_at": "2023-05-17T18:53:36Z",
      "updated_at": "2023-05-17T18:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196936716",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196936716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 466,
      "original_line": 466,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196939274",
      "pull_request_review_id": 1431359131,
      "id": 1196939274,
      "node_id": "PRRC_kwDOAP4Jqs5HV9gK",
      "diff_hunk": "@@ -495,6 +495,53 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\n     return 1;\n }\n \n+static int ellswift_xdh_hash_function_prefix(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    secp256k1_sha256 sha;\n+\n+    (void)data;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4c758e426eaf05032e2eead0055b5f2a55504bce",
      "in_reply_to_id": 1192102799,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "btw, there's another unresolved question in the reply thread here.",
      "created_at": "2023-05-17T18:55:29Z",
      "updated_at": "2023-05-17T18:55:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196939274",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196939274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196946131",
      "pull_request_review_id": 1431368943,
      "id": 1196946131,
      "node_id": "PRRC_kwDOAP4Jqs5HV_LT",
      "diff_hunk": "@@ -495,6 +495,53 @@ int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pu\n     return 1;\n }\n \n+static int ellswift_xdh_hash_function_prefix(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    secp256k1_sha256 sha;\n+\n+    (void)data;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4c758e426eaf05032e2eead0055b5f2a55504bce",
      "in_reply_to_id": 1192102799,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oops, I missed this.\r\n\r\nThe `(void)data;` line must have been a leftover from before the change to not sort the inputs in the prefix hashers. Fixed now.",
      "created_at": "2023-05-17T19:02:01Z",
      "updated_at": "2023-05-17T19:02:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1196946131",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1196946131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1199697908",
      "pull_request_review_id": 1435473854,
      "id": 1199697908,
      "node_id": "PRRC_kwDOAP4Jqs5Hge_0",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key\n+ *           auxrnd32:   (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrnd32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrnd32 contains 32 uniformly random bytes, though\n+ * it is optional (and does result in encodings that are indistinguishable from\n+ * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrnd32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      ell_a64:   pointer to the 64-byte encoded public key of party A\n+ *                      (will not be NULL)\n+ *           ell_b64:   pointer to the 64-byte encoded public key of party B\n+ *                      (will not be NULL)\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 150,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ad74020: ours64 needs to be updated too.",
      "created_at": "2023-05-21T05:17:31Z",
      "updated_at": "2023-06-15T19:12:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1199697908",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1199697908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1205675414",
      "pull_request_review_id": 1444140521,
      "id": 1205675414,
      "node_id": "PRRC_kwDOAP4Jqs5H3SWW",
      "diff_hunk": "@@ -71,6 +71,12 @@ if(SECP256K1_ENABLE_MODULE_EXTRAKEYS)\n   add_compile_definitions(ENABLE_MODULE_EXTRAKEYS=1)\n endif()\n \n+option(SECP256K1_ENABLE_MODULE_ELLSWIFT \"Enable ElligatorSwift module.\" ON)\n+if(SECP256K1_ENABLE_MODULE_ELLSWIFT)\n+  add_definitions(-DENABLE_MODULE_ELLSWIFT=1)",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 6,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "614509cbc6ce606e6719aede4832d5839367e3b5",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm assuming this is older than our `add_compile_definitions` switch-over. Mind updating it to match?",
      "created_at": "2023-05-25T15:20:00Z",
      "updated_at": "2023-05-25T15:24:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1205675414",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1205675414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1205678650",
      "pull_request_review_id": 1444140521,
      "id": 1205678650,
      "node_id": "PRRC_kwDOAP4Jqs5H3TI6",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "614509cbc6ce606e6719aede4832d5839367e3b5",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It was decided this this would not be experimental, but it's still described as such. I assume that's not intentional?\r\nEdit: It's also missing default help.",
      "created_at": "2023-05-25T15:22:28Z",
      "updated_at": "2023-05-25T15:25:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1205678650",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1205678650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1212078052",
      "pull_request_review_id": 1453810321,
      "id": 1212078052,
      "node_id": "PRRC_kwDOAP4Jqs5IPtfk",
      "diff_hunk": "@@ -71,6 +71,12 @@ if(SECP256K1_ENABLE_MODULE_EXTRAKEYS)\n   add_compile_definitions(ENABLE_MODULE_EXTRAKEYS=1)\n endif()\n \n+option(SECP256K1_ENABLE_MODULE_ELLSWIFT \"Enable ElligatorSwift module.\" ON)\n+if(SECP256K1_ENABLE_MODULE_ELLSWIFT)\n+  add_definitions(-DENABLE_MODULE_ELLSWIFT=1)",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 6,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "614509cbc6ce606e6719aede4832d5839367e3b5",
      "in_reply_to_id": 1205675414,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-31T17:42:50Z",
      "updated_at": "2023-05-31T17:42:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1212078052",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1212078052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1212078128",
      "pull_request_review_id": 1453810449,
      "id": 1212078128,
      "node_id": "PRRC_kwDOAP4Jqs5IPtgw",
      "diff_hunk": "@@ -185,6 +185,10 @@ AC_ARG_ENABLE(module_schnorrsig,\n     AS_HELP_STRING([--enable-module-schnorrsig],[enable schnorrsig module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_schnorrsig], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_ellswift,\n+    AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module (experimental)]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "614509cbc6ce606e6719aede4832d5839367e3b5",
      "in_reply_to_id": 1205678650,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-31T17:42:55Z",
      "updated_at": "2023-05-31T17:42:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1212078128",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1212078128"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229953023",
      "pull_request_review_id": 1479976878,
      "id": 1229953023,
      "node_id": "PRRC_kwDOAP4Jqs5JT5f_",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could we drop the `s == 0` check here? I assume it happens with negligible probability on honest inputs, and it's subsumed by the `is_square(q)` check below.\r\n\r\nIf no:\r\n * Do we want to add an `EXPECT` to the `s == 0` check? (Not sure if it changes much, but I saw you did the same above in the other function.)\r\n * Do we want to swap these checks for an earlier return?",
      "created_at": "2023-06-14T17:29:10Z",
      "updated_at": "2023-06-14T17:36:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1229953023",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229953023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229953290",
      "pull_request_review_id": 1479976878,
      "id": 1229953290,
      "node_id": "PRRC_kwDOAP4Jqs5JT5kK",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 281,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add `EXCEPT` here?",
      "created_at": "2023-06-14T17:29:25Z",
      "updated_at": "2023-06-14T17:36:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1229953290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229953290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229956516",
      "pull_request_review_id": 1479976878,
      "id": 1229956516,
      "node_id": "PRRC_kwDOAP4Jqs5JT6Wk",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 278,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you could drop the `is_square` check and simply use the return value of `fe_sqrt`. (Apparently, the entire return value of `fe_sqrt` is undocumented, this should be fixed.) \r\n\r\nIf you agree but feel that this belongs to a separate PR, I suggest opening an issue about the docs and mentioning this possible optimization,",
      "created_at": "2023-06-14T17:32:30Z",
      "updated_at": "2023-06-14T17:36:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1229956516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229956516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 276,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229959630",
      "pull_request_review_id": 1479976878,
      "id": 1229959630,
      "node_id": "PRRC_kwDOAP4Jqs5JT7HO",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 369,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This line can be dropped (or better, replaced by an assertion), as the last operation in `secp256k1_ellswift_xswiftec_inv_var` is a mul.",
      "created_at": "2023-06-14T17:35:34Z",
      "updated_at": "2023-06-14T17:36:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1229959630",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1229959630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230193927",
      "pull_request_review_id": 1480341720,
      "id": 1230193927,
      "node_id": "PRRC_kwDOAP4Jqs5JU0UH",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953023,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Could we drop the s == 0 check here? I assume it happens with negligible probability on honest inputs\r\n\r\nThat's a good question in general. The current code is written to deal perfectly with all possible inputs, because that's what matches my exhaustive analysis on small curves. You're right that this specific s=0 case can only happen with negligible probability on actual secp256k1 (it requires u=x, so with uniformly random u a probability of 1/2^256).\r\n\r\nOther than some cryptographically-unreachable code, this one does have a unit test exercising it though (an internal one; the API can't reach it).\r\n\r\n> and it's subsumed by the `is_square(q)` check below.\r\n\r\nThat's not correct. The tests fail if you comment it out.\r\n",
      "created_at": "2023-06-14T21:34:19Z",
      "updated_at": "2023-06-14T21:34:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230193927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230193927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230195193",
      "pull_request_review_id": 1480343553,
      "id": 1230195193,
      "node_id": "PRRC_kwDOAP4Jqs5JU0n5",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 278,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229956516,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could, but that's actually slower. The `is_square_var` should trigger for 50% of inputs, and an `is_square_var` takes less than half the time of an `sqrt`.",
      "created_at": "2023-06-14T21:36:14Z",
      "updated_at": "2023-06-14T21:36:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230195193",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230195193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 276,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230203219",
      "pull_request_review_id": 1480354640,
      "id": 1230203219,
      "node_id": "PRRC_kwDOAP4Jqs5JU2lT",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 369,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229959630,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The only caller, `secp256k1_ellswift_elligatorswift_var`, calls `secp256k1_fe_is_odd(t)` on this value, which requires full normalization (not just magnitude 1). The normalize call could be moved there, but it needs to be somewhere.",
      "created_at": "2023-06-14T21:45:57Z",
      "updated_at": "2023-06-14T21:45:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230203219",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230203219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230207735",
      "pull_request_review_id": 1480361042,
      "id": 1230207735,
      "node_id": "PRRC_kwDOAP4Jqs5JU3r3",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953023,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If no:\r\n>  * Do we want to add an `EXPECT` to the `s == 0` check? (Not sure if it changes much, but I saw you did the same above in the other function.)\r\n>  * Do we want to swap these checks for an earlier return?\r\n\r\nI've made these changes (and moved the `s==0` check even further, so that other more-likely-to-fail check go before it).",
      "created_at": "2023-06-14T21:52:18Z",
      "updated_at": "2023-06-14T21:52:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230207735",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230207735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230207798",
      "pull_request_review_id": 1480361136,
      "id": 1230207798,
      "node_id": "PRRC_kwDOAP4Jqs5JU3s2",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 281,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953290,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-14T21:52:24Z",
      "updated_at": "2023-06-14T21:52:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230207798",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230207798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230208129",
      "pull_request_review_id": 1480361616,
      "id": 1230208129,
      "node_id": "PRRC_kwDOAP4Jqs5JU3yB",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 369,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229959630,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, and moved the `normalize_var` call to `secp256k1_ellswift_elligatorswift_var`.",
      "created_at": "2023-06-14T21:52:56Z",
      "updated_at": "2023-06-14T21:52:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230208129",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230208129"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230730973",
      "pull_request_review_id": 1481134452,
      "id": 1230730973,
      "node_id": "PRRC_kwDOAP4Jqs5JW3bd",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953023,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> > and it's subsumed by the `is_square(q)` check below.\r\n> \r\n> That's not correct. The tests fail if you comment it out.\r\n\r\nOh.  When I wrote this, I had assumed, for a moment, that we abort if q is a square. But we abort if it's not a square.",
      "created_at": "2023-06-15T09:32:07Z",
      "updated_at": "2023-06-15T09:32:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230730973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230730973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230739200",
      "pull_request_review_id": 1481147284,
      "id": 1230739200,
      "node_id": "PRRC_kwDOAP4Jqs5JW5cA",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 369,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229959630,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep, I missed that we need full normalization.",
      "created_at": "2023-06-15T09:38:49Z",
      "updated_at": "2023-06-15T09:38:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230739200",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230739200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230755159",
      "pull_request_review_id": 1481171337,
      "id": 1230755159,
      "node_id": "PRRC_kwDOAP4Jqs5JW9VX",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 278,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229956516,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Makes sense. See https://github.com/bitcoin-core/secp256k1/pull/1347 for the missing docs.",
      "created_at": "2023-06-15T09:51:58Z",
      "updated_at": "2023-06-15T09:51:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230755159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230755159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 276,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230839782",
      "pull_request_review_id": 1481301716,
      "id": 1230839782,
      "node_id": "PRRC_kwDOAP4Jqs5JXR_m",
      "diff_hunk": "@@ -0,0 +1,541 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 409,
      "original_position": 411,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": 1196167066,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should keep track of this.\r\n\r\n> To prepare for that, perhaps we want a normalize call inside `secp256k1_pubkey_load`, so that this cost is not born by the callers of that function (given that it's unlikely to matter for real environments).\r\n\r\nYes, we want this. There's even a bug currently in `secp256k1_pubkey_load` because the ARG_CHECK at the end of the function assumes normalization. @stratospher Interested in opening a PR to add the normalization call to `secp256k1_pubkey_load`?",
      "created_at": "2023-06-15T11:02:58Z",
      "updated_at": "2023-06-15T11:02:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230839782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230839782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230842783",
      "pull_request_review_id": 1481306768,
      "id": 1230842783,
      "node_id": "PRRC_kwDOAP4Jqs5JXSuf",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 418,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you think it's better to call `secp256k1_eckey_pubkey_serialize` here? Or even the API facing `secp256k1_ec_pubkey_serialize`, which also takes care of loading the pubkey?",
      "created_at": "2023-06-15T11:05:57Z",
      "updated_at": "2023-06-15T11:05:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230842783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230842783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 417,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 418,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230850464",
      "pull_request_review_id": 1481319678,
      "id": 1230850464,
      "node_id": "PRRC_kwDOAP4Jqs5JXUmg",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);\n+        secp256k1_sha256_write(&hash, p64, sizeof(p64));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 427,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    /* Only reached in case the provided pubkey is invalid. */\r\n    memset(ell64, 0, 64);\r\n```",
      "created_at": "2023-06-15T11:12:55Z",
      "updated_at": "2023-06-15T11:12:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230850464",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230850464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230908460",
      "pull_request_review_id": 1481409228,
      "id": 1230908460,
      "node_id": "PRRC_kwDOAP4Jqs5JXiws",
      "diff_hunk": "@@ -0,0 +1,189 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it (including compatibility with BIP324).\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(prefix64 || ell_a64 || ell_b64 || x32), where prefix64 is the 64-byte\n+ *  array pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_prefix;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(ell_a64 || ell_b64 || x32), where H_tag is the\n+ *  BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\". Equivalent\n+ *  to secp256k1_ellswift_xdh_hash_function_prefix with prefix64 set to\n+ *  SHA256(\"bip324_ellswift_xonly_ecdh\")||SHA256(\"bip324_ellswift_xonly_ecdh\").\n+ *  The data argument is ignored. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 85,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Returns: 1 always.\r\n```\r\n(There are no invalid pubkeys in terms of the API, similar to  https://github.com/bitcoin-core/secp256k1/pull/1341 )",
      "created_at": "2023-06-15T12:05:12Z",
      "updated_at": "2023-06-15T12:05:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230908460",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230908460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230916747",
      "pull_request_review_id": 1481422142,
      "id": 1230916747,
      "node_id": "PRRC_kwDOAP4Jqs5JXkyL",
      "diff_hunk": "@@ -0,0 +1,189 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it (including compatibility with BIP324).\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(prefix64 || ell_a64 || ell_b64 || x32), where prefix64 is the 64-byte\n+ *  array pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_prefix;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(ell_a64 || ell_b64 || x32), where H_tag is the\n+ *  BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\". Equivalent\n+ *  to secp256k1_ellswift_xdh_hash_function_prefix with prefix64 set to\n+ *  SHA256(\"bip324_ellswift_xonly_ecdh\")||SHA256(\"bip324_ellswift_xonly_ecdh\").\n+ *  The data argument is ignored. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(",
      "path": "include/secp256k1_ellswift.h",
      "position": 105,
      "original_position": 101,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we want to add a warning to make sure we can swap the RNG?  Suggestion:\r\n\r\n\"It is not guaranteed that the computed ell64 is stable across versions of the library, even if all arguments to this function including rnd32 are the same.\"\r\n\r\nIf yes, this should be added to secp256k1_ellswift_create too\r\n",
      "created_at": "2023-06-15T12:12:41Z",
      "updated_at": "2023-06-15T12:18:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230916747",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230916747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 105,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230918653",
      "pull_request_review_id": 1481422142,
      "id": 1230918653,
      "node_id": "PRRC_kwDOAP4Jqs5JXlP9",
      "diff_hunk": "@@ -0,0 +1,189 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it (including compatibility with BIP324).\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(prefix64 || ell_a64 || ell_b64 || x32), where prefix64 is the 64-byte\n+ *  array pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_prefix;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(ell_a64 || ell_b64 || x32), where H_tag is the\n+ *  BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\". Equivalent\n+ *  to secp256k1_ellswift_xdh_hash_function_prefix with prefix64 set to\n+ *  SHA256(\"bip324_ellswift_xonly_ecdh\")||SHA256(\"bip324_ellswift_xonly_ecdh\").\n+ *  The data argument is ignored. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.",
      "path": "include/secp256k1_ellswift.h",
      "position": 130,
      "original_position": 126,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(Not this PR, I see this is copied from the other docs:) Ha, we should change this, \"try again\" is terrible advice. Hey, if your RNG outputs 32 zeroes, then don't worry, just call it in a loop. :D \r\n",
      "created_at": "2023-06-15T12:14:29Z",
      "updated_at": "2023-06-15T12:18:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230918653",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230918653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 130,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230922845",
      "pull_request_review_id": 1481422142,
      "id": 1230922845,
      "node_id": "PRRC_kwDOAP4Jqs5JXmRd",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953023,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I've made these changes (and moved the `s==0` check even further, so that other more-likely-to-fail check go before it).\r\n\r\nPerhaps update the pseudocode in the comment (and in the md?) accordingly.",
      "created_at": "2023-06-15T12:18:12Z",
      "updated_at": "2023-06-15T12:20:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1230922845",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230922845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1231432950",
      "pull_request_review_id": 1435473854,
      "id": 1231432950,
      "node_id": "PRRC_kwDOAP4Jqs5JZiz2",
      "diff_hunk": "@@ -0,0 +1,541 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if ((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch)) {\n+            secp256k1_fe_normalize_var(t);\n+            break;\n+        }\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {",
      "path": "src/modules/ellswift/main_impl.h",
      "position": 409,
      "original_position": 411,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": 1196167066,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes! opened [1349](https://github.com/bitcoin-core/secp256k1/pull/1349).",
      "created_at": "2023-06-15T19:07:23Z",
      "updated_at": "2023-06-15T19:12:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1231432950",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1231432950"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233062720",
      "pull_request_review_id": 1484825007,
      "id": 1233062720,
      "node_id": "PRRC_kwDOAP4Jqs5JfwtA",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);\n+        secp256k1_sha256_write(&hash, p64, sizeof(p64));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 427,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230850464,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-17T13:29:31Z",
      "updated_at": "2023-06-17T13:30:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233062720",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233062720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233062788",
      "pull_request_review_id": 1484825007,
      "id": 1233062788,
      "node_id": "PRRC_kwDOAP4Jqs5JfwuE",
      "diff_hunk": "@@ -0,0 +1,189 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it (including compatibility with BIP324).\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(prefix64 || ell_a64 || ell_b64 || x32), where prefix64 is the 64-byte\n+ *  array pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_prefix;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(ell_a64 || ell_b64 || x32), where H_tag is the\n+ *  BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\". Equivalent\n+ *  to secp256k1_ellswift_xdh_hash_function_prefix with prefix64 set to\n+ *  SHA256(\"bip324_ellswift_xonly_ecdh\")||SHA256(\"bip324_ellswift_xonly_ecdh\").\n+ *  The data argument is ignored. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(",
      "path": "include/secp256k1_ellswift.h",
      "position": 105,
      "original_position": 101,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230916747,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-17T13:30:03Z",
      "updated_at": "2023-06-17T13:30:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233062788",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233062788"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 105,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063308",
      "pull_request_review_id": 1484825870,
      "id": 1233063308,
      "node_id": "PRRC_kwDOAP4Jqs5Jfw2M",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key\n+ *           auxrnd32:   (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrnd32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrnd32 contains 32 uniformly random bytes, though\n+ * it is optional (and does result in encodings that are indistinguishable from\n+ * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrnd32, if provided).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed\n+ *           0: secret was invalid or hashfp returned 0\n+ *  Args:    ctx:       pointer to a context object.\n+ *  Out:     output:    pointer to an array to be filled by hashfp.\n+ *  In:      ell_a64:   pointer to the 64-byte encoded public key of party A\n+ *                      (will not be NULL)\n+ *           ell_b64:   pointer to the 64-byte encoded public key of party B\n+ *                      (will not be NULL)\n+ *           seckey32:  a pointer to the 32-byte secret key corresponding to\n+ *                      ours64 (the correspondence is not checked)",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 150,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "231bb7324ffc4097276874b216dda39e7e01befa",
      "in_reply_to_id": 1199697908,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-17T13:31:43Z",
      "updated_at": "2023-06-17T13:31:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233063308",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063350",
      "pull_request_review_id": 1484825906,
      "id": 1233063350,
      "node_id": "PRRC_kwDOAP4Jqs5Jfw22",
      "diff_hunk": "@@ -0,0 +1,189 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it (including compatibility with BIP324).\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function which uses\n+ *  SHA256(prefix64 || ell_a64 || ell_b64 || x32), where prefix64 is the 64-byte\n+ *  array pointed to by data. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_prefix;\n+\n+/** An implementation of an secp256k1_ellswift_xdh_hash_function compatible with\n+ *  BIP324. It returns H_tag(ell_a64 || ell_b64 || x32), where H_tag is the\n+ *  BIP340 tagged hash function with tag \"bip324_ellswift_xonly_ecdh\". Equivalent\n+ *  to secp256k1_ellswift_xdh_hash_function_prefix with prefix64 set to\n+ *  SHA256(\"bip324_ellswift_xonly_ecdh\")||SHA256(\"bip324_ellswift_xonly_ecdh\").\n+ *  The data argument is ignored. */\n+SECP256K1_API_VAR const secp256k1_ellswift_xdh_hash_function secp256k1_ellswift_xdh_hash_function_bip324;\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 85,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230908460,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-17T13:31:57Z",
      "updated_at": "2023-06-17T13:31:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233063350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063590",
      "pull_request_review_id": 1484826093,
      "id": 1233063590,
      "node_id": "PRRC_kwDOAP4Jqs5Jfw6m",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 418,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230842783,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good call. I've made it call `secp256k1_eckey_pubkey_serialize`. Using the API facing one would not be convenient, as we do need the `secp256k1_ge` form further down in the function.",
      "created_at": "2023-06-17T13:33:12Z",
      "updated_at": "2023-06-17T13:33:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233063590",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 417,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 418,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063629",
      "pull_request_review_id": 1484826127,
      "id": 1233063629,
      "node_id": "PRRC_kwDOAP4Jqs5Jfw7N",
      "diff_hunk": "@@ -0,0 +1,588 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s=0, fail. */\n+        if (secp256k1_fe_normalizes_to_zero_var(&s)) return 0;\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 263,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "fe26466f040a6ddc242cea54037c2c4cd85a0bc9",
      "in_reply_to_id": 1229953023,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-17T13:33:23Z",
      "updated_at": "2023-06-17T13:33:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233063629",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233063629"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233066008",
      "pull_request_review_id": 1484828359,
      "id": 1233066008,
      "node_id": "PRRC_kwDOAP4Jqs5JfxgY",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+struct ellswift_xdh_test {\n+    unsigned char priv_ours[32];\n+    unsigned char ellswift_ours[64];\n+    unsigned char ellswift_theirs[64];\n+    int initiating;\n+    unsigned char shared_secret[32];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested decoding against paper\n+ * authors' code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested decoding against the paper\n+ * authors' code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/* Set of expected ellswift_xdh BIP324 shared secrets, given private key, encodings, initiating,\n+ * taken from the BIP324 test vectors. Created using an independent implementation, and tested\n+ * against the paper authors' decoding code. */\n+static const struct ellswift_xdh_test ellswift_xdh_tests_bip324[] = {\n+    {{0x61, 0x06, 0x2e, 0xa5, 0x07, 0x1d, 0x80, 0x0b, 0xbf, 0xd5, 0x9e, 0x2e, 0x8b, 0x53, 0xd4, 0x7d, 0x19, 0x4b, 0x09, 0x5a, 0xe5, 0xa4, 0xdf, 0x04, 0x93, 0x6b, 0x49, 0x77, 0x2e, 0xf0, 0xd4, 0xd7}, {0xec, 0x0a, 0xdf, 0xf2, 0x57, 0xbb, 0xfe, 0x50, 0x0c, 0x18, 0x8c, 0x80, 0xb4, 0xfd, 0xd6, 0x40, 0xf6, 0xb4, 0x5a, 0x48, 0x2b, 0xbc, 0x15, 0xfc, 0x7c, 0xef, 0x59, 0x31, 0xde, 0xff, 0x0a, 0xa1, 0x86, 0xf6, 0xeb, 0x9b, 0xba, 0x7b, 0x85, 0xdc, 0x4d, 0xcc, 0x28, 0xb2, 0x87, 0x22, 0xde, 0x1e, 0x3d, 0x91, 0x08, 0xb9, 0x85, 0xe2, 0x96, 0x70, 0x45, 0x66, 0x8f, 0x66, 0x09, 0x8e, 0x47, 0x5b}, {0xa4, 0xa9, 0x4d, 0xfc, 0xe6, 0x9b, 0x4a, 0x2a, 0x0a, 0x09, 0x93, 0x13, 0xd1, 0x0f, 0x9f, 0x7e, 0x7d, 0x64, 0x9d, 0x60, 0x50, 0x1c, 0x9e, 0x1d, 0x27, 0x4c, 0x30, 0x0e, 0x0d, 0x89, 0xaa, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xaf, 0x88, 0xd5}, 1, {0xc6, 0x99, 0x2a, 0x11, 0x7f, 0x5e, 0xdb, 0xea, 0x70, 0xc3, 0xf5, 0x11, 0xd3, 0x2d, 0x26, 0xb9, 0x79, 0x8b, 0xe4, 0xb8, 0x1a, 0x62, 0xea, 0xee, 0x1a, 0x5a, 0xca, 0xa8, 0x45, 0x9a, 0x35, 0x92}},\n+    {{0x1f, 0x9c, 0x58, 0x1b, 0x35, 0x23, 0x18, 0x38, 0xf0, 0xf1, 0x7c, 0xf0, 0xc9, 0x79, 0x83, 0x5b, 0xac, 0xcb, 0x7f, 0x3a, 0xbb, 0xbb, 0x96, 0xff, 0xcc, 0x31, 0x8a, 0xb7, 0x1e, 0x6e, 0x12, 0x6f}, {0xa1, 0x85, 0x5e, 0x10, 0xe9, 0x4e, 0x00, 0xba, 0xa2, 0x30, 0x41, 0xd9, 0x16, 0xe2, 0x59, 0xf7, 0x04, 0x4e, 0x49, 0x1d, 0xa6, 0x17, 0x12, 0x69, 0x69, 0x47, 0x63, 0xf0, 0x18, 0xc7, 0xe6, 0x36, 0x93, 0xd2, 0x95, 0x75, 0xdc, 0xb4, 0x64, 0xac, 0x81, 0x6b, 0xaa, 0x1b, 0xe3, 0x53, 0xba, 0x12, 0xe3, 0x87, 0x6c, 0xba, 0x76, 0x28, 0xbd, 0x0b, 0xd8, 0xe7, 0x55, 0xe7, 0x21, 0xeb, 0x01, 0x40}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, {0xa0, 0x13, 0x8f, 0x56, 0x4f, 0x74, 0xd0, 0xad, 0x70, 0xbc, 0x33, 0x7d, 0xac, 0xc9, 0xd0, 0xbf, 0x1d, 0x23, 0x49, 0x36, 0x4c, 0xaf, 0x11, 0x88, 0xa1, 0xe6, 0xe8, 0xdd, 0xb3, 0xb7, 0xb1, 0x84}},\n+    {{0x02, 0x86, 0xc4, 0x1c, 0xd3, 0x09, 0x13, 0xdb, 0x0f, 0xdf, 0xf7, 0xa6, 0x4e, 0xbd, 0xa5, 0xc8, 0xe3, 0xe7, 0xce, 0xf1, 0x0f, 0x2a, 0xeb, 0xc0, 0x0a, 0x76, 0x50, 0x44, 0x3c, 0xf4, 0xc6, 0x0d}, {0xd1, 0xee, 0x8a, 0x93, 0xa0, 0x11, 0x30, 0xcb, 0xf2, 0x99, 0x24, 0x9a, 0x25, 0x8f, 0x94, 0xfe, 0xb5, 0xf4, 0x69, 0xe7, 0xd0, 0xf2, 0xf2, 0x8f, 0x69, 0xee, 0x5e, 0x9a, 0xa8, 0xf9, 0xb5, 0x4a, 0x60, 0xf2, 0xc3, 0xff, 0x2d, 0x02, 0x36, 0x34, 0xec, 0x7f, 0x41, 0x27, 0xa9, 0x6c, 0xc1, 0x16, 0x62, 0xe4, 0x02, 0x89, 0x4c, 0xf1, 0xf6, 0x94, 0xfb, 0x9a, 0x7e, 0xaa, 0x5f, 0x1d, 0x92, 0x44}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x22, 0xd5, 0xe4, 0x41, 0x52, 0x4d, 0x57, 0x1a, 0x52, 0xb3, 0xde, 0xf1, 0x26, 0x18, 0x9d, 0x3f, 0x41, 0x68, 0x90, 0xa9, 0x9d, 0x4d, 0xa6, 0xed, 0xe2, 0xb0, 0xcd, 0xe1, 0x76, 0x0c, 0xe2, 0xc3, 0xf9, 0x84, 0x57, 0xae}, 1, {0x25, 0x0b, 0x93, 0x57, 0x0d, 0x41, 0x11, 0x49, 0x10, 0x5a, 0xb8, 0xcb, 0x0b, 0xc5, 0x07, 0x99, 0x14, 0x90, 0x63, 0x06, 0x36, 0x8c, 0x23, 0xe9, 0xd7, 0x7c, 0x2a, 0x33, 0x26, 0x5b, 0x99, 0x4c}},\n+    {{0x6c, 0x77, 0x43, 0x2d, 0x1f, 0xda, 0x31, 0xe9, 0xf9, 0x42, 0xf8, 0xaf, 0x44, 0x60, 0x7e, 0x10, 0xf3, 0xad, 0x38, 0xa6, 0x5f, 0x8a, 0x4b, 0xdd, 0xae, 0x82, 0x3e, 0x5e, 0xff, 0x90, 0xdc, 0x38}, {0xd2, 0x68, 0x50, 0x70, 0xc1, 0xe6, 0x37, 0x6e, 0x63, 0x3e, 0x82, 0x52, 0x96, 0x63, 0x4f, 0xd4, 0x61, 0xfa, 0x9e, 0x5b, 0xdf, 0x21, 0x09, 0xbc, 0xeb, 0xd7, 0x35, 0xe5, 0xa9, 0x1f, 0x3e, 0x58, 0x7c, 0x5c, 0xb7, 0x82, 0xab, 0xb7, 0x97, 0xfb, 0xf6, 0xbb, 0x50, 0x74, 0xfd, 0x15, 0x42, 0xa4, 0x74, 0xf2, 0xa4, 0x5b, 0x67, 0x37, 0x63, 0xec, 0x2d, 0xb7, 0xfb, 0x99, 0xb7, 0x37, 0xbb, 0xb9}, {0x56, 0xbd, 0x0c, 0x06, 0xf1, 0x03, 0x52, 0xc3, 0xa1, 0xa9, 0xf4, 0xb4, 0xc9, 0x2f, 0x6f, 0xa2, 0xb2, 0x6d, 0xf1, 0x24, 0xb5, 0x78, 0x78, 0x35, 0x3c, 0x1f, 0xc6, 0x91, 0xc5, 0x1a, 0xbe, 0xa7, 0x7c, 0x88, 0x17, 0xda, 0xee, 0xb9, 0xfa, 0x54, 0x6b, 0x77, 0xc8, 0xda, 0xf7, 0x9d, 0x89, 0xb2, 0x2b, 0x0e, 0x1b, 0x87, 0x57, 0x4e, 0xce, 0x42, 0x37, 0x1f, 0x00, 0x23, 0x7a, 0xa9, 0xd8, 0x3a}, 0, {0x19, 0x18, 0xb7, 0x41, 0xef, 0x5f, 0x9d, 0x1d, 0x76, 0x70, 0xb0, 0x50, 0xc1, 0x52, 0xb4, 0xa4, 0xea, 0xd2, 0xc3, 0x1b, 0xe9, 0xae, 0xcb, 0x06, 0x81, 0xc0, 0xcd, 0x43, 0x24, 0x15, 0x08, 0x53}},\n+    {{0xa6, 0xec, 0x25, 0x12, 0x7c, 0xa1, 0xaa, 0x4c, 0xf1, 0x6b, 0x20, 0x08, 0x4b, 0xa1, 0xe6, 0x51, 0x6b, 0xaa, 0xe4, 0xd3, 0x24, 0x22, 0x28, 0x8e, 0x9b, 0x36, 0xd8, 0xbd, 0xdd, 0x2d, 0xe3, 0x5a}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x3d, 0x7e, 0xcc, 0xa5, 0x3e, 0x33, 0xe1, 0x85, 0xa8, 0xb9, 0xbe, 0x4e, 0x76, 0x99, 0xa9, 0x7c, 0x6f, 0xf4, 0xc7, 0x95, 0x52, 0x2e, 0x59, 0x18, 0xab, 0x7c, 0xd6, 0xb6, 0x88, 0x4f, 0x67, 0xe6, 0x83, 0xf3, 0xdc}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x73, 0x0b, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 1, {0xdd, 0x21, 0x0a, 0xa6, 0x62, 0x9f, 0x20, 0xbb, 0x32, 0x8e, 0x5d, 0x89, 0xda, 0xa6, 0xeb, 0x2a, 0xc3, 0xd1, 0xc6, 0x58, 0xa7, 0x25, 0x53, 0x6f, 0xf1, 0x54, 0xf3, 0x1b, 0x53, 0x6c, 0x23, 0xb2}},\n+    {{0x0a, 0xf9, 0x52, 0x65, 0x9e, 0xd7, 0x6f, 0x80, 0xf5, 0x85, 0x96, 0x6b, 0x95, 0xab, 0x6e, 0x6f, 0xd6, 0x86, 0x54, 0x67, 0x28, 0x27, 0x87, 0x86, 0x84, 0xc8, 0xb5, 0x47, 0xb1, 0xb9, 0x4f, 0x5a}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x10, 0x17, 0xfd, 0x92, 0xfd, 0x31, 0x63, 0x7c, 0x26, 0xc9, 0x06, 0xb4, 0x20, 0x92, 0xe1, 0x1c, 0xc0, 0xd3, 0xaf, 0xae, 0x8d, 0x90, 0x19, 0xd2, 0x57, 0x8a, 0xf2, 0x27, 0x35, 0xce, 0x7b, 0xc4, 0x69, 0xc7, 0x2d}, {0x96, 0x52, 0xd7, 0x8b, 0xae, 0xfc, 0x02, 0x8c, 0xd3, 0x7a, 0x6a, 0x92, 0x62, 0x5b, 0x8b, 0x8f, 0x85, 0xfd, 0xe1, 0xe4, 0xc9, 0x44, 0xad, 0x3f, 0x20, 0xe1, 0x98, 0xbe, 0xf8, 0xc0, 0x2f, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0xe9, 0x18, 0x70}, 0, {0x35, 0x68, 0xf2, 0xae, 0xa2, 0xe1, 0x4e, 0xf4, 0xee, 0x4a, 0x3c, 0x2a, 0x8b, 0x8d, 0x31, 0xbc, 0x5e, 0x31, 0x87, 0xba, 0x86, 0xdb, 0x10, 0x73, 0x9b, 0x4f, 0xf8, 0xec, 0x92, 0xff, 0x66, 0x55}},\n+    {{0xf9, 0x0e, 0x08, 0x0c, 0x64, 0xb0, 0x58, 0x24, 0xc5, 0xa2, 0x4b, 0x25, 0x01, 0xd5, 0xae, 0xaf, 0x08, 0xaf, 0x38, 0x72, 0xee, 0x86, 0x0a, 0xa8, 0x0b, 0xdc, 0xd4, 0x30, 0xf7, 0xb6, 0x34, 0x94}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x11, 0x51, 0x73, 0x76, 0x5d, 0xc2, 0x02, 0xcf, 0x02, 0x9a, 0xd3, 0xf1, 0x54, 0x79, 0x73, 0x5d, 0x57, 0x69, 0x7a, 0xf1, 0x2b, 0x01, 0x31, 0xdd, 0x21, 0x43, 0x0d, 0x57, 0x72, 0xe4, 0xef, 0x11, 0x47, 0x4d, 0x58, 0xb9}, {0x12, 0xa5, 0x0f, 0x3f, 0xaf, 0xea, 0x7c, 0x1e, 0xea, 0xda, 0x4c, 0xf8, 0xd3, 0x37, 0x77, 0x70, 0x4b, 0x77, 0x36, 0x14, 0x53, 0xaf, 0xc8, 0x3b, 0xda, 0x91, 0xee, 0xf3, 0x49, 0xae, 0x04, 0x4d, 0x20, 0x12, 0x6c, 0x62, 0x00, 0x54, 0x7e, 0xa5, 0xa6, 0x91, 0x17, 0x76, 0xc0, 0x5d, 0xee, 0x2a, 0x7f, 0x1a, 0x9b, 0xa7, 0xdf, 0xba, 0xbb, 0xbd, 0x27, 0x3c, 0x3e, 0xf2, 0x9e, 0xf4, 0x6e, 0x46}, 1, {0xe2, 0x54, 0x61, 0xfb, 0x0e, 0x4c, 0x16, 0x2e, 0x18, 0x12, 0x3e, 0xcd, 0xe8, 0x83, 0x42, 0xd5, 0x4d, 0x44, 0x96, 0x31, 0xe9, 0xb7, 0x5a, 0x26, 0x6f, 0xd9, 0x26, 0x0c, 0x2b, 0xb2, 0xf4, 0x1d}},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xdh_tests_bip324) / sizeof(ellswift_xdh_tests_bip324[0]); ++i) {\n+        const struct ellswift_xdh_test *test = &ellswift_xdh_tests_bip324[i];\n+        unsigned char shared_secret[32];\n+        int ret;\n+        int party = !test->initiating;\n+        const unsigned char* ell_a64 = party ? test->ellswift_theirs : test->ellswift_ours;\n+        const unsigned char* ell_b64 = party ? test->ellswift_ours   : test->ellswift_theirs;\n+        ret = secp256k1_ellswift_xdh(CTX, shared_secret,\n+                                     ell_a64, ell_b64,\n+                                     test->priv_ours,\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(shared_secret, test->shared_secret, 32) == 0);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char auxrnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(auxrnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? auxrnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell64 arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        (void)secp256k1_fe_set_b32_limit(&share_x, share32); /* no overflow is possible */\n+        secp256k1_fe_verify(&share_x);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char auxrnd32a[32], auxrnd32b[32], auxrnd32a_bad[32];\n+        unsigned char sec32a[32], sec32b[32], sec32a_bad[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64], ell64a_bad[64];\n+        unsigned char share32a[32], share32b[32], share32_bad[32];\n+        unsigned char prefix64[64];\n+        secp256k1_ellswift_xdh_hash_function hash_function;\n+        void* data;\n+        int ret;\n+\n+        /* Pick hasher to use. */\n+        if ((i % 3) == 0) {\n+            hash_function = ellswift_xdh_hash_x32;\n+            data = NULL;\n+        } else if ((i % 3) == 1) {\n+            hash_function = secp256k1_ellswift_xdh_hash_function_bip324;\n+            data = NULL;\n+        } else {\n+            hash_function = secp256k1_ellswift_xdh_hash_function_prefix;\n+            secp256k1_testrand256_test(prefix64);\n+            secp256k1_testrand256_test(prefix64 + 32);\n+            data = prefix64;\n+        }\n+\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(auxrnd32a);\n+        secp256k1_testrand256_test(auxrnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, auxrnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, auxrnd32b);\n+        CHECK(ret);\n+\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, hash_function, data);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, hash_function, data);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 338,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4860ab0e2246b56469a564d980a1316c5e36fb47",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shouldn't the first share be called `share32b` and the second `share32a`? Without this a few of the tests below don't make sense.\r\n\r\nIf we change the names of the shares as suggested, we would also need to replace `share32b` with `share32a` in\r\n```\r\n        ret = secp256k1_ellswift_xdh(CTX, share32_bad, ell64a, ell64b, sec32a_bad, 0, hash_function, data);\r\n        CHECK(!ret || secp256k1_memcmp_var(share32_bad, share32b, 32) != 0);\r\n ```\r\n",
      "created_at": "2023-06-17T13:54:24Z",
      "updated_at": "2023-06-17T13:54:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233066008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233066008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 336,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233099736",
      "pull_request_review_id": 1484863832,
      "id": 1233099736,
      "node_id": "PRRC_kwDOAP4Jqs5Jf5vY",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+#define SECP256K1_MODULE_ELLSWIFT_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+struct ellswift_xswiftec_inv_test {\n+    int enc_bitmap;\n+    secp256k1_fe u;\n+    secp256k1_fe x;\n+    secp256k1_fe encs[8];\n+};\n+\n+struct ellswift_decode_test {\n+    unsigned char enc[64];\n+    secp256k1_fe x;\n+    int odd_y;\n+};\n+\n+struct ellswift_xdh_test {\n+    unsigned char priv_ours[32];\n+    unsigned char ellswift_ours[64];\n+    unsigned char ellswift_theirs[64];\n+    int initiating;\n+    unsigned char shared_secret[32];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested decoding against paper\n+ * authors' code. */\n+static const struct ellswift_xswiftec_inv_test ellswift_xswiftec_inv_tests[] = {\n+    {0xcc, SECP256K1_FE_CONST(0x05ff6bda, 0xd900fc32, 0x61bc7fe3, 0x4e2fb0f5, 0x69f06e09, 0x1ae437d3, 0xa52e9da0, 0xcbfb9590), SECP256K1_FE_CONST(0x80cdf637, 0x74ec7022, 0xc89a5a85, 0x58e373a2, 0x79170285, 0xe0ab2741, 0x2dbce510, 0xbdfe23fc), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x45654798, 0xece071ba, 0x79286d04, 0xf7f3eb1c, 0x3f1d17dd, 0x883610f2, 0xad2efd82, 0xa287466b), SECP256K1_FE_CONST(0x0aeaa886, 0xf6b76c71, 0x58452418, 0xcbf5033a, 0xdc5747e9, 0xe9b5d3b2, 0x303db969, 0x36528557), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xba9ab867, 0x131f8e45, 0x86d792fb, 0x080c14e3, 0xc0e2e822, 0x77c9ef0d, 0x52d1027c, 0x5d78b5c4), SECP256K1_FE_CONST(0xf5155779, 0x0948938e, 0xa7badbe7, 0x340afcc5, 0x23a8b816, 0x164a2c4d, 0xcfc24695, 0xc9ad76d8)}},\n+    {0x33, SECP256K1_FE_CONST(0x1737a85f, 0x4c8d146c, 0xec96e3ff, 0xdca76d99, 0x03dcf3bd, 0x53061868, 0xd478c78c, 0x63c2aa9e), SECP256K1_FE_CONST(0x39e48dd1, 0x50d2f429, 0xbe088dfd, 0x5b61882e, 0x7e840748, 0x3702ae9a, 0x5ab35927, 0xb15f85ea), {SECP256K1_FE_CONST(0x1be8cc0b, 0x04be0c68, 0x1d0c6a68, 0xf733f82c, 0x6c896e0c, 0x8a262fcd, 0x392918e3, 0x03a7abf4), SECP256K1_FE_CONST(0x605b5814, 0xbf9b8cb0, 0x66667c9e, 0x5480d22d, 0xc5b6c92f, 0x14b4af3e, 0xe0a9eb83, 0xb03685e3), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xe41733f4, 0xfb41f397, 0xe2f39597, 0x08cc07d3, 0x937691f3, 0x75d9d032, 0xc6d6e71b, 0xfc58503b), SECP256K1_FE_CONST(0x9fa4a7eb, 0x4064734f, 0x99998361, 0xab7f2dd2, 0x3a4936d0, 0xeb4b50c1, 0x1f56147b, 0x4fc9764c), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x1aaa1cce, 0xbf9c7241, 0x91033df3, 0x66b36f69, 0x1c4d902c, 0x228033ff, 0x4516d122, 0xb2564f68), SECP256K1_FE_CONST(0xc7554125, 0x9d3ba98f, 0x207eaa30, 0xc69634d1, 0x87d0b6da, 0x594e719e, 0x420f4898, 0x638fc5b0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2323a1d0, 0x79b0fd72, 0xfc8bb62e, 0xc34230a8, 0x15cb0596, 0xc2bfac99, 0x8bd6b842, 0x60f5dc26), SECP256K1_FE_CONST(0x239342df, 0xb675500a, 0x34a19631, 0x0b8d87d5, 0x4f49dcac, 0x9da50c17, 0x43ceab41, 0xa7b249ff), {SECP256K1_FE_CONST(0xf63580b8, 0xaa49c484, 0x6de56e39, 0xe1b3e73f, 0x171e881e, 0xba8c66f6, 0x14e67e5c, 0x975dfc07), SECP256K1_FE_CONST(0xb6307b33, 0x2e699f1c, 0xf77841d9, 0x0af25365, 0x404deb7f, 0xed5edb30, 0x90db49e6, 0x42a156b6), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x09ca7f47, 0x55b63b7b, 0x921a91c6, 0x1e4c18c0, 0xe8e177e1, 0x45739909, 0xeb1981a2, 0x68a20028), SECP256K1_FE_CONST(0x49cf84cc, 0xd19660e3, 0x0887be26, 0xf50dac9a, 0xbfb21480, 0x12a124cf, 0x6f24b618, 0xbd5ea579), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x2dc90e64, 0x0cb646ae, 0x9164c0b5, 0xa9ef0169, 0xfebe34dc, 0x4437d6e4, 0x6acb0e27, 0xe219d1e8), SECP256K1_FE_CONST(0xd236f19b, 0xf349b951, 0x6e9b3f4a, 0x5610fe96, 0x0141cb23, 0xbbc8291b, 0x9534f1d7, 0x1de62a47), {SECP256K1_FE_CONST(0xe69df7d9, 0xc026c366, 0x00ebdf58, 0x80726758, 0x47c0c431, 0xc8eb7306, 0x82533e96, 0x4b6252c9), SECP256K1_FE_CONST(0x4f18bbdf, 0x7c2d6c5f, 0x818c1880, 0x2fa35cd0, 0x69eaa79f, 0xff74e4fc, 0x837c80d9, 0x3fece2f8), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x19620826, 0x3fd93c99, 0xff1420a7, 0x7f8d98a7, 0xb83f3bce, 0x37148cf9, 0x7dacc168, 0xb49da966), SECP256K1_FE_CONST(0xb0e74420, 0x83d293a0, 0x7e73e77f, 0xd05ca32f, 0x96155860, 0x008b1b03, 0x7c837f25, 0xc0131937), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0x3edd7b39, 0x80e2f2f3, 0x4d1409a2, 0x07069f88, 0x1fda5f96, 0xf08027ac, 0x4465b63d, 0xc278d672), SECP256K1_FE_CONST(0x053a98de, 0x4a27b196, 0x1155822b, 0x3a3121f0, 0x3b2a1445, 0x8bd80eb4, 0xa560c4c7, 0xa85c149c), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb3dae4b7, 0xdcf858e4, 0xc6968057, 0xcef2b156, 0x46543152, 0x6538199c, 0xf52dc1b2, 0xd62fda30), SECP256K1_FE_CONST(0x4aa77dd5, 0x5d6b6d3c, 0xfa10cc9d, 0x0fe42f79, 0x232e4575, 0x661049ae, 0x36779c1d, 0x0c666d88), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x4c251b48, 0x2307a71b, 0x39697fa8, 0x310d4ea9, 0xb9abcead, 0x9ac7e663, 0x0ad23e4c, 0x29d021ff), SECP256K1_FE_CONST(0xb558822a, 0xa29492c3, 0x05ef3362, 0xf01bd086, 0xdcd1ba8a, 0x99efb651, 0xc98863e1, 0xf3998ea7)}},\n+    {0x00, SECP256K1_FE_CONST(0x4295737e, 0xfcb1da6f, 0xb1d96b9c, 0xa7dcd1e3, 0x20024b37, 0xa736c494, 0x8b625981, 0x73069f70), SECP256K1_FE_CONST(0xfa7ffe4f, 0x25f88362, 0x831c087a, 0xfe2e8a9b, 0x0713e2ca, 0xc1ddca6a, 0x383205a2, 0x66f14307), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0x587c1a0c, 0xee91939e, 0x7f784d23, 0xb963004a, 0x3bf44f5d, 0x4e32a008, 0x1995ba20, 0xb0fca59e), SECP256K1_FE_CONST(0x2ea98853, 0x0715e8d1, 0x0363907f, 0xf2512452, 0x4d471ba2, 0x454d5ce3, 0xbe3f0419, 0x4dfd3a3c), {SECP256K1_FE_CONST(0xcfd5a094, 0xaa0b9b88, 0x91b76c6a, 0xb9438f66, 0xaa1c095a, 0x65f9f701, 0x35e81712, 0x92245e74), SECP256K1_FE_CONST(0xa89057d7, 0xc6563f0d, 0x6efa19ae, 0x84412b8a, 0x7b47e791, 0xa191ecdf, 0xdf2af84f, 0xd97bc339), SECP256K1_FE_CONST(0x475d0ae9, 0xef46920d, 0xf07b3411, 0x7be5a081, 0x7de1023e, 0x3cc32689, 0xe9be145b, 0x406b0aef), SECP256K1_FE_CONST(0xa0759178, 0xad802324, 0x54f827ef, 0x05ea3e72, 0xad8d7541, 0x8e6d4cc1, 0xcd4f5306, 0xc5e7c453), SECP256K1_FE_CONST(0x302a5f6b, 0x55f46477, 0x6e489395, 0x46bc7099, 0x55e3f6a5, 0x9a0608fe, 0xca17e8ec, 0x6ddb9dbb), SECP256K1_FE_CONST(0x576fa828, 0x39a9c0f2, 0x9105e651, 0x7bbed475, 0x84b8186e, 0x5e6e1320, 0x20d507af, 0x268438f6), SECP256K1_FE_CONST(0xb8a2f516, 0x10b96df2, 0x0f84cbee, 0x841a5f7e, 0x821efdc1, 0xc33cd976, 0x1641eba3, 0xbf94f140), SECP256K1_FE_CONST(0x5f8a6e87, 0x527fdcdb, 0xab07d810, 0xfa15c18d, 0x52728abe, 0x7192b33e, 0x32b0acf8, 0x3a1837dc)}},\n+    {0xcc, SECP256K1_FE_CONST(0x5fa88b33, 0x65a635cb, 0xbcee003c, 0xce9ef51d, 0xd1a310de, 0x277e441a, 0xbccdb7be, 0x1e4ba249), SECP256K1_FE_CONST(0x79461ff6, 0x2bfcbcac, 0x4249ba84, 0xdd040f2c, 0xec3c63f7, 0x25204dc7, 0xf464c16b, 0xf0ff3170), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x6bb700e1, 0xf4d7e236, 0xe8d193ff, 0x4a76c1b3, 0xbcd4e2b2, 0x5acac3d5, 0x1c8dac65, 0x3fe909a0), SECP256K1_FE_CONST(0xf4c73410, 0x633da7f6, 0x3a4f1d55, 0xaec6dd32, 0xc4c6d89e, 0xe74075ed, 0xb5515ed9, 0x0da9e683), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x9448ff1e, 0x0b281dc9, 0x172e6c00, 0xb5893e4c, 0x432b1d4d, 0xa5353c2a, 0xe3725399, 0xc016f28f), SECP256K1_FE_CONST(0x0b38cbef, 0x9cc25809, 0xc5b0e2aa, 0x513922cd, 0x3b392761, 0x18bf8a12, 0x4aaea125, 0xf25615ac)}},\n+    {0xcc, SECP256K1_FE_CONST(0x6fb31c75, 0x31f03130, 0xb42b155b, 0x952779ef, 0xbb46087d, 0xd9807d24, 0x1a48eac6, 0x3c3d96d6), SECP256K1_FE_CONST(0x56f81be7, 0x53e8d4ae, 0x4940ea6f, 0x46f6ec9f, 0xda66a6f9, 0x6cc95f50, 0x6cb2b574, 0x90e94260), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x59059774, 0x795bdb7a, 0x837fbe11, 0x40a5fa59, 0x984f48af, 0x8df95d57, 0xdd6d1c05, 0x437dcec1), SECP256K1_FE_CONST(0x22a644db, 0x79376ad4, 0xe7b3a009, 0xe58b3f13, 0x137c54fd, 0xf911122c, 0xc93667c4, 0x7077d784), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xa6fa688b, 0x86a42485, 0x7c8041ee, 0xbf5a05a6, 0x67b0b750, 0x7206a2a8, 0x2292e3f9, 0xbc822d6e), SECP256K1_FE_CONST(0xdd59bb24, 0x86c8952b, 0x184c5ff6, 0x1a74c0ec, 0xec83ab02, 0x06eeedd3, 0x36c9983a, 0x8f8824ab)}},\n+    {0x00, SECP256K1_FE_CONST(0x704cd226, 0xe71cb682, 0x6a590e80, 0xdac90f2d, 0x2f5830f0, 0xfdf135a3, 0xeae3965b, 0xff25ff12), SECP256K1_FE_CONST(0x138e0afa, 0x68936ee6, 0x70bd2b8d, 0xb53aedbb, 0x7bea2a85, 0x97388b24, 0xd0518edd, 0x22ad66ec), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x725e9147, 0x92cb8c89, 0x49e7e116, 0x8b7cdd8a, 0x8094c91c, 0x6ec2202c, 0xcd53a6a1, 0x8771edeb), SECP256K1_FE_CONST(0x8da16eb8, 0x6d347376, 0xb6181ee9, 0x74832275, 0x7f6b36e3, 0x913ddfd3, 0x32ac595d, 0x788e0e44), {SECP256K1_FE_CONST(0xdd357786, 0xb9f68733, 0x30391aa5, 0x62580965, 0x4e43116e, 0x82a5a5d8, 0x2ffd1d66, 0x24101fc4), SECP256K1_FE_CONST(0xa0b7efca, 0x01814594, 0xc59c9aae, 0x8e497001, 0x86ca5d95, 0xe88bcc80, 0x399044d9, 0xc2d8613d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x22ca8879, 0x460978cc, 0xcfc6e55a, 0x9da7f69a, 0xb1bcee91, 0x7d5a5a27, 0xd002e298, 0xdbefdc6b), SECP256K1_FE_CONST(0x5f481035, 0xfe7eba6b, 0x3a636551, 0x71b68ffe, 0x7935a26a, 0x1774337f, 0xc66fbb25, 0x3d279af2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x78fe6b71, 0x7f2ea4a3, 0x2708d79c, 0x151bf503, 0xa5312a18, 0xc0963437, 0xe865cc6e, 0xd3f6ae97), SECP256K1_FE_CONST(0x8701948e, 0x80d15b5c, 0xd8f72863, 0xeae40afc, 0x5aced5e7, 0x3f69cbc8, 0x179a3390, 0x2c094d98), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x44, SECP256K1_FE_CONST(0x7c37bb9c, 0x5061dc07, 0x413f11ac, 0xd5a34006, 0xe64c5c45, 0x7fdb9a43, 0x8f217255, 0xa961f50d), SECP256K1_FE_CONST(0x5c1a76b4, 0x4568eb59, 0xd6789a74, 0x42d9ed7c, 0xdc6226b7, 0x752b4ff8, 0xeaf8e1a9, 0x5736e507), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb94d30cd, 0x7dbff60b, 0x64620c17, 0xca0fafaa, 0x40b3d1f5, 0x2d077a60, 0xa2e0cafd, 0x145086c2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x46b2cf32, 0x824009f4, 0x9b9df3e8, 0x35f05055, 0xbf4c2e0a, 0xd2f8859f, 0x5d1f3501, 0xebaf756d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0x82388888, 0x967f82a6, 0xb444438a, 0x7d44838e, 0x13c0d478, 0xb9ca060d, 0xa95a41fb, 0x94303de6), SECP256K1_FE_CONST(0x29e96541, 0x70628fec, 0x8b497289, 0x8b113cf9, 0x8807f460, 0x9274f4f3, 0x140d0674, 0x157c90a0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0x91298f57, 0x70af7a27, 0xf0a47188, 0xd24c3b7b, 0xf98ab299, 0x0d84b0b8, 0x98507e3c, 0x561d6472), SECP256K1_FE_CONST(0x144f4ccb, 0xd9a74698, 0xa88cbf6f, 0xd00ad886, 0xd339d29e, 0xa19448f2, 0xc572cac0, 0xa07d5562), {SECP256K1_FE_CONST(0xe6a0ffa3, 0x807f09da, 0xdbe71e0f, 0x4be4725f, 0x2832e76c, 0xad8dc1d9, 0x43ce8393, 0x75eff248), SECP256K1_FE_CONST(0x837b8e68, 0xd4917544, 0x764ad090, 0x3cb11f86, 0x15d2823c, 0xefbb06d8, 0x9049dbab, 0xc69befda), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x195f005c, 0x7f80f625, 0x2418e1f0, 0xb41b8da0, 0xd7cd1893, 0x52723e26, 0xbc317c6b, 0x8a1009e7), SECP256K1_FE_CONST(0x7c847197, 0x2b6e8abb, 0x89b52f6f, 0xc34ee079, 0xea2d7dc3, 0x1044f927, 0x6fb62453, 0x39640c55), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xb682f3d0, 0x3bbb5dee, 0x4f54b5eb, 0xfba931b4, 0xf52f6a19, 0x1e5c2f48, 0x3c73c66e, 0x9ace97e1), SECP256K1_FE_CONST(0x904717bf, 0x0bc0cb78, 0x73fcdc38, 0xaa97f19e, 0x3a626309, 0x72acff92, 0xb24cc6dd, 0xa197cb96), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x77, SECP256K1_FE_CONST(0xc17ec69e, 0x665f0fb0, 0xdbab48d9, 0xc2f94d12, 0xec8a9d7e, 0xacb58084, 0x83309180, 0x1eb0b80b), SECP256K1_FE_CONST(0x147756e6, 0x6d96e31c, 0x426d3cc8, 0x5ed0c4cf, 0xbef6341d, 0xd8b28558, 0x5aa574ea, 0x0204b55e), {SECP256K1_FE_CONST(0x6f4aea43, 0x1a0043bd, 0xd03134d6, 0xd9159119, 0xce034b88, 0xc32e50e8, 0xe36c4ee4, 0x5eac7ae9), SECP256K1_FE_CONST(0xfd5be16d, 0x4ffa2690, 0x126c67c3, 0xef7cb9d2, 0x9b74d397, 0xc78b06b3, 0x605fda34, 0xdc9696a6), SECP256K1_FE_CONST(0x5e9c6079, 0x2a2f000e, 0x45c6250f, 0x296f875e, 0x174efc0e, 0x9703e628, 0x706103a9, 0xdd2d82c7), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x90b515bc, 0xe5ffbc42, 0x2fcecb29, 0x26ea6ee6, 0x31fcb477, 0x3cd1af17, 0x1c93b11a, 0xa1538146), SECP256K1_FE_CONST(0x02a41e92, 0xb005d96f, 0xed93983c, 0x1083462d, 0x648b2c68, 0x3874f94c, 0x9fa025ca, 0x23696589), SECP256K1_FE_CONST(0xa1639f86, 0xd5d0fff1, 0xba39daf0, 0xd69078a1, 0xe8b103f1, 0x68fc19d7, 0x8f9efc55, 0x22d27968), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xc25172fc, 0x3f29b6fc, 0x4a1155b8, 0x57523315, 0x5486b274, 0x64b74b8b, 0x260b499a, 0x3f53cb14), SECP256K1_FE_CONST(0x1ea9cbdb, 0x35cf6e03, 0x29aa31b0, 0xbb0a702a, 0x65123ed0, 0x08655a93, 0xb7dcd528, 0x0e52e1ab), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x7422edc7, 0x843136af, 0x0053bb88, 0x54448a82, 0x99994f9d, 0xdcefd3a9, 0xa92d4546, 0x2c59298a), SECP256K1_FE_CONST(0x78c7774a, 0x266f8b97, 0xea23d05d, 0x064f033c, 0x77319f92, 0x3f6b78bc, 0xe4e20bf0, 0x5fa5398d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x8bdd1238, 0x7bcec950, 0xffac4477, 0xabbb757d, 0x6666b062, 0x23102c56, 0x56d2bab8, 0xd3a6d2a5), SECP256K1_FE_CONST(0x873888b5, 0xd9907468, 0x15dc2fa2, 0xf9b0fcc3, 0x88ce606d, 0xc0948743, 0x1b1df40e, 0xa05ac2a2)}},\n+    {0x00, SECP256K1_FE_CONST(0xcab6626f, 0x832a4b12, 0x80ba7add, 0x2fc5322f, 0xf011caed, 0xedf7ff4d, 0xb6735d50, 0x26dc0367), SECP256K1_FE_CONST(0x2b2bef08, 0x52c6f7c9, 0x5d72ac99, 0xa23802b8, 0x75029cd5, 0x73b248d1, 0xf1b3fc80, 0x33788eb6), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x33, SECP256K1_FE_CONST(0xd8621b4f, 0xfc85b9ed, 0x56e99d8d, 0xd1dd24ae, 0xdcecb147, 0x63b861a1, 0x7112dc77, 0x1a104fd2), SECP256K1_FE_CONST(0x812cabe9, 0x72a22aa6, 0x7c7da0c9, 0x4d8a9362, 0x96eb9949, 0xd70c37cb, 0x2b248757, 0x4cb3ce58), {SECP256K1_FE_CONST(0xfbc5febc, 0x6fdbc9ae, 0x3eb88a93, 0xb982196e, 0x8b6275a6, 0xd5a73c17, 0x387e000c, 0x711bd0e3), SECP256K1_FE_CONST(0x8724c96b, 0xd4e5527f, 0x2dd195a5, 0x1c468d2d, 0x211ba2fa, 0xc7cbe0b4, 0xb3434253, 0x409fb42d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x043a0143, 0x90243651, 0xc147756c, 0x467de691, 0x749d8a59, 0x2a58c3e8, 0xc781fff2, 0x8ee42b4c), SECP256K1_FE_CONST(0x78db3694, 0x2b1aad80, 0xd22e6a5a, 0xe3b972d2, 0xdee45d05, 0x38341f4b, 0x4cbcbdab, 0xbf604802), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xda463164, 0xc6f4bf71, 0x29ee5f0e, 0xc00f65a6, 0x75a8adf1, 0xbd931b39, 0xb64806af, 0xdcda9a22), SECP256K1_FE_CONST(0x25b9ce9b, 0x390b408e, 0xd611a0f1, 0x3ff09a59, 0x8a57520e, 0x426ce4c6, 0x49b7f94f, 0x2325620d), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xdafc971e, 0x4a3a7b6d, 0xcfb42a08, 0xd9692d82, 0xad9e7838, 0x523fcbda, 0x1d4827e1, 0x4481ae2d), SECP256K1_FE_CONST(0x250368e1, 0xb5c58492, 0x304bd5f7, 0x2696d27d, 0x526187c7, 0xadc03425, 0xe2b7d81d, 0xbb7e4e02), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x370c28f1, 0xbe665efa, 0xcde6aa43, 0x6bf86fe2, 0x1e6e314c, 0x1e53dd04, 0x0e6c73a4, 0x6b4c8c49), SECP256K1_FE_CONST(0xcd8acee9, 0x8ffe5653, 0x1a84d7eb, 0x3e48fa40, 0x34206ce8, 0x25ace907, 0xd0edf0ea, 0xeb5e9ca2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xc8f3d70e, 0x4199a105, 0x321955bc, 0x9407901d, 0xe191ceb3, 0xe1ac22fb, 0xf1938c5a, 0x94b36fe6), SECP256K1_FE_CONST(0x32753116, 0x7001a9ac, 0xe57b2814, 0xc1b705bf, 0xcbdf9317, 0xda5316f8, 0x2f120f14, 0x14a15f8d)}},\n+    {0x44, SECP256K1_FE_CONST(0xe0294c8b, 0xc1a36b41, 0x66ee92bf, 0xa70a5c34, 0x976fa982, 0x9405efea, 0x8f9cd54d, 0xcb29b99e), SECP256K1_FE_CONST(0xae9690d1, 0x3b8d20a0, 0xfbbf37be, 0xd8474f67, 0xa04e142f, 0x56efd787, 0x70a76b35, 0x9165d8a1), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xdcd45d93, 0x5613916a, 0xf167b029, 0x058ba3a7, 0x00d37150, 0xb9df3472, 0x8cb05412, 0xc16d4182), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x232ba26c, 0xa9ec6e95, 0x0e984fd6, 0xfa745c58, 0xff2c8eaf, 0x4620cb8d, 0x734fabec, 0x3e92baad), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0x00, SECP256K1_FE_CONST(0xe148441c, 0xd7b92b8b, 0x0e4fa3bd, 0x68712cfd, 0x0d709ad1, 0x98cace61, 0x1493c10e, 0x97f5394e), SECP256K1_FE_CONST(0x164a6397, 0x94d74c53, 0xafc4d329, 0x4e79cdb3, 0xcd25f99f, 0x6df45c00, 0x0f758aba, 0x54d699c0), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe4b00ec9, 0x7aadcca9, 0x7644d3b0, 0xc8a931b1, 0x4ce7bcf7, 0xbc877954, 0x6d6e35aa, 0x5937381c), SECP256K1_FE_CONST(0x94e9588d, 0x41647b3f, 0xcc772dc8, 0xd83c67ce, 0x3be00353, 0x8517c834, 0x103d2cd4, 0x9d62ef4d), {SECP256K1_FE_CONST(0xc88d25f4, 0x1407376b, 0xb2c03a7f, 0xffeb3ec7, 0x811cc434, 0x91a0c3aa, 0xc0378cdc, 0x78357bee), SECP256K1_FE_CONST(0x51c02636, 0xce00c234, 0x5ecd89ad, 0xb6089fe4, 0xd5e18ac9, 0x24e3145e, 0x6669501c, 0xd37a00d4), SECP256K1_FE_CONST(0x205b3512, 0xdb40521c, 0xb200952e, 0x67b46f67, 0xe09e7839, 0xe0de4400, 0x4138329e, 0xbd9138c5), SECP256K1_FE_CONST(0x58aab390, 0xab6fb55c, 0x1d1b8089, 0x7a207ce9, 0x4a78fa5b, 0x4aa61a33, 0x398bcae9, 0xadb20d3e), SECP256K1_FE_CONST(0x3772da0b, 0xebf8c894, 0x4d3fc580, 0x0014c138, 0x7ee33bcb, 0x6e5f3c55, 0x3fc87322, 0x87ca8041), SECP256K1_FE_CONST(0xae3fd9c9, 0x31ff3dcb, 0xa1327652, 0x49f7601b, 0x2a1e7536, 0xdb1ceba1, 0x9996afe2, 0x2c85fb5b), SECP256K1_FE_CONST(0xdfa4caed, 0x24bfade3, 0x4dff6ad1, 0x984b9098, 0x1f6187c6, 0x1f21bbff, 0xbec7cd60, 0x426ec36a), SECP256K1_FE_CONST(0xa7554c6f, 0x54904aa3, 0xe2e47f76, 0x85df8316, 0xb58705a4, 0xb559e5cc, 0xc6743515, 0x524deef1)}},\n+    {0x00, SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), SECP256K1_FE_CONST(0xe5bbb9ef, 0x360d0a50, 0x1618f006, 0x7d36dceb, 0x75f5be9a, 0x620232aa, 0x9fd5139d, 0x0863fde5), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xff, SECP256K1_FE_CONST(0xe6bcb5c3, 0xd63467d4, 0x90bfa54f, 0xbbc6092a, 0x7248c25e, 0x11b248dc, 0x2964a6e1, 0x5edb1457), SECP256K1_FE_CONST(0x19434a3c, 0x29cb982b, 0x6f405ab0, 0x4439f6d5, 0x8db73da1, 0xee4db723, 0xd69b591d, 0xa124e7d8), {SECP256K1_FE_CONST(0x67119877, 0x832ab8f4, 0x59a82165, 0x6d8261f5, 0x44a553b8, 0x9ae4f25c, 0x52a97134, 0xb70f3426), SECP256K1_FE_CONST(0xffee02f5, 0xe649c07f, 0x0560eff1, 0x867ec7b3, 0x2d0e595e, 0x9b1c0ea6, 0xe2a4fc70, 0xc97cd71f), SECP256K1_FE_CONST(0xb5e0c189, 0xeb5b4bac, 0xd025b744, 0x4d74178b, 0xe8d5246c, 0xfa4a9a20, 0x7964a057, 0xee969992), SECP256K1_FE_CONST(0x5746e459, 0x1bf7f4c3, 0x044609ea, 0x372e9086, 0x03975d27, 0x9fdef834, 0x9f0b08d3, 0x2f07619d), SECP256K1_FE_CONST(0x98ee6788, 0x7cd5470b, 0xa657de9a, 0x927d9e0a, 0xbb5aac47, 0x651b0da3, 0xad568eca, 0x48f0c809), SECP256K1_FE_CONST(0x0011fd0a, 0x19b63f80, 0xfa9f100e, 0x7981384c, 0xd2f1a6a1, 0x64e3f159, 0x1d5b038e, 0x36832510), SECP256K1_FE_CONST(0x4a1f3e76, 0x14a4b453, 0x2fda48bb, 0xb28be874, 0x172adb93, 0x05b565df, 0x869b5fa7, 0x1169629d), SECP256K1_FE_CONST(0xa8b91ba6, 0xe4080b3c, 0xfbb9f615, 0xc8d16f79, 0xfc68a2d8, 0x602107cb, 0x60f4f72b, 0xd0f89a92)}},\n+    {0x33, SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), SECP256K1_FE_CONST(0xf28fba64, 0xaf766845, 0xeb2f4302, 0x456e2b9f, 0x8d80affe, 0x57e7aae4, 0x2738d7cd, 0xdb1c2ce6), {SECP256K1_FE_CONST(0x4f867ad8, 0xbb3d8404, 0x09d26b67, 0x307e6210, 0x0153273f, 0x72fa4b74, 0x84becfa1, 0x4ebe7408), SECP256K1_FE_CONST(0x5bbc4f59, 0xe452cc5f, 0x22a99144, 0xb10ce898, 0x9a89a995, 0xec3cea1c, 0x91ae10e8, 0xf721bb5d), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xb0798527, 0x44c27bfb, 0xf62d9498, 0xcf819def, 0xfeacd8c0, 0x8d05b48b, 0x7b41305d, 0xb1418827), SECP256K1_FE_CONST(0xa443b0a6, 0x1bad33a0, 0xdd566ebb, 0x4ef31767, 0x6576566a, 0x13c315e3, 0x6e51ef16, 0x08de40d2), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+    {0xcc, SECP256K1_FE_CONST(0xf455605b, 0xc85bf48e, 0x3a908c31, 0x023faf98, 0x381504c6, 0xc6d3aeb9, 0xede55f8d, 0xd528924d), SECP256K1_FE_CONST(0xd31fbcd5, 0xcdb798f6, 0xc00db669, 0x2f8fe896, 0x7fa9c79d, 0xd10958f4, 0xa194f013, 0x74905e99), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0x0c00c571, 0x5b56fe63, 0x2d814ad8, 0xa77f8e66, 0x628ea47a, 0x6116834f, 0x8c1218f3, 0xa03cbd50), SECP256K1_FE_CONST(0xdf88e44f, 0xac84fa52, 0xdf4d59f4, 0x8819f18f, 0x6a8cd415, 0x1d162afa, 0xf773166f, 0x57c7ff46), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0xf3ff3a8e, 0xa4a9019c, 0xd27eb527, 0x58807199, 0x9d715b85, 0x9ee97cb0, 0x73ede70b, 0x5fc33edf), SECP256K1_FE_CONST(0x20771bb0, 0x537b05ad, 0x20b2a60b, 0x77e60e70, 0x95732bea, 0xe2e9d505, 0x088ce98f, 0xa837fce9)}},\n+    {0xff, SECP256K1_FE_CONST(0xf58cd4d9, 0x830bad32, 0x2699035e, 0x8246007d, 0x4be27e19, 0xb6f53621, 0x317b4f30, 0x9b3daa9d), SECP256K1_FE_CONST(0x78ec2b3d, 0xc0948de5, 0x60148bbc, 0x7c6dc963, 0x3ad5df70, 0xa5a5750c, 0xbed72180, 0x4f082a3b), {SECP256K1_FE_CONST(0x6c4c580b, 0x76c75940, 0x43569f9d, 0xae16dc28, 0x01c16a1f, 0xbe128608, 0x81b75f8e, 0xf929bce5), SECP256K1_FE_CONST(0x94231355, 0xe7385c5f, 0x25ca436a, 0xa6419147, 0x1aea4393, 0xd6e86ab7, 0xa35fe2af, 0xacaefd0d), SECP256K1_FE_CONST(0xdff2a195, 0x1ada6db5, 0x74df8340, 0x48149da3, 0x397a75b8, 0x29abf58c, 0x7e69db1b, 0x41ac0989), SECP256K1_FE_CONST(0xa52b66d3, 0xc9070355, 0x48028bf8, 0x04711bf4, 0x22aba95f, 0x1a666fc8, 0x6f4648e0, 0x5f29caae), SECP256K1_FE_CONST(0x93b3a7f4, 0x8938a6bf, 0xbca96062, 0x51e923d7, 0xfe3e95e0, 0x41ed79f7, 0x7e48a070, 0x06d63f4a), SECP256K1_FE_CONST(0x6bdcecaa, 0x18c7a3a0, 0xda35bc95, 0x59be6eb8, 0xe515bc6c, 0x29179548, 0x5ca01d4f, 0x5350ff22), SECP256K1_FE_CONST(0x200d5e6a, 0xe525924a, 0x8b207cbf, 0xb7eb625c, 0xc6858a47, 0xd6540a73, 0x819624e3, 0xbe53f2a6), SECP256K1_FE_CONST(0x5ad4992c, 0x36f8fcaa, 0xb7fd7407, 0xfb8ee40b, 0xdd5456a0, 0xe5999037, 0x90b9b71e, 0xa0d63181)}},\n+    {0x00, SECP256K1_FE_CONST(0xfd7d912a, 0x40f182a3, 0x588800d6, 0x9ebfb504, 0x8766da20, 0x6fd7ebc8, 0xd2436c81, 0xcbef6421), SECP256K1_FE_CONST(0x8d37c862, 0x054debe7, 0x31694536, 0xff46b273, 0xec122b35, 0xa9bf1445, 0xac3c4ff9, 0xf262c952), {SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0), SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0)}},\n+};\n+\n+/* Set of (encoding, xcoord) test vectors, selected to maximize branch coverage, part of the BIP324\n+ * test vectors. Created using an independent implementation, and tested decoding against the paper\n+ * authors' code. */\n+static const struct ellswift_decode_test ellswift_decode_tests[] = {\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb, 0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 1},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c, 0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x532167c1, 0x1200b08c, 0x0e84a354, 0xe74dcc40, 0xf8b25f4f, 0xe686e308, 0x69526366, 0x278a0688), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x74e880b3, 0xffd18fe3, 0xcddf7902, 0x522551dd, 0xf97fa4a3, 0x5a3cfda8, 0x197f9470, 0x81a57b8f), 0},\n+    {{0x0f, 0xfd, 0xe9, 0xca, 0x81, 0xd7, 0x51, 0xe9, 0xcd, 0xaf, 0xfc, 0x1a, 0x50, 0x77, 0x92, 0x45, 0x32, 0x0b, 0x28, 0x99, 0x6d, 0xba, 0xf3, 0x2f, 0x82, 0x2f, 0x20, 0x11, 0x7c, 0x22, 0xfb, 0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x377b643f, 0xce2271f6, 0x4e5c8101, 0x566107c1, 0xbe498074, 0x50917838, 0x04f65478, 0x1ac9217c), 1},\n+    {{0x12, 0x36, 0x58, 0x44, 0x4f, 0x32, 0xbe, 0x8f, 0x02, 0xea, 0x20, 0x34, 0xaf, 0xa7, 0xef, 0x4b, 0xbe, 0x8a, 0xdc, 0x91, 0x8c, 0xeb, 0x49, 0xb1, 0x27, 0x73, 0xb6, 0x25, 0xf4, 0x90, 0xb3, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xc5, 0xfe, 0x11}, SECP256K1_FE_CONST(0xed16d65c, 0xf3a9538f, 0xcb2c139f, 0x1ecbc143, 0xee148271, 0x20cbc265, 0x9e667256, 0x800b8142), 0},\n+    {{0x14, 0x6f, 0x92, 0x46, 0x4d, 0x15, 0xd3, 0x6e, 0x35, 0x38, 0x2b, 0xd3, 0xca, 0x5b, 0x0f, 0x97, 0x6c, 0x95, 0xcb, 0x08, 0xac, 0xdc, 0xf2, 0xd5, 0xb3, 0x57, 0x06, 0x17, 0x99, 0x08, 0x39, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0x45, 0xe9, 0x3b}, SECP256K1_FE_CONST(0x0d5cd840, 0x427f941f, 0x65193079, 0xab8e2e83, 0x024ef2ee, 0x7ca558d8, 0x8879ffd8, 0x79fb6657), 0},\n+    {{0x15, 0xfd, 0xf5, 0xcf, 0x09, 0xc9, 0x07, 0x59, 0xad, 0xd2, 0x27, 0x2d, 0x57, 0x4d, 0x2b, 0xb5, 0xfe, 0x14, 0x29, 0xf9, 0xf3, 0xc1, 0x4c, 0x65, 0xe3, 0x19, 0x4b, 0xf6, 0x1b, 0x82, 0xaa, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xcf, 0xd9, 0x06}, SECP256K1_FE_CONST(0x16d0e439, 0x46aec93f, 0x62d57eb8, 0xcde68951, 0xaf136cf4, 0xb307938d, 0xd1447411, 0xe07bffe1), 1},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0x67, 0xed, 0xf7, 0x79, 0xa8, 0xa6, 0x49, 0xd6, 0xde, 0xf6, 0x00, 0x35, 0xf2, 0xfa, 0x22, 0xd0, 0x22, 0xdd, 0x35, 0x90, 0x79, 0xa1, 0xa1, 0x44, 0x07, 0x3d, 0x84, 0xf1, 0x9b, 0x92, 0xd5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x025661f9, 0xaba9d15c, 0x3118456b, 0xbe980e3e, 0x1b8ba2e0, 0x47c737a4, 0xeb48a040, 0xbb566f6c), 0},\n+    {{0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6, 0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x98bec3b2, 0xa351fa96, 0xcfd191c1, 0x77835193, 0x1b9e9ba9, 0xad1149f6, 0xd9eadca8, 0x0981b801), 0},\n+    {{0x40, 0x56, 0xa3, 0x4a, 0x21, 0x0e, 0xec, 0x78, 0x92, 0xe8, 0x82, 0x06, 0x75, 0xc8, 0x60, 0x09, 0x9f, 0x85, 0x7b, 0x26, 0xaa, 0xd8, 0x54, 0x70, 0xee, 0x6d, 0x3c, 0xf1, 0x30, 0x4a, 0x9d, 0xcf, 0x37, 0x5e, 0x70, 0x37, 0x42, 0x71, 0xf2, 0x0b, 0x13, 0xc9, 0x98, 0x6e, 0xd7, 0xd3, 0xc1, 0x77, 0x99, 0x69, 0x8c, 0xfc, 0x43, 0x5d, 0xbe, 0xd3, 0xa9, 0xf3, 0x4b, 0x38, 0xc8, 0x23, 0xc2, 0xb4}, SECP256K1_FE_CONST(0x868aac20, 0x03b29dbc, 0xad1a3e80, 0x3855e078, 0xa89d1654, 0x3ac64392, 0xd1224172, 0x98cec76e), 0},\n+    {{0x41, 0x97, 0xec, 0x37, 0x23, 0xc6, 0x54, 0xcf, 0xdd, 0x32, 0xab, 0x07, 0x55, 0x06, 0x64, 0x8b, 0x2f, 0xf5, 0x07, 0x03, 0x62, 0xd0, 0x1a, 0x4f, 0xff, 0x14, 0xb3, 0x36, 0xb7, 0x8f, 0x96, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb3, 0xab, 0x1e, 0x95}, SECP256K1_FE_CONST(0xba5a6314, 0x502a8952, 0xb8f456e0, 0x85928105, 0xf665377a, 0x8ce27726, 0xa5b0eb7e, 0xc1ac0286), 0},\n+    {{0x47, 0xeb, 0x3e, 0x20, 0x8f, 0xed, 0xcd, 0xf8, 0x23, 0x4c, 0x94, 0x21, 0xe9, 0xcd, 0x9a, 0x7a, 0xe8, 0x73, 0xbf, 0xbd, 0xbc, 0x39, 0x37, 0x23, 0xd1, 0xba, 0x1e, 0x1e, 0x6a, 0x8e, 0x6b, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xd1, 0x2c, 0xb1}, SECP256K1_FE_CONST(0xd192d520, 0x07e541c9, 0x807006ed, 0x0468df77, 0xfd214af0, 0xa795fe11, 0x9359666f, 0xdcf08f7c), 0},\n+    {{0x5e, 0xb9, 0x69, 0x6a, 0x23, 0x36, 0xfe, 0x2c, 0x3c, 0x66, 0x6b, 0x02, 0xc7, 0x55, 0xdb, 0x4c, 0x0c, 0xfd, 0x62, 0x82, 0x5c, 0x7b, 0x58, 0x9a, 0x7b, 0x7b, 0xb4, 0x42, 0xe1, 0x41, 0xc1, 0xd6, 0x93, 0x41, 0x3f, 0x00, 0x52, 0xd4, 0x9e, 0x64, 0xab, 0xec, 0x6d, 0x58, 0x31, 0xd6, 0x6c, 0x43, 0x61, 0x28, 0x30, 0xa1, 0x7d, 0xf1, 0xfe, 0x43, 0x83, 0xdb, 0x89, 0x64, 0x68, 0x10, 0x02, 0x21}, SECP256K1_FE_CONST(0xef6e1da6, 0xd6c7627e, 0x80f7a723, 0x4cb08a02, 0x2c1ee1cf, 0x29e4d0f9, 0x642ae924, 0xcef9eb38), 1},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x7b, 0xf9, 0x6b, 0x7b, 0x6d, 0xa1, 0x5d, 0x34, 0x76, 0xa2, 0xb1, 0x95, 0x93, 0x4b, 0x69, 0x0a, 0x3a, 0x3d, 0xe3, 0xe8, 0xab, 0x84, 0x74, 0x85, 0x68, 0x63, 0xb0, 0xde, 0x3a, 0xf9, 0x0b, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x50851dfc, 0x9f418c31, 0x4a437295, 0xb24feeea, 0x27af3d0c, 0xd2308348, 0xfda6e21c, 0x463e46ff), 0},\n+    {{0x85, 0x1b, 0x1c, 0xa9, 0x45, 0x49, 0x37, 0x1c, 0x4f, 0x1f, 0x71, 0x87, 0x32, 0x1d, 0x39, 0xbf, 0x51, 0xc6, 0xb7, 0xfb, 0x61, 0xf7, 0xcb, 0xf0, 0x27, 0xc9, 0xda, 0x62, 0x02, 0x1b, 0x7a, 0x65, 0xfc, 0x54, 0xc9, 0x68, 0x37, 0xfb, 0x22, 0xb3, 0x62, 0xed, 0xa6, 0x3e, 0xc5, 0x2e, 0xc8, 0x3d, 0x81, 0xbe, 0xdd, 0x16, 0x0c, 0x11, 0xb2, 0x2d, 0x96, 0x5d, 0x9f, 0x4a, 0x6d, 0x64, 0xd2, 0x51}, SECP256K1_FE_CONST(0x3e731051, 0xe12d3323, 0x7eb324f2, 0xaa5b16bb, 0x868eb49a, 0x1aa1fadc, 0x19b6e876, 0x1b5a5f7b), 1},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0x94, 0x3c, 0x2f, 0x77, 0x51, 0x08, 0xb7, 0x37, 0xfe, 0x65, 0xa9, 0x53, 0x1e, 0x19, 0xf2, 0xfc, 0x2a, 0x19, 0x7f, 0x56, 0x03, 0xe3, 0xa2, 0x88, 0x1d, 0x1d, 0x83, 0xe4, 0x00, 0x8f, 0x91, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x311c61f0, 0xab2f32b7, 0xb1f0223f, 0xa72f0a78, 0x752b8146, 0xe46107f8, 0x876dd9c4, 0xf92b2942), 0},\n+    {{0xa0, 0xf1, 0x84, 0x92, 0x18, 0x3e, 0x61, 0xe8, 0x06, 0x3e, 0x57, 0x36, 0x06, 0x59, 0x14, 0x21, 0xb0, 0x6b, 0xc3, 0x51, 0x36, 0x31, 0x57, 0x8a, 0x73, 0xa3, 0x9c, 0x1c, 0x33, 0x06, 0x23, 0x9f, 0x2f, 0x32, 0x90, 0x4f, 0x0d, 0x2a, 0x33, 0xec, 0xca, 0x8a, 0x54, 0x51, 0x70, 0x5b, 0xb5, 0x37, 0xd3, 0xbf, 0x44, 0xe0, 0x71, 0x22, 0x60, 0x25, 0xcd, 0xbf, 0xd2, 0x49, 0xfe, 0x0f, 0x7a, 0xd6}, SECP256K1_FE_CONST(0x97a09cf1, 0xa2eae7c4, 0x94df3c6f, 0x8a9445bf, 0xb8c09d60, 0x832f9b0b, 0x9d5eabe2, 0x5fbd14b9), 0},\n+    {{0xa1, 0xed, 0x0a, 0x0b, 0xd7, 0x9d, 0x8a, 0x23, 0xcf, 0xe4, 0xec, 0x5f, 0xef, 0x5b, 0xa5, 0xcc, 0xcf, 0xd8, 0x44, 0xe4, 0xff, 0x5c, 0xb4, 0xb0, 0xf2, 0xe7, 0x16, 0x27, 0x34, 0x1f, 0x1c, 0x5b, 0x17, 0xc4, 0x99, 0x24, 0x9e, 0x0a, 0xc0, 0x8d, 0x5d, 0x11, 0xea, 0x1c, 0x2c, 0x8c, 0xa7, 0x00, 0x16, 0x16, 0x55, 0x9a, 0x79, 0x94, 0xea, 0xde, 0xc9, 0xca, 0x10, 0xfb, 0x4b, 0x85, 0x16, 0xdc}, SECP256K1_FE_CONST(0x65a89640, 0x744192cd, 0xac64b2d2, 0x1ddf989c, 0xdac75007, 0x25b645be, 0xf8e2200a, 0xe39691f2), 0},\n+    {{0xba, 0x94, 0x59, 0x4a, 0x43, 0x27, 0x21, 0xaa, 0x35, 0x80, 0xb8, 0x4c, 0x16, 0x1d, 0x0d, 0x13, 0x4b, 0xc3, 0x54, 0xb6, 0x90, 0x40, 0x4d, 0x7c, 0xd4, 0xec, 0x57, 0xc1, 0x6d, 0x3f, 0xbe, 0x98, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x50, 0x7d, 0xd7}, SECP256K1_FE_CONST(0x5e0d7656, 0x4aae92cb, 0x347e01a6, 0x2afd389a, 0x9aa401c7, 0x6c8dd227, 0x543dc9cd, 0x0efe685a), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x2d97f96c, 0xac882dfe, 0x73dc44db, 0x6ce0f1d3, 0x1d624135, 0x8dd5d74e, 0xb3d3b500, 0x03d24c2b), 0},\n+    {{0xbc, 0xaf, 0x72, 0x19, 0xf2, 0xf6, 0xfb, 0xf5, 0x5f, 0xe5, 0xe0, 0x62, 0xdc, 0xe0, 0xe4, 0x8c, 0x18, 0xf6, 0x81, 0x03, 0xf1, 0x0b, 0x81, 0x98, 0xe9, 0x74, 0xc1, 0x84, 0x75, 0x0e, 0x1b, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x07, 0xd0, 0x9a}, SECP256K1_FE_CONST(0xe7008afe, 0x6e8cbd50, 0x55df120b, 0xd748757c, 0x686dadb4, 0x1cce75e4, 0xaddcc5e0, 0x2ec02b44), 1},\n+    {{0xc5, 0x98, 0x1b, 0xae, 0x27, 0xfd, 0x84, 0x40, 0x1c, 0x72, 0xa1, 0x55, 0xe5, 0x70, 0x7f, 0xbb, 0x81, 0x1b, 0x2b, 0x62, 0x06, 0x45, 0xd1, 0x02, 0x8e, 0xa2, 0x70, 0xcb, 0xe0, 0xee, 0x22, 0x5d, 0x4b, 0x62, 0xaa, 0x4d, 0xca, 0x65, 0x06, 0xc1, 0xac, 0xdb, 0xec, 0xc0, 0x55, 0x25, 0x69, 0xb4, 0xb2, 0x14, 0x36, 0xa5, 0x69, 0x2e, 0x25, 0xd9, 0x0d, 0x3b, 0xc2, 0xeb, 0x7c, 0xe2, 0x40, 0x78}, SECP256K1_FE_CONST(0x948b40e7, 0x181713bc, 0x018ec170, 0x2d3d054d, 0x15746c59, 0xa7020730, 0xdd13ecf9, 0x85a010d7), 0},\n+    {{0xc8, 0x94, 0xce, 0x48, 0xbf, 0xec, 0x43, 0x30, 0x14, 0xb9, 0x31, 0xa6, 0xad, 0x42, 0x26, 0xd7, 0xdb, 0xd8, 0xea, 0xa7, 0xb6, 0xe3, 0xfa, 0xa8, 0xd0, 0xef, 0x94, 0x05, 0x2b, 0xcf, 0x8c, 0xff, 0x33, 0x6e, 0xeb, 0x39, 0x19, 0xe2, 0xb4, 0xef, 0xb7, 0x46, 0xc7, 0xf7, 0x1b, 0xbc, 0xa7, 0xe9, 0x38, 0x32, 0x30, 0xfb, 0xbc, 0x48, 0xff, 0xaf, 0xe7, 0x7e, 0x8b, 0xcc, 0x69, 0x54, 0x24, 0x71}, SECP256K1_FE_CONST(0xf1c91acd, 0xc2525330, 0xf9b53158, 0x434a4d43, 0xa1c547cf, 0xf29f1550, 0x6f5da4eb, 0x4fe8fa5a), 1},\n+    {{0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c, 0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x872d81ed, 0x8831d999, 0x8b67cb71, 0x05243edb, 0xf86c10ed, 0xfebb786c, 0x110b02d0, 0x7b2e67cd), 0},\n+    {{0xd9, 0x17, 0xb7, 0x86, 0xda, 0xc3, 0x56, 0x70, 0xc3, 0x30, 0xc9, 0xc5, 0xae, 0x59, 0x71, 0xdf, 0xb4, 0x95, 0xc8, 0xae, 0x52, 0x3e, 0xd9, 0x7e, 0xe2, 0x42, 0x01, 0x17, 0xb1, 0x71, 0xf4, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0xf6, 0xf6}, SECP256K1_FE_CONST(0xe45b71e1, 0x10b831f2, 0xbdad8651, 0x994526e5, 0x8393fde4, 0x328b1ec0, 0x4d598971, 0x42584691), 1},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe2, 0x8b, 0xd8, 0xf5, 0x92, 0x9b, 0x46, 0x7e, 0xb7, 0x0e, 0x04, 0x33, 0x23, 0x74, 0xff, 0xb7, 0xe7, 0x18, 0x02, 0x18, 0xad, 0x16, 0xea, 0xa4, 0x6b, 0x71, 0x61, 0xaa, 0x67, 0x9e, 0xb4, 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x66b8c980, 0xa75c72e5, 0x98d383a3, 0x5a62879f, 0x844242ad, 0x1e73ff12, 0xedaa59f4, 0xe58632b5), 0},\n+    {{0xe7, 0xee, 0x58, 0x14, 0xc1, 0x70, 0x6b, 0xf8, 0xa8, 0x93, 0x96, 0xa9, 0xb0, 0x32, 0xbc, 0x01, 0x4c, 0x2c, 0xac, 0x9c, 0x12, 0x11, 0x27, 0xdb, 0xf6, 0xc9, 0x92, 0x78, 0xf8, 0xbb, 0x53, 0xd1, 0xdf, 0xd0, 0x4d, 0xbc, 0xda, 0x8e, 0x35, 0x24, 0x66, 0xb6, 0xfc, 0xd5, 0xf2, 0xde, 0xa3, 0xe1, 0x7d, 0x5e, 0x13, 0x31, 0x15, 0x88, 0x6e, 0xda, 0x20, 0xdb, 0x8a, 0x12, 0xb5, 0x4d, 0xe7, 0x1b}, SECP256K1_FE_CONST(0xe842c6e3, 0x529b2342, 0x70a5e977, 0x44edc34a, 0x04d7ba94, 0xe44b6d25, 0x23c9cf01, 0x95730a50), 1},\n+    {{0xf2, 0x92, 0xe4, 0x68, 0x25, 0xf9, 0x22, 0x5a, 0xd2, 0x3d, 0xc0, 0x57, 0xc1, 0xd9, 0x1c, 0x4f, 0x57, 0xfc, 0xb1, 0x38, 0x6f, 0x29, 0xef, 0x10, 0x48, 0x1c, 0xb1, 0xd2, 0x25, 0x18, 0x59, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x11, 0xc9, 0x89}, SECP256K1_FE_CONST(0x3cea2c53, 0xb8b01701, 0x66ac7da6, 0x7194694a, 0xdacc84d5, 0x6389225e, 0x330134da, 0xb85a4d55), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x01, 0xd3, 0x47, 0x5b, 0xf7, 0x65, 0x5b, 0x0f, 0xb2, 0xd8, 0x52, 0x92, 0x10, 0x35, 0xb2, 0xef, 0x60, 0x7f, 0x49, 0x06, 0x9b, 0x97, 0x45, 0x4e, 0x67, 0x95, 0x25, 0x10, 0x62, 0x74, 0x17, 0x71}, SECP256K1_FE_CONST(0xb5da00b7, 0x3cd65605, 0x20e7c364, 0x086e7cd2, 0x3a34bf60, 0xd0e707be, 0x9fc34d4c, 0xd5fdfa2c), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14, 0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee}, SECP256K1_FE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x82, 0x27, 0x7c, 0x4a, 0x71, 0xf9, 0xd2, 0x2e, 0x66, 0xec, 0xe5, 0x23, 0xf8, 0xfa, 0x08, 0x74, 0x1a, 0x7c, 0x09, 0x12, 0xc6, 0x6a, 0x69, 0xce, 0x68, 0x51, 0x4b, 0xfd, 0x35, 0x15, 0xb4, 0x9f}, SECP256K1_FE_CONST(0xf482f2e2, 0x41753ad0, 0xfb89150d, 0x8491dc1e, 0x34ff0b8a, 0xcfbb442c, 0xfe999e2e, 0x5e6fd1d2), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x84, 0x21, 0xcc, 0x93, 0x0e, 0x77, 0xc9, 0xf5, 0x14, 0xb6, 0x91, 0x5c, 0x3d, 0xbe, 0x2a, 0x94, 0xc6, 0xd8, 0xf6, 0x90, 0xb5, 0xb7, 0x39, 0x86, 0x4b, 0xa6, 0x78, 0x9f, 0xb8, 0xa5, 0x5d, 0xd0}, SECP256K1_FE_CONST(0x9f59c402, 0x75f5085a, 0x006f05da, 0xe77eb98c, 0x6fd0db1a, 0xb4a72ac4, 0x7eae90a4, 0xfc9e57e0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xd1, 0x9c, 0x18, 0x2d, 0x27, 0x59, 0xcd, 0x99, 0x82, 0x42, 0x28, 0xd9, 0x47, 0x99, 0xf8, 0xc6, 0x55, 0x7c, 0x38, 0xa1, 0xc0, 0xd6, 0x77, 0x9b, 0x9d, 0x4b, 0x72, 0x9c, 0x6f, 0x1c, 0xcc, 0x42}, SECP256K1_FE_CONST(0x70720db7, 0xe238d041, 0x21f5b1af, 0xd8cc5ad9, 0xd18944c6, 0xbdc94881, 0xf502b7a3, 0xaf3aecff), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0xedd1fd3e, 0x327ce90c, 0xc7a35426, 0x14289aee, 0x9682003e, 0x9cf7dcc9, 0xcf2ca974, 0x3be5aa0c), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x26, 0x64, 0xbb, 0xd5}, SECP256K1_FE_CONST(0x50873db3, 0x1badcc71, 0x890e4f67, 0x753a6575, 0x7f97aaa7, 0xdd5f1e82, 0xb753ace3, 0x2219064b), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x28, 0xde, 0x7d}, SECP256K1_FE_CONST(0x1eea9cc5, 0x9cfcf2fa, 0x151ac6c2, 0x74eea411, 0x0feb4f7b, 0x68c59657, 0x32e9992e, 0x976ef68e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xcf, 0xb7, 0xe7}, SECP256K1_FE_CONST(0x12303941, 0xaedc2088, 0x80735b1f, 0x1795c8e5, 0x5be520ea, 0x93e10335, 0x7b5d2adb, 0x7ed59b8e), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x11, 0x3a, 0xd9}, SECP256K1_FE_CONST(0x7eed6b70, 0xe7b0767c, 0x7d7feac0, 0x4e57aa2a, 0x12fef5e0, 0xf48f878f, 0xcbb88b3b, 0x6b5e0783), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xce, 0xa4, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x64998443, 0x5b62b4a2, 0x5d40c613, 0x3e8d9ab8, 0xc53d4b05, 0x9ee8a154, 0xa3be0fcf, 0x4e892edb), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x02, 0x8c, 0x59, 0x00, 0x63, 0xf6, 0x4d, 0x5a, 0x7f, 0x1c, 0x14, 0x91, 0x5c, 0xd6, 0x1e, 0xac, 0x88, 0x6a, 0xb2, 0x95, 0xbe, 0xbd, 0x91, 0x99, 0x25, 0x04, 0xcf, 0x77, 0xed, 0xb0, 0x28, 0xbd, 0xd6, 0x26, 0x7f}, SECP256K1_FE_CONST(0x3fde5713, 0xf8282eea, 0xd7d39d42, 0x01f44a7c, 0x85a5ac8a, 0x0681f35e, 0x54085c6b, 0x69543374), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0x15, 0xde, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x3524f77f, 0xa3a6eb43, 0x89c3cb5d, 0x27f1f914, 0x62086429, 0xcd6c0cb0, 0xdf43ea8f, 0x1e7b3fb4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2c, 0x2c, 0x57, 0x09, 0xe7, 0x15, 0x6c, 0x41, 0x77, 0x17, 0xf2, 0xfe, 0xab, 0x14, 0x71, 0x41, 0xec, 0x3d, 0xa1, 0x9f, 0xb7, 0x59, 0x57, 0x5c, 0xc6, 0xe3, 0x7b, 0x2e, 0xa5, 0xac, 0x93, 0x09, 0xf2, 0x6f, 0x0f, 0x66}, SECP256K1_FE_CONST(0xd2469ab3, 0xe04acbb2, 0x1c65a180, 0x9f39caaf, 0xe7a77c13, 0xd10f9dd3, 0x8f391c01, 0xdc499c52), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3a, 0x08, 0xcc, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x60, 0xe9, 0xf0}, SECP256K1_FE_CONST(0x38e2a5ce, 0x6a93e795, 0xe16d2c39, 0x8bc99f03, 0x69202ce2, 0x1e8f09d5, 0x6777b40f, 0xc512bccc), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x91, 0x25, 0x7d, 0x93, 0x20, 0x16, 0xcb, 0xf6, 0x9c, 0x44, 0x71, 0xbd, 0x1f, 0x65, 0x6c, 0x6a, 0x10, 0x7f, 0x19, 0x73, 0xde, 0x4a, 0xf7, 0x08, 0x6d, 0xb8, 0x97, 0x27, 0x70, 0x60, 0xe2, 0x56, 0x77, 0xf1, 0x9a}, SECP256K1_FE_CONST(0x864b3dc9, 0x02c37670, 0x9c10a93a, 0xd4bbe29f, 0xce0012f3, 0xdc8672c6, 0x286bba28, 0xd7d6d6fc), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x79, 0x5d, 0x6c, 0x1c, 0x32, 0x2c, 0xad, 0xf5, 0x99, 0xdb, 0xb8, 0x64, 0x81, 0x52, 0x2b, 0x3c, 0xc5, 0x5f, 0x15, 0xa6, 0x79, 0x32, 0xdb, 0x2a, 0xfa, 0x01, 0x11, 0xd9, 0xed, 0x69, 0x81, 0xbc, 0xd1, 0x24, 0xbf, 0x44}, SECP256K1_FE_CONST(0x766dfe4a, 0x700d9bee, 0x288b903a, 0xd58870e3, 0xd4fe2f0e, 0xf780bcac, 0x5c823f32, 0x0d9a9bef), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x42, 0x6f, 0x03, 0x92, 0x38, 0x90, 0x78, 0xc1, 0x2b, 0x1a, 0x89, 0xe9, 0x54, 0x2f, 0x05, 0x93, 0xbc, 0x96, 0xb6, 0xbf, 0xde, 0x82, 0x24, 0xf8, 0x65, 0x4e, 0xf5, 0xd5, 0xcd, 0xa9, 0x35, 0xa3, 0x58, 0x21, 0x94}, SECP256K1_FE_CONST(0xfaec7bc1, 0x987b6323, 0x3fbc5f95, 0x6edbf37d, 0x54404e74, 0x61c58ab8, 0x631bc68e, 0x451a0478), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x91, 0x19, 0x21, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x45, 0xf0, 0xf1, 0xeb}, SECP256K1_FE_CONST(0xec29a50b, 0xae138dbf, 0x7d8e2482, 0x5006bb5f, 0xc1a2cc12, 0x43ba335b, 0xc6116fb9, 0xe498ec1f), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0xeb, 0x9a, 0xb7, 0x6e, 0x84, 0x49, 0x9c, 0x48, 0x3b, 0x3b, 0xf0, 0x62, 0x14, 0xab, 0xfe, 0x06, 0x5d, 0xdd, 0xf4, 0x3b, 0x86, 0x01, 0xde, 0x59, 0x6d, 0x63, 0xb9, 0xe4, 0x5a, 0x16, 0x6a, 0x58, 0x05, 0x41, 0xfe}, SECP256K1_FE_CONST(0x1e0ff2de, 0xe9b09b13, 0x6292a9e9, 0x10f0d6ac, 0x3e552a64, 0x4bba39e6, 0x4e9dd3e3, 0xbbd3d4d4), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xc7, 0x4d, 0x99, 0xef, 0xce, 0xaa, 0x55, 0x0f, 0x1a, 0xd1, 0xc0, 0xf4, 0x3f, 0x46, 0xe7, 0xff, 0x1e, 0xe3, 0xbd, 0x01, 0x62, 0xb7, 0xbf, 0x55, 0xf2, 0x96, 0x5d, 0xa9, 0xc3, 0x45, 0x06, 0x46}, SECP256K1_FE_CONST(0x8b7dd5c3, 0xedba9ee9, 0x7b70eff4, 0x38f22dca, 0x9849c825, 0x4a2f3345, 0xa0a572ff, 0xeaae0928), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x77, 0xb7, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x6c, 0xa8, 0x96}, SECP256K1_FE_CONST(0x0881950c, 0x8f51d6b9, 0xa6387465, 0xd5f12609, 0xef1bb254, 0x12a08a74, 0xcb2dfb20, 0x0c74bfbf), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xf5, 0xcd, 0x83, 0x88, 0x16, 0xc1, 0x6c, 0x4f, 0xe8, 0xa1, 0x66, 0x1d, 0x60, 0x6f, 0xdb, 0x13, 0xcf, 0x9a, 0xf0, 0x4b, 0x97, 0x9a, 0x2e, 0x15, 0x9a, 0x09, 0x40, 0x9e, 0xbc, 0x86, 0x45, 0xd5, 0x8f, 0xde, 0x02}, SECP256K1_FE_CONST(0x2f083207, 0xb9fd9b55, 0x0063c31c, 0xd62b8746, 0xbd543bdc, 0x5bbf10e3, 0xa35563e9, 0x27f440c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x3f, 0x75, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x4f51e0be, 0x078e0cdd, 0xab274215, 0x6adba7e7, 0xa148e731, 0x57072fd6, 0x18cd6094, 0x2b146bd0), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xbc, 0x1f, 0x8d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f}, SECP256K1_FE_CONST(0x16c2ccb5, 0x4352ff4b, 0xd794f6ef, 0xd613c721, 0x97ab7082, 0xda5b563b, 0xdf9cb3ed, 0xaafe74c2), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x64, 0xd1, 0x62, 0x75, 0x05, 0x46, 0xce, 0x42, 0xb0, 0x43, 0x13, 0x61, 0xe5, 0x2d, 0x4f, 0x52, 0x42, 0xd8, 0xf2, 0x4f, 0x33, 0xe6, 0xb1, 0xf9, 0x9b, 0x59, 0x16, 0x47, 0xcb, 0xc8, 0x08, 0xf4, 0x62, 0xaf, 0x51}, SECP256K1_FE_CONST(0xd41244d1, 0x1ca4f652, 0x40687759, 0xf95ca9ef, 0xbab767ed, 0xedb38fd1, 0x8c36e18c, 0xd3b6f6a9), 1},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe5, 0xbe, 0x52, 0x37, 0x2d, 0xd6, 0xe8, 0x94, 0xb2, 0xa3, 0x26, 0xfc, 0x36, 0x05, 0xa6, 0xe8, 0xf3, 0xc6, 0x9c, 0x71, 0x0b, 0xf2, 0x7d, 0x63, 0x0d, 0xfe, 0x20, 0x04, 0x98, 0x8b, 0x78, 0xeb, 0x6e, 0xab, 0x36}, SECP256K1_FE_CONST(0x64bf84dd, 0x5e03670f, 0xdb24c0f5, 0xd3c2c365, 0x736f51db, 0x6c92d950, 0x10716ad2, 0xd36134c8), 0},\n+    {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0xb9, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xd6, 0xdb, 0x1f}, SECP256K1_FE_CONST(0x1c92ccdf, 0xcf4ac550, 0xc28db57c, 0xff0c8515, 0xcb26936c, 0x786584a7, 0x0114008d, 0x6c33a34b), 0},\n+};\n+\n+/* Set of expected ellswift_xdh BIP324 shared secrets, given private key, encodings, initiating,\n+ * taken from the BIP324 test vectors. Created using an independent implementation, and tested\n+ * against the paper authors' decoding code. */\n+static const struct ellswift_xdh_test ellswift_xdh_tests_bip324[] = {\n+    {{0x61, 0x06, 0x2e, 0xa5, 0x07, 0x1d, 0x80, 0x0b, 0xbf, 0xd5, 0x9e, 0x2e, 0x8b, 0x53, 0xd4, 0x7d, 0x19, 0x4b, 0x09, 0x5a, 0xe5, 0xa4, 0xdf, 0x04, 0x93, 0x6b, 0x49, 0x77, 0x2e, 0xf0, 0xd4, 0xd7}, {0xec, 0x0a, 0xdf, 0xf2, 0x57, 0xbb, 0xfe, 0x50, 0x0c, 0x18, 0x8c, 0x80, 0xb4, 0xfd, 0xd6, 0x40, 0xf6, 0xb4, 0x5a, 0x48, 0x2b, 0xbc, 0x15, 0xfc, 0x7c, 0xef, 0x59, 0x31, 0xde, 0xff, 0x0a, 0xa1, 0x86, 0xf6, 0xeb, 0x9b, 0xba, 0x7b, 0x85, 0xdc, 0x4d, 0xcc, 0x28, 0xb2, 0x87, 0x22, 0xde, 0x1e, 0x3d, 0x91, 0x08, 0xb9, 0x85, 0xe2, 0x96, 0x70, 0x45, 0x66, 0x8f, 0x66, 0x09, 0x8e, 0x47, 0x5b}, {0xa4, 0xa9, 0x4d, 0xfc, 0xe6, 0x9b, 0x4a, 0x2a, 0x0a, 0x09, 0x93, 0x13, 0xd1, 0x0f, 0x9f, 0x7e, 0x7d, 0x64, 0x9d, 0x60, 0x50, 0x1c, 0x9e, 0x1d, 0x27, 0x4c, 0x30, 0x0e, 0x0d, 0x89, 0xaa, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xaf, 0x88, 0xd5}, 1, {0xc6, 0x99, 0x2a, 0x11, 0x7f, 0x5e, 0xdb, 0xea, 0x70, 0xc3, 0xf5, 0x11, 0xd3, 0x2d, 0x26, 0xb9, 0x79, 0x8b, 0xe4, 0xb8, 0x1a, 0x62, 0xea, 0xee, 0x1a, 0x5a, 0xca, 0xa8, 0x45, 0x9a, 0x35, 0x92}},\n+    {{0x1f, 0x9c, 0x58, 0x1b, 0x35, 0x23, 0x18, 0x38, 0xf0, 0xf1, 0x7c, 0xf0, 0xc9, 0x79, 0x83, 0x5b, 0xac, 0xcb, 0x7f, 0x3a, 0xbb, 0xbb, 0x96, 0xff, 0xcc, 0x31, 0x8a, 0xb7, 0x1e, 0x6e, 0x12, 0x6f}, {0xa1, 0x85, 0x5e, 0x10, 0xe9, 0x4e, 0x00, 0xba, 0xa2, 0x30, 0x41, 0xd9, 0x16, 0xe2, 0x59, 0xf7, 0x04, 0x4e, 0x49, 0x1d, 0xa6, 0x17, 0x12, 0x69, 0x69, 0x47, 0x63, 0xf0, 0x18, 0xc7, 0xe6, 0x36, 0x93, 0xd2, 0x95, 0x75, 0xdc, 0xb4, 0x64, 0xac, 0x81, 0x6b, 0xaa, 0x1b, 0xe3, 0x53, 0xba, 0x12, 0xe3, 0x87, 0x6c, 0xba, 0x76, 0x28, 0xbd, 0x0b, 0xd8, 0xe7, 0x55, 0xe7, 0x21, 0xeb, 0x01, 0x40}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0, {0xa0, 0x13, 0x8f, 0x56, 0x4f, 0x74, 0xd0, 0xad, 0x70, 0xbc, 0x33, 0x7d, 0xac, 0xc9, 0xd0, 0xbf, 0x1d, 0x23, 0x49, 0x36, 0x4c, 0xaf, 0x11, 0x88, 0xa1, 0xe6, 0xe8, 0xdd, 0xb3, 0xb7, 0xb1, 0x84}},\n+    {{0x02, 0x86, 0xc4, 0x1c, 0xd3, 0x09, 0x13, 0xdb, 0x0f, 0xdf, 0xf7, 0xa6, 0x4e, 0xbd, 0xa5, 0xc8, 0xe3, 0xe7, 0xce, 0xf1, 0x0f, 0x2a, 0xeb, 0xc0, 0x0a, 0x76, 0x50, 0x44, 0x3c, 0xf4, 0xc6, 0x0d}, {0xd1, 0xee, 0x8a, 0x93, 0xa0, 0x11, 0x30, 0xcb, 0xf2, 0x99, 0x24, 0x9a, 0x25, 0x8f, 0x94, 0xfe, 0xb5, 0xf4, 0x69, 0xe7, 0xd0, 0xf2, 0xf2, 0x8f, 0x69, 0xee, 0x5e, 0x9a, 0xa8, 0xf9, 0xb5, 0x4a, 0x60, 0xf2, 0xc3, 0xff, 0x2d, 0x02, 0x36, 0x34, 0xec, 0x7f, 0x41, 0x27, 0xa9, 0x6c, 0xc1, 0x16, 0x62, 0xe4, 0x02, 0x89, 0x4c, 0xf1, 0xf6, 0x94, 0xfb, 0x9a, 0x7e, 0xaa, 0x5f, 0x1d, 0x92, 0x44}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x22, 0xd5, 0xe4, 0x41, 0x52, 0x4d, 0x57, 0x1a, 0x52, 0xb3, 0xde, 0xf1, 0x26, 0x18, 0x9d, 0x3f, 0x41, 0x68, 0x90, 0xa9, 0x9d, 0x4d, 0xa6, 0xed, 0xe2, 0xb0, 0xcd, 0xe1, 0x76, 0x0c, 0xe2, 0xc3, 0xf9, 0x84, 0x57, 0xae}, 1, {0x25, 0x0b, 0x93, 0x57, 0x0d, 0x41, 0x11, 0x49, 0x10, 0x5a, 0xb8, 0xcb, 0x0b, 0xc5, 0x07, 0x99, 0x14, 0x90, 0x63, 0x06, 0x36, 0x8c, 0x23, 0xe9, 0xd7, 0x7c, 0x2a, 0x33, 0x26, 0x5b, 0x99, 0x4c}},\n+    {{0x6c, 0x77, 0x43, 0x2d, 0x1f, 0xda, 0x31, 0xe9, 0xf9, 0x42, 0xf8, 0xaf, 0x44, 0x60, 0x7e, 0x10, 0xf3, 0xad, 0x38, 0xa6, 0x5f, 0x8a, 0x4b, 0xdd, 0xae, 0x82, 0x3e, 0x5e, 0xff, 0x90, 0xdc, 0x38}, {0xd2, 0x68, 0x50, 0x70, 0xc1, 0xe6, 0x37, 0x6e, 0x63, 0x3e, 0x82, 0x52, 0x96, 0x63, 0x4f, 0xd4, 0x61, 0xfa, 0x9e, 0x5b, 0xdf, 0x21, 0x09, 0xbc, 0xeb, 0xd7, 0x35, 0xe5, 0xa9, 0x1f, 0x3e, 0x58, 0x7c, 0x5c, 0xb7, 0x82, 0xab, 0xb7, 0x97, 0xfb, 0xf6, 0xbb, 0x50, 0x74, 0xfd, 0x15, 0x42, 0xa4, 0x74, 0xf2, 0xa4, 0x5b, 0x67, 0x37, 0x63, 0xec, 0x2d, 0xb7, 0xfb, 0x99, 0xb7, 0x37, 0xbb, 0xb9}, {0x56, 0xbd, 0x0c, 0x06, 0xf1, 0x03, 0x52, 0xc3, 0xa1, 0xa9, 0xf4, 0xb4, 0xc9, 0x2f, 0x6f, 0xa2, 0xb2, 0x6d, 0xf1, 0x24, 0xb5, 0x78, 0x78, 0x35, 0x3c, 0x1f, 0xc6, 0x91, 0xc5, 0x1a, 0xbe, 0xa7, 0x7c, 0x88, 0x17, 0xda, 0xee, 0xb9, 0xfa, 0x54, 0x6b, 0x77, 0xc8, 0xda, 0xf7, 0x9d, 0x89, 0xb2, 0x2b, 0x0e, 0x1b, 0x87, 0x57, 0x4e, 0xce, 0x42, 0x37, 0x1f, 0x00, 0x23, 0x7a, 0xa9, 0xd8, 0x3a}, 0, {0x19, 0x18, 0xb7, 0x41, 0xef, 0x5f, 0x9d, 0x1d, 0x76, 0x70, 0xb0, 0x50, 0xc1, 0x52, 0xb4, 0xa4, 0xea, 0xd2, 0xc3, 0x1b, 0xe9, 0xae, 0xcb, 0x06, 0x81, 0xc0, 0xcd, 0x43, 0x24, 0x15, 0x08, 0x53}},\n+    {{0xa6, 0xec, 0x25, 0x12, 0x7c, 0xa1, 0xaa, 0x4c, 0xf1, 0x6b, 0x20, 0x08, 0x4b, 0xa1, 0xe6, 0x51, 0x6b, 0xaa, 0xe4, 0xd3, 0x24, 0x22, 0x28, 0x8e, 0x9b, 0x36, 0xd8, 0xbd, 0xdd, 0x2d, 0xe3, 0x5a}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x3d, 0x7e, 0xcc, 0xa5, 0x3e, 0x33, 0xe1, 0x85, 0xa8, 0xb9, 0xbe, 0x4e, 0x76, 0x99, 0xa9, 0x7c, 0x6f, 0xf4, 0xc7, 0x95, 0x52, 0x2e, 0x59, 0x18, 0xab, 0x7c, 0xd6, 0xb6, 0x88, 0x4f, 0x67, 0xe6, 0x83, 0xf3, 0xdc}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x73, 0x0b, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 1, {0xdd, 0x21, 0x0a, 0xa6, 0x62, 0x9f, 0x20, 0xbb, 0x32, 0x8e, 0x5d, 0x89, 0xda, 0xa6, 0xeb, 0x2a, 0xc3, 0xd1, 0xc6, 0x58, 0xa7, 0x25, 0x53, 0x6f, 0xf1, 0x54, 0xf3, 0x1b, 0x53, 0x6c, 0x23, 0xb2}},\n+    {{0x0a, 0xf9, 0x52, 0x65, 0x9e, 0xd7, 0x6f, 0x80, 0xf5, 0x85, 0x96, 0x6b, 0x95, 0xab, 0x6e, 0x6f, 0xd6, 0x86, 0x54, 0x67, 0x28, 0x27, 0x87, 0x86, 0x84, 0xc8, 0xb5, 0x47, 0xb1, 0xb9, 0x4f, 0x5a}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x10, 0x17, 0xfd, 0x92, 0xfd, 0x31, 0x63, 0x7c, 0x26, 0xc9, 0x06, 0xb4, 0x20, 0x92, 0xe1, 0x1c, 0xc0, 0xd3, 0xaf, 0xae, 0x8d, 0x90, 0x19, 0xd2, 0x57, 0x8a, 0xf2, 0x27, 0x35, 0xce, 0x7b, 0xc4, 0x69, 0xc7, 0x2d}, {0x96, 0x52, 0xd7, 0x8b, 0xae, 0xfc, 0x02, 0x8c, 0xd3, 0x7a, 0x6a, 0x92, 0x62, 0x5b, 0x8b, 0x8f, 0x85, 0xfd, 0xe1, 0xe4, 0xc9, 0x44, 0xad, 0x3f, 0x20, 0xe1, 0x98, 0xbe, 0xf8, 0xc0, 0x2f, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0xe9, 0x18, 0x70}, 0, {0x35, 0x68, 0xf2, 0xae, 0xa2, 0xe1, 0x4e, 0xf4, 0xee, 0x4a, 0x3c, 0x2a, 0x8b, 0x8d, 0x31, 0xbc, 0x5e, 0x31, 0x87, 0xba, 0x86, 0xdb, 0x10, 0x73, 0x9b, 0x4f, 0xf8, 0xec, 0x92, 0xff, 0x66, 0x55}},\n+    {{0xf9, 0x0e, 0x08, 0x0c, 0x64, 0xb0, 0x58, 0x24, 0xc5, 0xa2, 0x4b, 0x25, 0x01, 0xd5, 0xae, 0xaf, 0x08, 0xaf, 0x38, 0x72, 0xee, 0x86, 0x0a, 0xa8, 0x0b, 0xdc, 0xd4, 0x30, 0xf7, 0xb6, 0x34, 0x94}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x11, 0x51, 0x73, 0x76, 0x5d, 0xc2, 0x02, 0xcf, 0x02, 0x9a, 0xd3, 0xf1, 0x54, 0x79, 0x73, 0x5d, 0x57, 0x69, 0x7a, 0xf1, 0x2b, 0x01, 0x31, 0xdd, 0x21, 0x43, 0x0d, 0x57, 0x72, 0xe4, 0xef, 0x11, 0x47, 0x4d, 0x58, 0xb9}, {0x12, 0xa5, 0x0f, 0x3f, 0xaf, 0xea, 0x7c, 0x1e, 0xea, 0xda, 0x4c, 0xf8, 0xd3, 0x37, 0x77, 0x70, 0x4b, 0x77, 0x36, 0x14, 0x53, 0xaf, 0xc8, 0x3b, 0xda, 0x91, 0xee, 0xf3, 0x49, 0xae, 0x04, 0x4d, 0x20, 0x12, 0x6c, 0x62, 0x00, 0x54, 0x7e, 0xa5, 0xa6, 0x91, 0x17, 0x76, 0xc0, 0x5d, 0xee, 0x2a, 0x7f, 0x1a, 0x9b, 0xa7, 0xdf, 0xba, 0xbb, 0xbd, 0x27, 0x3c, 0x3e, 0xf2, 0x9e, 0xf4, 0x6e, 0x46}, 1, {0xe2, 0x54, 0x61, 0xfb, 0x0e, 0x4c, 0x16, 0x2e, 0x18, 0x12, 0x3e, 0xcd, 0xe8, 0x83, 0x42, 0xd5, 0x4d, 0x44, 0x96, 0x31, 0xe9, 0xb7, 0x5a, 0x26, 0x6f, 0xd9, 0x26, 0x0c, 0x2b, 0xb2, 0xf4, 0x1d}},\n+};\n+\n+/** This is a hasher for ellswift_xdh which just returns the shared X coordinate.\n+ *\n+ * This is generally a bad idea as it means changes to the encoding of the\n+ * exchanged public keys do not affect the shared secret. However, it's used here\n+ * in tests to be able to verify the X coordinate through other means.\n+ */\n+static int ellswift_xdh_hash_x32(unsigned char *output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {\n+    (void)ell_a64;\n+    (void)ell_b64;\n+    (void)data;\n+    memcpy(output, x32, 32);\n+    return 1;\n+}\n+\n+void run_ellswift_tests(void) {\n+    int i = 0;\n+    /* Test vectors. */\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xswiftec_inv_tests) / sizeof(ellswift_xswiftec_inv_tests[0]); ++i) {\n+        const struct ellswift_xswiftec_inv_test *testcase = &ellswift_xswiftec_inv_tests[i];\n+        int c;\n+        for (c = 0; c < 8; ++c) {\n+            secp256k1_fe t;\n+            int ret = secp256k1_ellswift_xswiftec_inv_var(&t, &testcase->x, &testcase->u, c);\n+            CHECK(ret == ((testcase->enc_bitmap >> c) & 1));\n+            if (ret) {\n+                secp256k1_fe x2;\n+                CHECK(check_fe_equal(&t, &testcase->encs[c]));\n+                secp256k1_ellswift_xswiftec_var(&x2, &testcase->u, &testcase->encs[c]);\n+                CHECK(check_fe_equal(&testcase->x, &x2));\n+            }\n+        }\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_decode_tests) / sizeof(ellswift_decode_tests[0]); ++i) {\n+        const struct ellswift_decode_test *testcase = &ellswift_decode_tests[i];\n+        secp256k1_pubkey pubkey;\n+        secp256k1_ge ge;\n+        int ret;\n+        ret = secp256k1_ellswift_decode(CTX, &pubkey, testcase->enc);\n+        CHECK(ret);\n+        ret = secp256k1_pubkey_load(CTX, &ge, &pubkey);\n+        CHECK(ret);\n+        CHECK(check_fe_equal(&testcase->x, &ge.x));\n+        CHECK(secp256k1_fe_is_odd(&ge.y) == testcase->odd_y);\n+    }\n+    for (i = 0; (unsigned)i < sizeof(ellswift_xdh_tests_bip324) / sizeof(ellswift_xdh_tests_bip324[0]); ++i) {\n+        const struct ellswift_xdh_test *test = &ellswift_xdh_tests_bip324[i];\n+        unsigned char shared_secret[32];\n+        int ret;\n+        int party = !test->initiating;\n+        const unsigned char* ell_a64 = party ? test->ellswift_theirs : test->ellswift_ours;\n+        const unsigned char* ell_b64 = party ? test->ellswift_ours   : test->ellswift_theirs;\n+        ret = secp256k1_ellswift_xdh(CTX, shared_secret,\n+                                     ell_a64, ell_b64,\n+                                     test->priv_ours,\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL);\n+        CHECK(ret);\n+        CHECK(secp256k1_memcmp_var(shared_secret, test->shared_secret, 32) == 0);\n+    }\n+    /* Verify that secp256k1_ellswift_encode + decode roundtrips. */\n+    for (i = 0; i < 1000 * COUNT; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        /* Generate random public key and random randomizer. */\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        /* Convert the public key to ElligatorSwift and back. */\n+        secp256k1_ellswift_encode(CTX, ell64, &pubkey, rnd32);\n+        secp256k1_ellswift_decode(CTX, &pubkey2, ell64);\n+        secp256k1_pubkey_load(CTX, &g2, &pubkey2);\n+        /* Compare with original. */\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify the behavior of secp256k1_ellswift_create */\n+    for (i = 0; i < 400 * COUNT; i++) {\n+        unsigned char auxrnd32[32], sec32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_gej res;\n+        secp256k1_ge dec;\n+        secp256k1_pubkey pub;\n+        unsigned char ell64[64];\n+        int ret;\n+        /* Generate random secret key and random randomizer. */\n+        if (i & 1) secp256k1_testrand256_test(auxrnd32);\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Construct ElligatorSwift-encoded public keys for that key. */\n+        ret = secp256k1_ellswift_create(CTX, ell64, sec32, (i & 1) ? auxrnd32 : NULL);\n+        CHECK(ret);\n+        /* Decode it, and compare with traditionally-computed public key. */\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_ecmult(&res, NULL, &secp256k1_scalar_zero, &sec);\n+        ge_equals_gej(&dec, &res);\n+    }\n+    /* Verify that secp256k1_ellswift_xdh computes the right shared X coordinate. */\n+    for (i = 0; i < 800 * COUNT; i++) {\n+        unsigned char ell64[64], sec32[32], share32[32];\n+        secp256k1_scalar sec;\n+        secp256k1_ge dec, res;\n+        secp256k1_fe share_x;\n+        secp256k1_gej decj, resj;\n+        secp256k1_pubkey pub;\n+        int ret;\n+        /* Generate random secret key. */\n+        random_scalar_order_test(&sec);\n+        secp256k1_scalar_get_b32(sec32, &sec);\n+        /* Generate random ElligatorSwift encoding for the remote key and decode it. */\n+        secp256k1_testrand256_test(ell64);\n+        secp256k1_testrand256_test(ell64 + 32);\n+        secp256k1_ellswift_decode(CTX, &pub, ell64);\n+        secp256k1_pubkey_load(CTX, &dec, &pub);\n+        secp256k1_gej_set_ge(&decj, &dec);\n+        /* Compute the X coordinate of seckey*pubkey using ellswift_xdh. Note that we\n+         * pass ell64 as claimed (but incorrect) encoding for sec32 here; this works\n+         * because the \"hasher\" function we use here ignores the ell64 arguments. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32, ell64, ell64, sec32, i & 1, &ellswift_xdh_hash_x32, NULL);\n+        CHECK(ret);\n+        (void)secp256k1_fe_set_b32_limit(&share_x, share32); /* no overflow is possible */\n+        secp256k1_fe_verify(&share_x);\n+        /* Compute seckey*pubkey directly. */\n+        secp256k1_ecmult(&resj, &decj, &sec, NULL);\n+        secp256k1_ge_set_gej(&res, &resj);\n+        /* Compare. */\n+        CHECK(check_fe_equal(&res.x, &share_x));\n+    }\n+    /* Verify the joint behavior of secp256k1_ellswift_xdh */\n+    for (i = 0; i < 200 * COUNT; i++) {\n+        unsigned char auxrnd32a[32], auxrnd32b[32], auxrnd32a_bad[32];\n+        unsigned char sec32a[32], sec32b[32], sec32a_bad[32];\n+        secp256k1_scalar seca, secb;\n+        unsigned char ell64a[64], ell64b[64], ell64a_bad[64];\n+        unsigned char share32a[32], share32b[32], share32_bad[32];\n+        unsigned char prefix64[64];\n+        secp256k1_ellswift_xdh_hash_function hash_function;\n+        void* data;\n+        int ret;\n+\n+        /* Pick hasher to use. */\n+        if ((i % 3) == 0) {\n+            hash_function = ellswift_xdh_hash_x32;\n+            data = NULL;\n+        } else if ((i % 3) == 1) {\n+            hash_function = secp256k1_ellswift_xdh_hash_function_bip324;\n+            data = NULL;\n+        } else {\n+            hash_function = secp256k1_ellswift_xdh_hash_function_prefix;\n+            secp256k1_testrand256_test(prefix64);\n+            secp256k1_testrand256_test(prefix64 + 32);\n+            data = prefix64;\n+        }\n+\n+        /* Generate random secret keys and random randomizers. */\n+        secp256k1_testrand256_test(auxrnd32a);\n+        secp256k1_testrand256_test(auxrnd32b);\n+        random_scalar_order_test(&seca);\n+        random_scalar_order_test(&secb);\n+        secp256k1_scalar_get_b32(sec32a, &seca);\n+        secp256k1_scalar_get_b32(sec32b, &secb);\n+\n+        /* Construct ElligatorSwift-encoded public keys for those keys. */\n+        ret = secp256k1_ellswift_create(CTX, ell64a, sec32a, auxrnd32a);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_create(CTX, ell64b, sec32b, auxrnd32b);\n+        CHECK(ret);\n+\n+        /* Compute the shared secret both ways and compare with each other. */\n+        ret = secp256k1_ellswift_xdh(CTX, share32a, ell64a, ell64b, sec32b, 1, hash_function, data);\n+        CHECK(ret);\n+        ret = secp256k1_ellswift_xdh(CTX, share32b, ell64a, ell64b, sec32a, 0, hash_function, data);",
      "path": "src/modules/ellswift/tests_impl.h",
      "position": null,
      "original_position": 338,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "4860ab0e2246b56469a564d980a1316c5e36fb47",
      "in_reply_to_id": 1233066008,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasnick I don't think it matters, because share32a == share32b thoughout. Still, I've reworked these, and expanded them into performing all mutations on both sides.",
      "created_at": "2023-06-17T17:35:58Z",
      "updated_at": "2023-06-17T17:35:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233099736",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233099736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": 336,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233163031",
      "pull_request_review_id": 1484936885,
      "id": 1233163031,
      "node_id": "PRRC_kwDOAP4Jqs5JgJMX",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - If s=0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 299,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "16d251380fb3e619ff7da0a983735ff78d301307",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "comment nit:\r\n```suggestion\r\n    /* Now m = {-w if c&5=0 or c&5=5; w otherwise}. */\r\n```",
      "created_at": "2023-06-18T00:19:58Z",
      "updated_at": "2023-06-18T00:32:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233163031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233163031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233168982",
      "pull_request_review_id": 1484943804,
      "id": 1233168982,
      "node_id": "PRRC_kwDOAP4Jqs5JgKpW",
      "diff_hunk": "@@ -0,0 +1,542 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - If s=0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 299,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "16d251380fb3e619ff7da0a983735ff78d301307",
      "in_reply_to_id": 1233163031,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-18T01:06:35Z",
      "updated_at": "2023-06-18T01:06:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1233168982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1233168982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1234535396",
      "pull_request_review_id": 1487005600,
      "id": 1234535396,
      "node_id": "PRRC_kwDOAP4Jqs5JlYPk",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 always.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * It is not guaranteed that the computed encoding is stable across versions\n+ * of the library, even if all arguments to this function (including rnd32)\n+ * are the same.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key\n+ *           auxrnd32:   (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrnd32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrnd32 contains 32 uniformly random bytes, though\n+ * it is optional (and does result in encodings that are indistinguishable from\n+ * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrnd32, if provided).\n+ *\n+ * Like secp256k1_ellswift_encode, this function does not guaranteed that the",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 135,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "5e9b62c1a7ec36cf672e3303fcf96e6122322e32",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * Like secp256k1_ellswift_encode, this function does not guarantee that the\r\n```",
      "created_at": "2023-06-19T22:53:06Z",
      "updated_at": "2023-06-19T23:54:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1234535396",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1234535396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1234538622",
      "pull_request_review_id": 1487005600,
      "id": 1234538622,
      "node_id": "PRRC_kwDOAP4Jqs5JlZB-",
      "diff_hunk": "@@ -0,0 +1,107 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+#define SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point[256];\n+    unsigned char rnd64[64];\n+} bench_ellswift_data;\n+\n+static void bench_ellswift_setup(void *arg) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+    static const unsigned char init[64] = {\n+        0x78, 0x1f, 0xb7, 0xd4, 0x67, 0x7f, 0x08, 0x68,\n+        0xdb, 0xe3, 0x1d, 0x7f, 0x1b, 0xb0, 0xf6, 0x9e,\n+        0x0a, 0x64, 0xca, 0x32, 0x9e, 0xc6, 0x20, 0x79,\n+        0x03, 0xf3, 0xd0, 0x46, 0x7a, 0x0f, 0xd2, 0x21,\n+        0xb0, 0x2c, 0x46, 0xd8, 0xba, 0xca, 0x26, 0x4f,\n+        0x8f, 0x8c, 0xd4, 0xdd, 0x2d, 0x04, 0xbe, 0x30,\n+        0x48, 0x51, 0x1e, 0xd4, 0x16, 0xfd, 0x42, 0x85,\n+        0x62, 0xc9, 0x02, 0xf9, 0x89, 0x84, 0xff, 0xdc\n+    };\n+    memcpy(data->rnd64, init, 64);\n+    for (i = 0; i < 256; ++i) {\n+        int j;\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &data->point[i], data->rnd64));\n+        for (j = 0; j < 64; ++j) {\n+            data->rnd64[j] += 1;\n+        }\n+    }\n+    CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[255], init + 16));\n+}\n+\n+static void bench_ellswift_encode(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[i & 255], data->rnd64 + 16));\n+    }\n+}\n+\n+static void bench_ellswift_create(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char buf[64];\n+        CHECK(secp256k1_ellswift_create(data->ctx, buf, data->rnd64, data->rnd64 + 32));\n+        memcpy(data->rnd64, buf, 64);\n+    }\n+}\n+\n+static void bench_ellswift_decode(void *arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    size_t len;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &out, data->rnd64) == 1);\n+        len = 33;\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->rnd64 + (i % 32), &len, &out, SECP256K1_EC_COMPRESSED));\n+    }\n+}\n+\n+static void bench_ellswift_xdh(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        int party = i & 1;\n+        CHECK(secp256k1_ellswift_xdh(data->ctx,\n+                                     data->rnd64 + (i % 33),\n+                                     data->rnd64,\n+                                     data->rnd64,\n+                                     data->rnd64 + ((i + 16) % 33),\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL) == 1);\n+    }\n+}\n+\n+void run_ellswift_bench(int iters, int argc, char **argv) {\n+    bench_ellswift_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with signing capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    memset(data.rnd64, 11, sizeof(data.rnd64));",
      "path": "src/modules/ellswift/bench_impl.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d4ec51cf0f93edce3f73cb9c11799b1db4297481",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems like this can be removed, as the initialization happens in `bench_ellswift_setup`?\r\n```suggestion\r\n```",
      "created_at": "2023-06-19T22:55:15Z",
      "updated_at": "2023-06-19T23:54:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1234538622",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1234538622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235205984",
      "pull_request_review_id": 1488056773,
      "id": 1235205984,
      "node_id": "PRRC_kwDOAP4Jqs5Jn79g",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);\n+        secp256k1_sha256_write(&hash, p64, sizeof(p64));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 427,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230850464,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you overlooked this one. My primary suggestion was to add a call to `memset`, the comment change was rather a by-product thereof.  :)",
      "created_at": "2023-06-20T12:38:57Z",
      "updated_at": "2023-06-20T12:38:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1235205984",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235205984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235437579",
      "pull_request_review_id": 1488428168,
      "id": 1235437579,
      "node_id": "PRRC_kwDOAP4Jqs5Jo0gL",
      "diff_hunk": "@@ -0,0 +1,107 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+#define SECP256K1_MODULE_ELLSWIFT_BENCH_H\n+\n+#include \"../../../include/secp256k1_ellswift.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point[256];\n+    unsigned char rnd64[64];\n+} bench_ellswift_data;\n+\n+static void bench_ellswift_setup(void *arg) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+    static const unsigned char init[64] = {\n+        0x78, 0x1f, 0xb7, 0xd4, 0x67, 0x7f, 0x08, 0x68,\n+        0xdb, 0xe3, 0x1d, 0x7f, 0x1b, 0xb0, 0xf6, 0x9e,\n+        0x0a, 0x64, 0xca, 0x32, 0x9e, 0xc6, 0x20, 0x79,\n+        0x03, 0xf3, 0xd0, 0x46, 0x7a, 0x0f, 0xd2, 0x21,\n+        0xb0, 0x2c, 0x46, 0xd8, 0xba, 0xca, 0x26, 0x4f,\n+        0x8f, 0x8c, 0xd4, 0xdd, 0x2d, 0x04, 0xbe, 0x30,\n+        0x48, 0x51, 0x1e, 0xd4, 0x16, 0xfd, 0x42, 0x85,\n+        0x62, 0xc9, 0x02, 0xf9, 0x89, 0x84, 0xff, 0xdc\n+    };\n+    memcpy(data->rnd64, init, 64);\n+    for (i = 0; i < 256; ++i) {\n+        int j;\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &data->point[i], data->rnd64));\n+        for (j = 0; j < 64; ++j) {\n+            data->rnd64[j] += 1;\n+        }\n+    }\n+    CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[255], init + 16));\n+}\n+\n+static void bench_ellswift_encode(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_encode(data->ctx, data->rnd64, &data->point[i & 255], data->rnd64 + 16));\n+    }\n+}\n+\n+static void bench_ellswift_create(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char buf[64];\n+        CHECK(secp256k1_ellswift_create(data->ctx, buf, data->rnd64, data->rnd64 + 32));\n+        memcpy(data->rnd64, buf, 64);\n+    }\n+}\n+\n+static void bench_ellswift_decode(void *arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    size_t len;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_ellswift_decode(data->ctx, &out, data->rnd64) == 1);\n+        len = 33;\n+        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->rnd64 + (i % 32), &len, &out, SECP256K1_EC_COMPRESSED));\n+    }\n+}\n+\n+static void bench_ellswift_xdh(void *arg, int iters) {\n+    int i;\n+    bench_ellswift_data *data = (bench_ellswift_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        int party = i & 1;\n+        CHECK(secp256k1_ellswift_xdh(data->ctx,\n+                                     data->rnd64 + (i % 33),\n+                                     data->rnd64,\n+                                     data->rnd64,\n+                                     data->rnd64 + ((i + 16) % 33),\n+                                     party,\n+                                     secp256k1_ellswift_xdh_hash_function_bip324,\n+                                     NULL) == 1);\n+    }\n+}\n+\n+void run_ellswift_bench(int iters, int argc, char **argv) {\n+    bench_ellswift_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with signing capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    memset(data.rnd64, 11, sizeof(data.rnd64));",
      "path": "src/modules/ellswift/bench_impl.h",
      "position": null,
      "original_position": 97,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d4ec51cf0f93edce3f73cb9c11799b1db4297481",
      "in_reply_to_id": 1234538622,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-20T15:24:34Z",
      "updated_at": "2023-06-20T15:24:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1235437579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235437579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235437763",
      "pull_request_review_id": 1488428430,
      "id": 1235437763,
      "node_id": "PRRC_kwDOAP4Jqs5Jo0jD",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+  unsigned char *output,\n+  const unsigned char *x32,\n+  const unsigned char *ell_a64,\n+  const unsigned char *ell_b64,\n+  void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 always.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * It is not guaranteed that the computed encoding is stable across versions\n+ * of the library, even if all arguments to this function (including rnd32)\n+ * are the same.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key\n+ *           auxrnd32:   (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrnd32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrnd32 contains 32 uniformly random bytes, though\n+ * it is optional (and does result in encodings that are indistinguishable from\n+ * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrnd32, if provided).\n+ *\n+ * Like secp256k1_ellswift_encode, this function does not guaranteed that the",
      "path": "include/secp256k1_ellswift.h",
      "position": null,
      "original_position": 135,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "5e9b62c1a7ec36cf672e3303fcf96e6122322e32",
      "in_reply_to_id": 1234535396,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-20T15:24:43Z",
      "updated_at": "2023-06-20T15:24:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1235437763",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235437763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235438396",
      "pull_request_review_id": 1488429367,
      "id": 1235438396,
      "node_id": "PRRC_kwDOAP4Jqs5Jo0s8",
      "diff_hunk": "@@ -0,0 +1,586 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+#define SECP256K1_MODULE_ELLSWIFT_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellswift.h\"\n+#include \"../../hash.h\"\n+\n+/** c1 = (sqrt(-3)-1)/2 */\n+static const secp256k1_fe secp256k1_ellswift_c1 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/** c2 = (-sqrt(-3)-1)/2 = -(c1+1) */\n+static const secp256k1_fe secp256k1_ellswift_c2 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/** c3 = (-sqrt(-3)+1)/2 = -c1 = c2+1 */\n+static const secp256k1_fe secp256k1_ellswift_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ef);\n+/** c4 = (sqrt(-3)+1)/2 = -c2 = c1+1 */\n+static const secp256k1_fe secp256k1_ellswift_c4 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa41);\n+\n+/** Decode ElligatorSwift encoding (u, t) to a fraction xn/xd representing a curve X coordinate. */\n+static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    /* The implemented algorithm is the following (all operations in GF(p)):\n+     *\n+     * - c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - If u^3+7+t^2 = 0, set t=2*t.\n+     * - Let X=(u^3+7-t^2)/(2*t)\n+     * - Let Y=(X+t)/(c0*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return x2.\n+     * - Return x1=(X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).\n+     *\n+     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:\n+     *\n+     * - Let c0 = ...\n+     * - If u=0, set u=1.\n+     * - If t=0, set t=1.\n+     * - Let s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set t=2*t, s=4*s\n+     * - Let X=(g-s)/(2*t)\n+     * - Let Y=(X+t)/(c0*u) = (g+s)/(2*c0*t*u)\n+     * - If x3=u+4*Y^2 is a valid x coordinate, return x3.\n+     * - If x2=(-X/Y-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This\n+     * means X and Y do not need to be evaluated explicitly anymore.\n+     *\n+     * - ...\n+     * - If g+s=0, set s=4*s\n+     * - If x3=u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=(-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u).\n+     *\n+     * Simplifying x2 using 2 additional constants:\n+     *\n+     * - c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - ...\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - ...\n+     *\n+     * Writing x3 as a fraction:\n+     *\n+     * - ...\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2)\n+     * - ...\n+\n+     * Overall, we get:\n+     *\n+     * - c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40\n+     * - c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\n+     * - If u=0, set u=1.\n+     * - If t=0, set s=1, else set s=t^2\n+     * - Let g=u^3+7\n+     * - If g+s=0, set s=4*s\n+     * - If x3=(3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.\n+     * - If x2=u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.\n+     * - Return x1=-(x2+u)\n+     */\n+    secp256k1_fe u1, s, g, p, d, n, l;\n+    u1 = *u;\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&s, t);\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;\n+    secp256k1_fe_sqr(&l, &u1); /* l = u^2 */\n+    secp256k1_fe_mul(&g, &l, &u1); /* g = u^3 */\n+    secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3 + 7 */\n+    p = g; /* p = g */\n+    secp256k1_fe_add(&p, &s); /* p = g+s */\n+    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {\n+        secp256k1_fe_mul_int(&s, 4); /* s = 4*s */\n+        /* recompute p = g+s */\n+        p = g; /* p = g */\n+        secp256k1_fe_add(&p, &s); /* p = g+s */\n+    }\n+    secp256k1_fe_mul(&d, &s, &l); /* d = s*u^2 */\n+    secp256k1_fe_mul_int(&d, 3); /* d = 3*s*u^2 */\n+    secp256k1_fe_sqr(&l, &p); /* l = (g+s)^2 */\n+    secp256k1_fe_negate(&l, &l, 1); /* l = -(g+s)^2 */\n+    secp256k1_fe_mul(&n, &d, &u1); /* n = 3*s*u^3 */\n+    secp256k1_fe_add(&n, &l); /* n = 3*s*u^3-(g+s)^2 */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {\n+        /* Return n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */\n+        *xn = n;\n+        *xd = d;\n+        return;\n+    }\n+    *xd = p;\n+    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s); /* l = c1*s */\n+    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g); /* n = c2*g */\n+    secp256k1_fe_add(&n, &l); /* n = c1*s+c2*g */\n+    secp256k1_fe_mul(&n, &n, &u1); /* n = u*(c1*s+c2*g) */\n+    /* Possible optimization: in the invocation below, d^2 = (g+s)^2 is computed,\n+     * which we already have computed above. This could be deduplicated. */\n+    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {\n+        /* Return n/p = u*(c1*s+c2*g)/(g+s) */\n+        *xn = n;\n+        return;\n+    }\n+    secp256k1_fe_mul(&l, &p, &u1); /* l = u*(g+s) */\n+    secp256k1_fe_add(&n, &l); /* n = u*(c1*s+c2*g)+u*(g+s) */\n+    secp256k1_fe_negate(xn, &n, 2); /* n = -u*(c1*s+c2*g)-u*(g+s) */\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));\n+#endif\n+    /* Return n/p = -(u*(c1*s+c2*g)/(g+s)+u) */\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to X coordinate. */\n+static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe xn, xd;\n+    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);\n+    secp256k1_fe_inv_var(&xd, &xd);\n+    secp256k1_fe_mul(x, &xn, &xd);\n+}\n+\n+/** Decode ElligatorSwift encoding (u, t) to point P. */\n+static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {\n+    secp256k1_fe x;\n+    secp256k1_ellswift_xswiftec_var(&x, u, t);\n+    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));\n+}\n+\n+/* Try to complete an ElligatorSwift encoding (u, t) for X coordinate x, given u and x.\n+ *\n+ * There may be up to 8 distinct t values such that (u, t) decodes back to x, but also\n+ * fewer, or none at all. Each such partial inverse can be accessed individually using a\n+ * distinct input argument c (in range 0-7), and some or all of these may return failure.\n+ * The following guarantees exist:\n+ * - Given (x, u), no two distinct c values give the same successful result t.\n+ * - Every successful result maps back to x through secp256k1_ellswift_xswiftec_var.\n+ * - Given (x, u), all t values that map back to x can be reached by combining the\n+ *   successful results from this function over all c values, with the exception of:\n+ *   - this function cannot be called with u=0\n+ *   - no result with t=0 will be returned\n+ *   - no result for which u^3 + t^2 + 7 = 0 will be returned.\n+ *\n+ * The rather unusual encoding of bits in c (a large \"if\" based on the middle bit, and then\n+ * using the low and high bits to pick signs of square roots) is to match the paper's\n+ * encoding more closely: c=0 through c=3 match branches 1..4 in the paper, while c=4 through\n+ * c=7 are copies of those with an additional negation of sqrt(w).\n+ */\n+static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {\n+    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):\n+     *\n+     * - If (c & 2) = 0:\n+     *   - If (-x-u) is a valid X coordinate, fail.\n+     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).\n+     *   - If s is not square, fail.\n+     *   - Let v=x.\n+     * - If (c & 2) = 2:\n+     *   - Let s=x-u.\n+     *   - If s=0, fail.\n+     *   - If s is not square, fail.\n+     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.\n+     *   - If (c & 1) = 1 and r = 0, fail.\n+     *   - Let v=(r/s-u)/2.\n+     * - Let w=sqrt(s).\n+     * - If (c & 5) = 0: return -w*(c3*u + v)\n+     * - If (c & 5) = 1: return  w*(c4*u + v)\n+     * - If (c & 5) = 4: return  w*(c3*u + v)\n+     * - If (c & 5) = 5: return -w*(c4*u + v)\n+     */\n+    secp256k1_fe x = *x_in, u = *u_in, u2, g, v, s, m, r, q;\n+    int ret;\n+\n+    secp256k1_fe_normalize_weak(&x);\n+    secp256k1_fe_normalize_weak(&u);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(c >= 0 && c < 8);\n+    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));\n+#endif\n+\n+    if (!(c & 2)) {\n+        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or\n+         * c=4) formula, or x2 (if c=1 or c=5) formula. */\n+\n+        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips\n+         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding\n+         * would not match x). */\n+        m = x; /* m = x */\n+        secp256k1_fe_add(&m, &u); /* m = u+x */\n+        secp256k1_fe_negate(&m, &m, 2); /* m = -u-x */\n+        /* test if (-u-x) is a valid X coordinate. If so, fail. */\n+        if (secp256k1_ge_x_on_curve_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */\n+        secp256k1_fe_sqr(&s, &m); /* s = (u+x)^2 */\n+        secp256k1_fe_negate(&s, &s, 1); /* s= -(u+x)^2 */\n+        secp256k1_fe_mul(&m, &u, &x); /* m = u*x */\n+        secp256k1_fe_add(&s, &m); /* s = -(u^2 + u*x + x^2) */\n+\n+        /* Note that at this point, s=0 is impossible. If it were the case:\n+         *    s = -(u^2 + u*x + x^2) = 0.\n+         * => u^2 + u*x + x^2 = 0\n+         * => (u + 2*x) * (u^2 + u*x + x^2) = 0\n+         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0\n+         * => (x + u)^3 + x^3 = 0\n+         * => x^3 = -(x + u)^3\n+         * => x^3 + B = (-u - x)^3 + B\n+         *\n+         * However, We know x^3 + B is square (because x is on the curve) and\n+         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)\n+         * test above would have failed). This is a contradiction, and thus the\n+         * assumption s=0 is false. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));\n+#endif\n+\n+        /* If s is not square, fail. We have not fully computed s yet, but s is square iff\n+         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is\n+         * nonzero). */\n+        secp256k1_fe_sqr(&g, &u); /* g = u^2 */\n+        secp256k1_fe_mul(&g, &g, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_mul(&m, &s, &g); /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */\n+        if (!secp256k1_fe_is_square_var(&m)) return 0;\n+\n+        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */\n+        secp256k1_fe_inv_var(&s, &s); /* s = -1/(u^2 + u*x + x^2) [cannot be div by 0] */\n+        secp256k1_fe_mul(&s, &s, &g); /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */\n+\n+        /* Let v = x. */\n+        v = x;\n+    } else {\n+        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */\n+\n+        /* Let s = x-u. */\n+        secp256k1_fe_negate(&m, &u, 1); /* m = -u */\n+        s = m; /* s = -u */\n+        secp256k1_fe_add(&s, &x); /* s = x-u */\n+\n+        /* If s is not square, fail. */\n+        if (!secp256k1_fe_is_square_var(&s)) return 0;\n+\n+        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */\n+        secp256k1_fe_sqr(&u2, &u); /* u2 = u^2 */\n+        secp256k1_fe_mul(&g, &u2, &u); /* g = u^3 */\n+        secp256k1_fe_add_int(&g, SECP256K1_B); /* g = u^3+7 */\n+        secp256k1_fe_normalize_weak(&g);\n+        secp256k1_fe_mul_int(&g, 4); /* g = 4*(u^3+7) */\n+        secp256k1_fe_mul_int(&u2, 3); /* u2 = 3*u^2 */\n+        secp256k1_fe_mul(&q, &s, &u2); /* q = 3*s*u^2 */\n+        secp256k1_fe_add(&q, &g); /* q = 4*(u^3+7)+3*s*u^2 */\n+        secp256k1_fe_mul(&q, &q, &s); /* q = s*(4*(u^3+7)+3*u^2*s) */\n+        secp256k1_fe_negate(&q, &q, 1); /* q = -s*(4*(u^3+7)+3*u^2*s) */\n+        if (!secp256k1_fe_is_square_var(&q)) return 0;\n+        ret = secp256k1_fe_sqrt(&r, &q); /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */\n+        VERIFY_CHECK(ret);\n+\n+        /* If (c & 1) = 1 and r = 0, fail. */\n+        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;\n+\n+        /* If s=0, fail. */\n+        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;\n+\n+        /* Let v=(r/s-u)/2. */\n+        secp256k1_fe_inv_var(&v, &s); /* v=1/s [cannot be div by 0] */\n+        secp256k1_fe_mul(&v, &v, &r); /* v=r/s */\n+        secp256k1_fe_add(&v, &m); /* v=r/s-u */\n+        secp256k1_fe_half(&v); /* v=(r/s-u)/2 */\n+    }\n+\n+    /* Let w=sqrt(s). */\n+    ret = secp256k1_fe_sqrt(&m, &s); /* m = sqrt(s) = w */\n+    VERIFY_CHECK(ret);\n+\n+    /* Return logic. */\n+    if ((c & 5) == 0 || (c & 5) == 5) {\n+        secp256k1_fe_negate(&m, &m, 1); /* m = -w */\n+    }\n+    /* Now m = {w if c&5=0 or c&5=5; -w otherwise}. */\n+    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);\n+    /* u = {c4 if c&1=1; c3 otherwise}*u */\n+    secp256k1_fe_add(&u, &v); /* u = {c4 if c&1=1; c3 otherwise}*u + v */\n+    secp256k1_fe_mul(t, &m, &u);\n+    return 1;\n+}\n+\n+/** Use SHA256 as a PRNG, returning SHA256(hasher || cnt).\n+ *\n+ * hasher is a SHA256 object which a incrementing 4-byte counter is added to generate randomness.\n+ * Adding 13 bytes (4 bytes for counter, plus 9 bytes for the SHA256 padding) cannot cross a\n+ * 64-byte block size boundary (to make sure it only triggers a single SHA256 compression). */\n+static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {\n+    secp256k1_sha256 hash = *hasher;\n+    unsigned char buf4[4];\n+#ifdef VERIFY\n+    size_t blocks = hash.bytes >> 6;\n+#endif\n+    buf4[0] = cnt;\n+    buf4[1] = cnt >> 8;\n+    buf4[2] = cnt >> 16;\n+    buf4[3] = cnt >> 24;\n+    secp256k1_sha256_write(&hash, buf4, 4);\n+    secp256k1_sha256_finalize(&hash, out32);\n+#ifdef VERIFY\n+    /* Writing and finalizing together should trigger exactly one SHA256 compression. */\n+    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));\n+#endif\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for X coordinate x, and random Y coordinate.\n+ *\n+ * u32 is the 32-byte big endian encoding of u; t is the output field element t that still\n+ * needs encoding.\n+ *\n+ * hasher is a hasher in the secp256k1_ellswift_prng sense, with the same restrictions. */\n+static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {\n+    /* Pool of 3-bit branch values. */\n+    unsigned char branch_hash[32];\n+    /* Number of 3-bit values in branch_hash left. */\n+    int branches_left = 0;\n+    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive\n+     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64\n+     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples\n+     * thereof) are used to repopulate the pool and start over, if that were ever necessary.\n+     * On average, 4 iterations are needed. */\n+    uint32_t cnt = 0;\n+    while (1) {\n+        int branch;\n+        secp256k1_fe u;\n+        /* If the pool of branch values is empty, populate it. */\n+        if (branches_left == 0) {\n+            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);\n+            branches_left = 64;\n+        }\n+        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */\n+        --branches_left;\n+        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;\n+        /* Compute a new u value by hashing. */\n+        secp256k1_ellswift_prng(u32, hasher, cnt++);\n+        /* overflow is not a problem (we prefer uniform u32 over uniform u). */\n+        secp256k1_fe_set_b32_mod(&u, u32);\n+        /* Since u is the output of a hash, it should practically never be 0. We could apply the\n+         * u=0 to u=1 correction here too to deal with that case still, but it's such a low\n+         * probability event that we do not bother. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));\n+#endif\n+        /* Find a remainder t, and return it if found. */\n+        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;\n+    }\n+}\n+\n+/** Find an ElligatorSwift encoding (u, t) for point P.\n+ *\n+ * This is similar secp256k1_ellswift_xelligatorswift_var, except it takes a full group element p\n+ * as input, and returns an encoding that matches the provided Y coordinate rather than a random\n+ * one.\n+ */\n+static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {\n+    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);\n+    secp256k1_fe_normalize_var(t);\n+    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {\n+        secp256k1_fe_negate(t, t, 1);\n+        secp256k1_fe_normalize_var(t);\n+    }\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"secp256k1_ellswift_encode\". */\n+static void secp256k1_ellswift_sha256_init_encode(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd1a6524bul;\n+    hash->s[1] = 0x028594b3ul;\n+    hash->s[2] = 0x96e42f4eul;\n+    hash->s[3] = 0x1037a177ul;\n+    hash->s[4] = 0x1b8fcb8bul;\n+    hash->s[5] = 0x56023885ul;\n+    hash->s[6] = 0x2560ede1ul;\n+    hash->s[7] = 0xd626b715ul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_ellswift_encode(const secp256k1_context *ctx, unsigned char *ell64, const secp256k1_pubkey *pubkey, const unsigned char *rnd32) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        secp256k1_fe t;\n+        unsigned char p64[64] = {0};\n+        secp256k1_sha256 hash;\n+\n+        /* Set up hasher state; the used RNG is H(pubkey || \"\\x00\"*31 || rnd32 || cnt++), using BIP340 tagged\n+         * hash with tag \"secp256k1_ellswift_encode\". */\n+        secp256k1_ellswift_sha256_init_encode(&hash);\n+        p64[0] = 0x02 ^ secp256k1_fe_is_odd(&p.y);\n+        secp256k1_fe_get_b32(p64 + 1, &p.x);\n+        secp256k1_sha256_write(&hash, p64, sizeof(p64));\n+        secp256k1_sha256_write(&hash, rnd32, 32);\n+\n+        /* Compute ElligatorSwift encoding and construct output. */\n+        secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */\n+        secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */",
      "path": "src/modules/ellswift/main_impl.h",
      "position": null,
      "original_position": 427,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "d710e6b9002a6e85e44c55a34410f4716994b559",
      "in_reply_to_id": 1230850464,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-20T15:25:12Z",
      "updated_at": "2023-06-20T15:25:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1235438396",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235438396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1236523397",
      "pull_request_review_id": 1489988983,
      "id": 1236523397,
      "node_id": "PRRC_kwDOAP4Jqs5Js9mF",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+#ifndef SECP256K1_ELLSWIFT_H\n+#define SECP256K1_ELLSWIFT_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of ElligatorSwift as well as a\n+ * version of x-only ECDH using it.\n+ *\n+ * ElligatorSwift is described in https://eprint.iacr.org/2022/759 by\n+ * Chavez-Saab, Rodriguez-Henriquez, and Tibouchi. It permits encoding\n+ * uniformly chosen public keys as 64-byte arrays which are indistinguishable\n+ * from uniformly random arrays.\n+ *\n+ * Let f be the function from pairs of field elements to point X coordinates,\n+ * defined as follows (all operations modulo p = 2^256 - 2^32 - 977)\n+ * f(u,t):\n+ * - Let C = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852,\n+ *   a square root of -3.\n+ * - If u=0, set u=1 instead.\n+ * - If t=0, set t=1 instead.\n+ * - If u^3 + t^2 + 7 = 0, multiply t by 2.\n+ * - Let X = (u^3 + 7 - t^2) / (2 * t)\n+ * - Let Y = (X + t) / (C * u)\n+ * - Return the first in [u + 4 * Y^2, (-X/Y - u) / 2, (X/Y - u) / 2] that is an\n+ *   X coordinate on the curve (at least one of them is, for any u and t).\n+ *\n+ * Then an ElligatorSwift encoding of x consists of the 32-byte big-endian\n+ * encodings of field elements u and t concatenated, where f(u,t) = x.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u,t) among those which encode x.\n+ *\n+ * If the Y coordinate is relevant, it is given the same parity as t.\n+ *\n+ * Changes w.r.t. the the paper:\n+ * - The u=0, t=0, and u^3+t^2+7=0 conditions result in decoding to the point\n+ *   at infinity in the paper. Here they are remapped to finite points.\n+ * - The paper uses an additional encoding bit for the parity of y. Here the\n+ *   parity of t is used (negating t does not affect the decoded x coordinate,\n+ *   so this is possible).\n+ */\n+\n+/** A pointer to a function used by secp256k1_ellswift_xdh to hash the shared X\n+ *  coordinate along with the encoded public keys to a uniform shared secret.\n+ *\n+ *  Returns: 1 if a shared secret was successfully computed.\n+ *           0 will cause secp256k1_ellswift_xdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ellswift_xdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to the 32-byte serialized X coordinate\n+ *                       of the resulting shared point (will not be NULL)\n+ *           ell_a64:    pointer to the 64-byte encoded public key of party A\n+ *                       (will not be NULL)\n+ *           ell_b64:    pointer to the 64-byte encoded public key of party B\n+ *                       (will not be NULL)\n+ *           data:       arbitrary data pointer that is passed through\n+ */\n+typedef int (*secp256k1_ellswift_xdh_hash_function)(\n+    unsigned char *output,\n+    const unsigned char *x32,\n+    const unsigned char *ell_a64,\n+    const unsigned char *ell_b64,\n+    void *data\n+);\n+\n+/** Construct a 64-byte ElligatorSwift encoding of a given pubkey.\n+ *\n+ *  Returns: 1 always.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *           rnd32:      pointer to 32 bytes of randomness\n+ *\n+ * It is recommended that rnd32 consists of 32 uniformly random bytes, not\n+ * known to any adversary trying to detect whether public keys are being\n+ * encoded, though 16 bytes of randomness (padded to an array of 32 bytes,\n+ * e.g., with zeros) suffice to make the result indistinguishable from\n+ * uniform. The randomness in rnd32 must not be a deterministic function of\n+ * the pubkey (it can be derived from the private key, though).\n+ *\n+ * It is not guaranteed that the computed encoding is stable across versions\n+ * of the library, even if all arguments to this function (including rnd32)\n+ * are the same.\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_encode(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *rnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes ElligatorSwift encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellswift_decode(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute an ElligatorSwift public key for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, public key was stored.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to receive the ElligatorSwift\n+ *                       public key\n+ *  In:      seckey32:   pointer to a 32-byte secret key\n+ *           auxrnd32:   (optional) pointer to 32 bytes of randomness\n+ *\n+ * Constant time in seckey and auxrnd32, but not in the resulting public key.\n+ *\n+ * It is recommended that auxrnd32 contains 32 uniformly random bytes, though\n+ * it is optional (and does result in encodings that are indistinguishable from\n+ * uniform even without any auxrnd32). It differs from the (mandatory) rnd32\n+ * argument to secp256k1_ellswift_encode in this regard.\n+ *\n+ * This function can be used instead of calling secp256k1_ec_pubkey_create\n+ * followed by secp256k1_ellswift_encode. It is safer, as it uses the secret\n+ * key as entropy for the encoding (supplemented with auxrnd32, if provided).\n+ *\n+ * Like secp256k1_ellswift_encode, this function does not guarantee that the\n+ * computed encoding is stable across versions of the library, even if all\n+ * arguments (including auxrnd32) are the same.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ellswift_create(\n+    const secp256k1_context *ctx,\n+    unsigned char *ell64,\n+    const unsigned char *seckey32,\n+    const unsigned char *auxrnd32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Given a private key, and ElligatorSwift public keys sent in both directions,\n+ *  compute a shared secret using x-only Elliptic Curve Diffie-Hellman (ECDH).\n+ *\n+ *  Returns: 1: shared secret was succesfully computed",
      "path": "include/secp256k1_ellswift.h",
      "position": 162,
      "original_position": 149,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "c47917bbd62c488fb168431169c1ffe780562da1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Returns: 1: shared secret was successfully computed\r\n```",
      "created_at": "2023-06-21T07:44:50Z",
      "updated_at": "2023-06-23T18:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1236523397",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1236523397"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238555762",
      "pull_request_review_id": 1489988983,
      "id": 1238555762,
      "node_id": "PRRC_kwDOAP4Jqs5J0txy",
      "diff_hunk": "@@ -0,0 +1,483 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0",
      "path": "doc/ellswift.md",
      "position": 91,
      "original_position": 91,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "swiftEC paper shows this:\r\n$\\dfrac{g(u) + h(u)(Y_0(u) - X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)}$",
      "created_at": "2023-06-22T13:45:26Z",
      "updated_at": "2023-06-23T18:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1238555762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238555762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238577607",
      "pull_request_review_id": 1489988983,
      "id": 1238577607,
      "node_id": "PRRC_kwDOAP4Jqs5J0zHH",
      "diff_hunk": "@@ -0,0 +1,483 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)",
      "path": "doc/ellswift.md",
      "position": 164,
      "original_position": 164,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "~~tried using WolframAlpha(my first time) for this condition - [link](https://www.wolframalpha.com/input?i=solve%28%7Bx+%3D+%28g+%2B+h*%28y0+-+x0*t%29%5E2%29%2F%28x0*%281+%2B+h*t%5E2%29%29%2C+y+%3D+y0+%2B+t*%28x+-+x0%29%2C+g+%3D+x%5E3+%2B+a*x+%2B+b%2C+h+%3D+3*x%5E3+%2B+4*a%7D%2C%7Bt%7D%29).~~\r\n\r\nEDIT: sorry for the spam! got it when i plugged in the right equation.",
      "created_at": "2023-06-22T14:00:37Z",
      "updated_at": "2023-06-27T18:49:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1238577607",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238577607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 164,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1239903278",
      "pull_request_review_id": 1489988983,
      "id": 1239903278,
      "node_id": "PRRC_kwDOAP4Jqs5J52wu",
      "diff_hunk": "@@ -0,0 +1,483 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any order which does not place $x_3$ first requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2)$ (four solutions).\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. A division by 0 in the first branch in fact cannot occur at all, because $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs.\n+For cryptographically sized fields, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targeted uniformly by the\n+    encoder anyway as there will generally be more than 8.\n+  * When $g(x) = 0$, the same $t$ would be produced as in the $x_3$ branch (where $c \\in \\\\{2, 3, 6, 7\\\\}$) which we give precedence\n+    as it can deal with $g(u)=0$.\n+    This is again only possible on even-ordered curves.\n+* In the branch for $x_3$ (where $c \\in \\\\{2, 3, 6, 7\\\\}$):\n+  * When $s=0$, a division by zero would occur.\n+  * When $v = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.\n+    It is equivalent to checking whether $r=0$.\n+    This cannot occur in the $x_1$ or $x_2$ branches, as it would trigger the $g(-u-x)$ is square condition.\n+    A similar concern for $w = -w$ does not exist, as $w=0$ is already impossible in both branches: in the first\n+    it requires $g(u)=0$ which is already outlawed on even-ordered curves and impossible on others; in the second it would trigger division by zero.\n+* Curve-specific special cases also exist that need to be rejected, because they result in $(u,t)$ which is invalid to the decoder, or because of division by zero in the encoder:\n+  * For $a=0$ curves, when $u=0$ or when $t=0$. The latter can only be reached by the encoder when $g(u)=0$, which requires an even-ordered curve.\n+  * For $a \\neq 0$ curves, when $X_0(u)=0$, when $h(u)t^2 = -1$, or when $2w(u + 2v) = 2X_0(u)$ while also either $w \\neq 2Y_0(u)$ or $h(u)=0$.\n+\n+**Define** a version of $G_{c,u}(x)$ which deals with all these cases:\n+* If $a=0$ and $u=0$, return $\\bot.$\n+* If $a \\neq 0$ and $X_0(u)=0$, return $\\bot.$\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(u) = 0$ or $g(x) = 0$, return $\\bot$ (even curves only).\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a)$ (cannot cause division by zero).\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\n+  * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\n+  * If $s = 0$, return $\\bot.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\n+* If $a \\neq 0$ and $w(u+2v) = 2X_0(u)$ and either $w \\neq 2Y_0(u)$ or $h(u) = 0$, return $\\bot.$",
      "path": "doc/ellswift.md",
      "position": 349,
      "original_position": 349,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "~~(from L332 actually) how does this happen? (when Y = 0 in x1, x2 computation or something else?)~~\r\n\r\nEDIT: L332 needs to be updated to $w(u+2v) = 2X_0(u)$. (this happens when  X = X0)",
      "created_at": "2023-06-23T14:38:49Z",
      "updated_at": "2023-06-27T19:36:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1239903278",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1239903278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 349,
      "original_line": 349,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240132878",
      "pull_request_review_id": 1489988983,
      "id": 1240132878,
      "node_id": "PRRC_kwDOAP4Jqs5J6u0O",
      "diff_hunk": "@@ -0,0 +1,483 @@\n+# ElligatorSwift for secp256k1 explained\n+\n+In this document we explain how the `ellswift` module implementation is related to the\n+construction in the\n+[\"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves\"](https://eprint.iacr.org/2022/759)\n+paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.\n+\n+* [1. Introduction](#1-introduction)\n+* [2. The decoding function](#2-the-decoding-function)\n+  + [2.1 Decoding for `secp256k1`](#21-decoding-for-secp256k1)\n+* [3. The encoding function](#3-the-encoding-function)\n+  + [3.1 Switching to *v, w* coordinates](#31-switching-to-v-w-coordinates)\n+  + [3.2 Avoiding computing all inverses](#32-avoiding-computing-all-inverses)\n+  + [3.3 Finding the inverse](#33-finding-the-inverse)\n+  + [3.4 Dealing with special cases](#34-dealing-with-special-cases)\n+  + [3.5 Encoding for `secp256k1`](#35-encoding-for-secp256k1)\n+* [4. Encoding and decoding full *(x, y)* coordinates](#4-encoding-and-decoding-full-x-y-coordinates)\n+  + [4.1 Full *(x, y)* coordinates for `secp256k1`](#41-full-x-y-coordinates-for-secp256k1)\n+\n+## 1. Introduction\n+\n+The `ellswift` module effectively introduces a new 64-byte public key format, with the property\n+that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally\n+indistinguishable from uniform byte arrays. The module provides functions to convert public keys\n+from and to this format, as well as convenience functions for key generation and ECDH that operate\n+directly on ellswift-encoded keys.\n+\n+The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$\n+and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on\n+the curve.\n+\n+**Decoding** consists of decoding the field elements $u$ and $t$ (values above the field size $p$\n+are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid\n+x-coordinate on the curve. The functions $F_u$ will be defined in [Section 2](#2-the-decoding-function).\n+\n+**Encoding** a given $x$ coordinate is conceptually done as follows:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to *8* elements.\n+  * With probability $1 - \\dfrac{\\\\#L}{8}$, restart the loop.\n+  * Select a uniformly random $t \\in L$ and return $(u, t).$\n+\n+This is the *ElligatorSwift* algorithm, here given for just x-coordinates. An extension to full\n+$(x, y)$ points will be given in [Section 4](#4-encoding-and-decoding-full-x-y-coordinates).\n+The algorithm finds a uniformly random $(u, t)$ among (almost all) those\n+for which $F_u(t) = x.$ Section 3.2 in the paper proves that the number of such encodings for\n+almost all x-coordinates on the curve (all but at most 39) is close to two times the field size\n+(specifically, it lies in the range $2q \\pm (22\\sqrt{q} + O(1))$, where $q$ is the size of the field).\n+\n+## 2. The decoding function\n+\n+First some definitions:\n+* $\\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \\equiv 1 \\mod 3.$\n+  * For `secp256k1`, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.\n+* Let $E$ be the elliptic curve of points $(x, y) \\in \\mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$\n+  public constants, for which $\\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \\pm \\sqrt{-3 \\Delta_E} / 36)/2$ is a square.\n+  This implies that the order of $E$ is either odd, or a multiple of *4*.\n+  If $a=0$, this condition is always fulfilled.\n+  * For `secp256k1`, $a=0$ and $b=7.$\n+* Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$\n+* Let the function $h(x) = 3x^3 + 4a.$\n+* Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$\n+* Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \\neq 0.$\n+* $P_u$ is a function from $\\mathbb{F}$ to $S_u$ that will be defined below.\n+* $\\psi_u$ is a function from $S_u$ to $V$ that will be defined below.\n+\n+**Note**: In the paper:\n+* $F_u$ corresponds to $F_{0,u}$ there.\n+* $P_u(t)$ is called $P$ there.\n+* All $S_u$ sets together correspond to $S$ there.\n+* All $\\psi_u$ functions together (operating on elements of $S$) correspond to $\\psi$ there.\n+\n+Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right\n+hand must also be square. As multiplying non-squares results in a square in $\\mathbb{F}$,\n+out of the three right-hand side factors an even number must be non-squares.\n+This implies that exactly *1* or exactly *3* out of\n+$\\\\{g(x_1), g(x_2), g(x_3)\\\\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \\in V$,\n+at least one of $\\\\{x_1, x_2, x_3\\\\}$ must be a valid x-coordinate on $E.$ There is one exception\n+to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.\n+\n+**Define** the decoding function $F_u(t)$ as:\n+* Let $(x_1, x_2, x_3, z) = \\psi_u(P_u(t)).$\n+* Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).\n+\n+$P_u(t) = (X(u, t), Y(u, t))$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+X(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{g(u) - t^2}{2t} & a = 0 \\\\\n+  \\dfrac{g(u) + h(u)(Y_0(u) + X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} & a \\neq 0\n+\\end{array}\\right. \\\\\n+Y(u, t) & = & \\left\\\\{\\begin{array}{ll}\n+  \\dfrac{X(u, t) + t}{u \\sqrt{-3}} = \\dfrac{g(u) + t^2}{2tu\\sqrt{-3}} & a = 0 \\\\\n+  Y_0(u) + t(X(u, t) - X_0(u)) & a \\neq 0\n+\\end{array}\\right.\n+\\end{array}\n+$$\n+\n+$P_u(t)$ is defined:\n+* For $a=0$, unless:\n+  * $u = 0$ or $t = 0$ (division by zero)\n+  * $g(u) = -t^2$ (would give $Y=0$).\n+* For $a \\neq 0$, unless:\n+  * $X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)\n+  * $Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).\n+\n+The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$\n+\n+The function $\\psi_u$ is the same for all curves: $\\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & \\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_2 & = & -\\dfrac{X}{2Y} - \\dfrac{u}{2} && \\\\\n+  x_3 & = & u + 4Y^2 && \\\\\n+  z   & = & \\dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \\dfrac{-g(u)g(x_3)}{8Y^3}\n+\\end{array}\n+$$\n+\n+### 2.1 Decoding for `secp256k1`\n+\n+Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:\n+\n+**Define** $F_u(t)$ as:\n+* Let $X = \\dfrac{u^3 + b - t^2}{2t}.$\n+* Let $Y = \\dfrac{X + t}{u\\sqrt{-3}}.$\n+* Return the first $x$ in $(u + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u}{2}, \\dfrac{X}{2Y} - \\dfrac{u}{2})$ for which $g(x)$ is square.\n+\n+To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case\n+$P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):\n+\n+**Define** $F_u(t)$ as:\n+* Let $u'=u$ if $u \\neq 0$; $1$ otherwise (guaranteeing $u' \\neq 0$).\n+* Let $t'=t$ if $t \\neq 0$; $1$ otherwise (guaranteeing $t' \\neq 0$).\n+* Let $t''=t'$ if $g(u') \\neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \\neq 0$ and $g(u') \\neq -t''^2$).\n+* Let $X = \\dfrac{u'^3 + b - t''^2}{2t''}.$\n+* Let $Y = \\dfrac{X + t''}{u'\\sqrt{-3}}.$\n+* Return the first $x$ in $(u' + 4Y^2, \\dfrac{-X}{2Y} - \\dfrac{u'}{2}, \\dfrac{X}{2Y} - \\dfrac{u'}{2})$ for which $x^3 + b$ is square.\n+\n+The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice,\n+but the approach here is simple enough and gives fairly uniform output even in these cases.\n+\n+**Note**: in the paper these conditions result in $\\infty$ as output, due to the use of projective coordinates there.\n+We wish to avoid the need for callers to deal with this special case.\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_frac_var` (which decodes to an x-coordinate represented as a fraction), and\n+in `secp256k1_ellswift_xswiftec_var` (which outputs the actual x-coordinate).\n+\n+## 3. The encoding function\n+\n+To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:\n+* Find all the $(X, Y) \\in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\\psi_u.$\n+* Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$\n+* For each of the found $t$ values, verify that $F_u(t) = x.$\n+* Return the remaining $t$ values.\n+\n+The function $P_u^{-1}$, which finds $t$ given $(X, Y) \\in S_u$, is significantly simpler than $P_u:$\n+\n+$$\n+P_u^{-1}(X, Y) = \\left\\\\{\\begin{array}{ll}\n+Yu\\sqrt{-3} - X & a = 0 \\\\\n+\\dfrac{Y-Y_0(u)}{X-X_0(u)} & a \\neq 0 \\land X \\neq X_0(u) \\\\\n+\\dfrac{-X_0(u)}{h(u)Y_0(u)} & a \\neq 0 \\land X = X_0(u) \\land Y = Y_0(u)\n+\\end{array}\\right.\n+$$\n+\n+The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions,\n+it is possible that decoding through $\\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the\n+$x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.\n+\n+Since we know that exactly one or exactly three out of $\\\\{x_1, x_2, x_3\\\\}$ are valid x-coordinates for any $t$,\n+the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid.\n+This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of\n+$x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.\n+\n+Observe that $\\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as\n+$-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square,\n+and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined\n+before those values are computed.\n+\n+It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would\n+take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take\n+precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$\n+values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder;\n+any order which does not place $x_3$ first requires more complicated round-trip checks in the encoder.\n+\n+### 3.1 Switching to *v, w* coordinates\n+\n+Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and\n+$w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$\n+* $S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \\neq 0.$\n+* For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\\left(\\frac{\\sqrt{-3}-1}{2}u - v\\right).$\n+* $\\psi_u$ can be stated for $(v, w)$ as $\\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where\n+\n+$$\n+\\begin{array}{lcl}\n+  x_1 & = & v \\\\\n+  x_2 & = & -u - v \\\\\n+  x_3 & = & u + w^2 \\\\\n+  z   & = & \\dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \\dfrac{-g(u)g(x_3)}{w^3}\n+\\end{array}\n+$$\n+\n+We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\\\\{x_1, x_2, x_3\\\\}$\n+expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:\n+* Assuming $x = x_1$, we find $v = x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\n+* Assuming $x = x_2$, we find $v = -u-x$ and $w = \\pm\\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).\n+* Assuming $x = x_3$, we find $w = \\pm\\sqrt{x-u}$ and $v = -u/2 \\pm \\sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2)$ (four solutions).\n+\n+### 3.2 Avoiding computing all inverses\n+\n+The *ElligatorSwift* algorithm as stated in Section 1 requires the computation of $L = F_u^{-1}(x)$ (the\n+set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.\n+\n+Observe that the procedure of restarting with probability $(1 - \\frac{\\\\#L}{8})$ and otherwise returning a\n+uniformly random element from $L$ is actually equivalent to always padding $L$ with $\\bot$ values up to length 8,\n+picking a uniformly random element from that, restarting whenever $\\bot$ is picked:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Compute the set $L = F_u^{-1}(x).$\n+  * Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \\\\#L$ times $\\\\{\\bot\\\\}.$\n+  * Select a uniformly random $t \\in T.$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Now notice that the order of elements in $T$ does not matter, as all we do is pick a uniformly\n+random element in it, so we do not need to have all $\\bot$ values at the end.\n+As we have 8 distinct formulas for finding $(v, w)$ (taking the variants due to $\\pm$ into account),\n+we can associate every index in $T$ with exactly one of those formulas, making sure that:\n+* Formulas that yield no solutions (due to division by zero or non-existing square roots) or invalid solutions are made to return $\\bot.$\n+* For the $x_1$ and $x_2$ cases, if $g(-u-x)$ is a square, $\\bot$ is returned instead (the round-trip check).\n+* In case multiple formulas would return the same non- $\\bot$ result, all but one of those must be turned into $\\bot$ to avoid biasing those.\n+\n+The last condition above only occurs with negligible probability for cryptographically-sized curves, but is interesting\n+to take into account as it allows exhaustive testing in small groups. See [Section 3.4](#34-dealing-with-special-cases)\n+for an analysis of all the negligible cases.\n+\n+If we define $T = (G_{0,u}(x), G_{1,u}(x), \\ldots, G_{7,u}(x))$, with each $G_{i,u}$ matching one of the formulas,\n+the loop can be simplified to only compute one of the inverses instead of all of them:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+This is implemented in `secp256k1_ellswift_xelligatorswift_var`.\n+\n+### 3.3 Finding the inverse\n+\n+To implement $G_{c,u}$, we map $c=0$ to the $x_1$ formula, $c=1$ to the $x_2$ formula, and $c=2$ and $c=3$ to the $x_3$ formula.\n+Those are then repeated as $c=4$ through $c=7$ for the other sign of $w$ (noting that in each formula, $w$ is a square root of some expression).\n+Ignoring the negligible cases, we get:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}$ (for $x_1$ and $x_2$ formulas):\n+  * If $g(-u-x)$ is square, return $\\bot$ (as $x_3$ would be valid and take precedence).\n+  * If $c \\in \\\\{0, 4\\\\}$ (the $x_1$ formula) let $v = x$, otherwise let $v = -u-x$ (the $x_2$ formula)\n+  * Let $s = -g(u)/(u^2 + uv + v^2 + a)$ (using $s = w^2$ in what follows).\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}$ (for $x_3$ formulas):\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2$ if $c \\in \\\\{3, 7\\\\}$; $(-r/s - u)/2$ otherwise.\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 1, 2, 3\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{4, 5, 6, 7\\\\}:$ return $P_u^{'-1}(v, -w).$\n+\n+Whenever a square root of a non-square is taken, $\\bot$ is returned; for both square roots this happens with roughly\n+50% on random inputs. Similarly, when a division by 0 would occur, $\\bot$ is returned as well; this will only happen\n+with negligible probability. A division by 0 in the first branch in fact cannot occur at all, because $u^2 + uv + v^2 + a = 0$\n+implies $g(-u-x) = g(x)$ which would mean the $g(-u-x)$ is square condition has triggered\n+and $\\bot$ would have been returned already.\n+\n+**Note**: In the paper, the $case$ variable corresponds roughly to the $c$ above, but only takes on 4 possible values (1 to 4).\n+The conditional negation of $w$ at the end is done randomly, which is equivalent, but makes testing harder. We choose to\n+have the $G_{c,u}$ be deterministic, and capture all choices in $c.$\n+\n+Now observe that the $c \\in \\\\{1, 5\\\\}$ and $c \\in \\\\{3, 7\\\\}$ conditions effectively perform the same $v \\rightarrow -u-v$\n+transformation. Furthermore, that transformation has no effect on $s$ in the first branch\n+as $u^2 + ux + x^2 + a = u^2 + u(-u-x) + (-u-x)^2 + a.$ Thus we can extract it out and move it down:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a).$\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $P_u^{'-1}(-u-v, -w).$\n+\n+This shows there will always be exactly 0, 4, or 8 $t$ values for a given $(u, x)$ input.\n+There can be 0, 1, or 2 $(v, w)$ pairs before invoking $P_u^{'-1}$, and each results in 4 distinct $t$ values.\n+\n+### 3.4 Dealing with special cases\n+\n+As mentioned before there are a few cases to deal with which only happen in a negligibly small subset of inputs.\n+For cryptographically sized fields, if only random inputs are going to be considered, it is unnecessary to deal with these. Still, for completeness\n+we analyse them here. They generally fall into two categories: cases in which the encoder would produce $t$ values that\n+do not decode back to $x$ (or at least cannot guarantee that they do), and cases in which the encoder might produce the same\n+$t$ value for multiple $c$ inputs (thereby biasing that encoding):\n+\n+* In the branch for $x_1$ and $x_2$ (where $c \\in \\\\{0, 1, 4, 5\\\\}$):\n+  * When $g(u) = 0$, we would have $s=w=Y=0$, which is not on $S_u.$ This is only possible on even-ordered curves.\n+    Excluding this also removes the one condition under which the simplified check for $x_3$ on the curve\n+    fails (namely when $g(x_1)=g(x_2)=0$ but $g(x_3)$ is not square).\n+    This does exclude some valid encodings: when both $g(u)=0$ and $u^2+ux+x^2+a=0$ (also implying $g(x)=0$),\n+    the $S_u'$ equation degenerates to $0 = 0$, and many valid $t$ values may exist. Yet, these cannot be targeted uniformly by the\n+    encoder anyway as there will generally be more than 8.\n+  * When $g(x) = 0$, the same $t$ would be produced as in the $x_3$ branch (where $c \\in \\\\{2, 3, 6, 7\\\\}$) which we give precedence\n+    as it can deal with $g(u)=0$.\n+    This is again only possible on even-ordered curves.\n+* In the branch for $x_3$ (where $c \\in \\\\{2, 3, 6, 7\\\\}$):\n+  * When $s=0$, a division by zero would occur.\n+  * When $v = -u-v$ and $c \\in \\\\{3, 7\\\\}$, the same $t$ would be returned as in the $c \\in \\\\{2, 6\\\\}$ cases.\n+    It is equivalent to checking whether $r=0$.\n+    This cannot occur in the $x_1$ or $x_2$ branches, as it would trigger the $g(-u-x)$ is square condition.\n+    A similar concern for $w = -w$ does not exist, as $w=0$ is already impossible in both branches: in the first\n+    it requires $g(u)=0$ which is already outlawed on even-ordered curves and impossible on others; in the second it would trigger division by zero.\n+* Curve-specific special cases also exist that need to be rejected, because they result in $(u,t)$ which is invalid to the decoder, or because of division by zero in the encoder:\n+  * For $a=0$ curves, when $u=0$ or when $t=0$. The latter can only be reached by the encoder when $g(u)=0$, which requires an even-ordered curve.\n+  * For $a \\neq 0$ curves, when $X_0(u)=0$, when $h(u)t^2 = -1$, or when $2w(u + 2v) = 2X_0(u)$ while also either $w \\neq 2Y_0(u)$ or $h(u)=0$.\n+\n+**Define** a version of $G_{c,u}(x)$ which deals with all these cases:\n+* If $a=0$ and $u=0$, return $\\bot.$\n+* If $a \\neq 0$ and $X_0(u)=0$, return $\\bot.$\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $g(u) = 0$ or $g(x) = 0$, return $\\bot$ (even curves only).\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a)$ (cannot cause division by zero).\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\n+  * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\n+  * If $s = 0$, return $\\bot.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\n+* If $a \\neq 0$ and $w(u+2v) = 2X_0(u)$ and either $w \\neq 2Y_0(u)$ or $h(u) = 0$, return $\\bot.$\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}$, let $t = P_u^{'-1}(v, w).$\n+  * If $c \\in \\\\{1, 3\\\\}$, let $t = P_u^{'-1}(-u-v, w).$\n+  * If $c \\in \\\\{4, 6\\\\}$, let $t = P_u^{'-1}(v, -w).$\n+  * If $c \\in \\\\{5, 7\\\\}$, let $t = P_u^{'-1}(-u-v, -w).$\n+* If $a=0$ and $t=0$, return $\\bot$ (even curves only).\n+* If $a \\neq 0$ and $h(u)t^2 = -1$, return $\\bot.$\n+* Return $t.$\n+\n+Given any $u$, using this algorithm over all $x$ and $c$ values, every $t$ value will be reached exactly once,\n+for an $x$ for which $F_u(t) = x$ holds, except for these cases that will not be reached:\n+* All cases where $P_u(t)$ is not defined:\n+  * For $a=0$ curves, when $u=0$, $t=0$, or $g(u) = -t^2.$\n+  * For $a \\neq 0$ curves, when $h(u)t^2 = -1$, $X_0(u) = 0$, or $Y_0(u) (1 - h(u) t^2) = 2X_0(u)t.$\n+* When $g(u)=0$, the potentially many $t$ values that decode to an $x$ satisfying $g(x)=0$ using the $x_2$ formula. These were excluded by the $g(u)=0$ condition in the $c \\in \\\\{0, 1, 4, 5\\\\}$ branch.\n+\n+These cases form a negligible subset of all $(u, t)$ for cryptographically sized curves.\n+\n+### 3.5 Encoding for `secp256k1`\n+\n+Specialized for odd-ordered $a=0$ curves:\n+\n+**Define** $G_{c,u}(x)$ as:\n+* If $u=0$, return $\\bot.$\n+* If $c \\in \\\\{0, 1, 4, 5\\\\}:$\n+  * If $(-u-x)^3 + b$ is square, return $\\bot$\n+  * Let $s = -(u^3 + b)/(u^2 + ux + x^2)$ (cannot cause division by 0).\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3, 6, 7\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4(u^3 + b) + 3su^2)}$; return $\\bot$ if not square.\n+  * If $c \\in \\\\{3, 7\\\\}$ and $r=0$, return $\\bot.$\n+  * If $s = 0$, return $\\bot.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\n+* Depending on $c:$\n+  * If $c \\in \\\\{0, 2\\\\}:$ return $w(\\frac{\\sqrt{-3}-1}{2}u - v).$\n+  * If $c \\in \\\\{1, 3\\\\}:$ return $w(\\frac{\\sqrt{-3}+1}{2}u + v).$\n+  * If $c \\in \\\\{4, 6\\\\}:$ return $w(\\frac{-\\sqrt{-3}+1}{2}u + v).$\n+  * If $c \\in \\\\{5, 7\\\\}:$ return $w(\\frac{-\\sqrt{-3}-1}{2}u - v).$\n+\n+This is implemented in `secp256k1_ellswift_xswiftec_inv_var`.\n+\n+And the x-only ElligatorSwift encoding algorithm is still:\n+\n+**Define** *ElligatorSwift(x)* as:\n+* Loop:\n+  * Pick a uniformly random field element $u.$\n+  * Pick a uniformly random integer $c$ in $[0,8).$\n+  * Let $t = G_{c,u}(x).$\n+  * If $t \\neq \\bot$, return $(u, t)$; restart loop otherwise.\n+\n+Note that this logic does not take the remapped $u=0$, $t=0$, and $g(u) = -t^2$ cases into account; it just avoids them.\n+While it is not impossible to make the encoder target them, this would increase the maximum number of $t$ values for a given $(u, x)$\n+combination beyond 8, and thereby slow down the ElligatorSwift loop proportionally, for a negligible gain in uniformity.\n+\n+## 4. Encoding and decoding full *(x, y)* coordinates\n+\n+So far we have only addressed encoding and decoding x-coordinates, but in some cases an encoding\n+for full points with $(x, y)$ coordinates is desirable. It is possible to encode this information\n+in $t$ as well.\n+\n+Note that for any $(X, Y) \\in S_u$, $(\\pm X, \\pm Y)$ are all on $S_u.$ Moreover, all of these are\n+mapped to the same x-coordinate. Negating $X$ or negating $Y$ just results in $x_1$ and $x_2$\n+being swapped, and does not affect $x_3.$ This will not change the outcome x-coordinate as the order\n+of $x_1$ and $x_2$ only matters if both were to be valid, and in that case $x_3$ would be used instead.\n+\n+Still, these four $(X, Y)$ combinations all correspond to distinct $t$ values, so we can encode\n+the sign of the y-coordinate in the sign of $X$ or the sign of $Y.$ They correspond to the\n+four distinct $P_u^{'-1}$ calls in the definition of $G_{u,c}.$\n+\n+**Note**: In the paper, the sign of the y coordinate is encoded in a separately-coded bit.\n+\n+To encode the sign of $y$ in the sign of $Y:$\n+\n+**Define** *Decode(u, t)* for full $(x, y)$ as:\n+* Let $(X, Y) = P_u(t).$\n+* Let $x$ be the first value in $(u + 4Y^2, \\frac{-X}{2Y} - \\frac{u}{2}, \\frac{X}{2Y} - \\frac{u}{2})$ for which $g(x)$ is square.\n+* Let $y = \\sqrt{g(x)}.$\n+* If $sign(y) = sign(Y)$, return $(x, y)$; otherwise return $(x, -y).$\n+\n+And encoding would be done using a $G_{c,u}(x, y)$ function defined as:\n+\n+**Define** $G_{c,u}(x, y)$ as:\n+* If $c \\in \\\\{0, 1\\\\}:$\n+  * If $g(u) = 0$ or $g(x) = 0$, return $\\bot$ (even curves only).\n+  * If $g(-u-x)$ is square, return $\\bot.$\n+  * Let $s = -g(u)/(u^2 + ux + x^2 + a)$ (cannot cause division by zero).\n+  * Let $v = x.$\n+* Otherwise, when $c \\in \\\\{2, 3\\\\}:$\n+  * Let $s = x-u.$\n+  * Let $r = \\sqrt{-s(4g(u) + sh(u))}$; return $\\bot$ if not square.\n+  * If $c = 3$ and $r = 0$, return $\\bot.$\n+  * Let $v = (r/s - u)/2.$\n+* Let $w = \\sqrt{s}$; return $\\bot$ if not square.\n+* Let $w' = w$ if $sign(w/2) = sign(y)$; $-w$ otherwise.",
      "path": "doc/ellswift.md",
      "position": 445,
      "original_position": 445,
      "commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "original_commit_id": "90e360acc2511f313964e394005bafb377b4f191",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why not $sign(w)$?",
      "created_at": "2023-06-23T18:02:36Z",
      "updated_at": "2023-06-23T18:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1129#discussion_r1240132878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240132878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1129"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 445,
      "original_line": 445,
      "side": "RIGHT"
    }
  ]
}