{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385",
    "id": 1451528456,
    "node_id": "PR_kwDOAP4Jqs5WhJEI",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1385.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1385.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
    "number": 1385,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "add fuzz tests about field operations.",
    "user": {
      "login": "YafeiXie1",
      "id": 114428701,
      "node_id": "U_kgDOBtILHQ",
      "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/YafeiXie1",
      "html_url": "https://github.com/YafeiXie1",
      "followers_url": "https://api.github.com/users/YafeiXie1/followers",
      "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
      "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
      "repos_url": "https://api.github.com/users/YafeiXie1/repos",
      "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thanks for the previous review. \r\nThis PR:\r\n1. changes on the function names in the scalar operations tests.\r\n2. remove the randomness in fuzz_scalar_shift test, the value is computed from size. \r\n3. add the function that decide the test based on an environment variable.\r\n4. add fuzz tests about field operations.\r\nCould you give me some suggestions?\r\n",
    "labels": [
      {
        "id": 165017692,
        "node_id": "MDU6TGFiZWwxNjUwMTc2OTI=",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/assurance",
        "name": "assurance",
        "description": "",
        "color": "A6DF3D",
        "default": false
      }
    ],
    "created_at": "2023-07-27T08:08:29Z",
    "updated_at": "2023-08-29T13:28:58Z",
    "closed_at": "2023-08-21T14:24:55Z",
    "mergeable_state": "unknown",
    "merge_commit_sha": "21ea1c14472df251e6913f942347a4c7aaea3ce2",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "YafeiXie1:fuzz",
      "ref": "fuzz",
      "sha": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "user": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 667139146,
        "node_id": "R_kgDOJ8O8Sg",
        "name": "secp256k1",
        "full_name": "YafeiXie1/secp256k1",
        "owner": {
          "login": "YafeiXie1",
          "id": 114428701,
          "node_id": "U_kgDOBtILHQ",
          "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/YafeiXie1",
          "html_url": "https://github.com/YafeiXie1",
          "followers_url": "https://api.github.com/users/YafeiXie1/followers",
          "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
          "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
          "repos_url": "https://api.github.com/users/YafeiXie1/repos",
          "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/YafeiXie1/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/YafeiXie1/secp256k1",
        "archive_url": "https://api.github.com/repos/YafeiXie1/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/YafeiXie1/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/YafeiXie1/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/YafeiXie1/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/YafeiXie1/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/YafeiXie1/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/YafeiXie1/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/YafeiXie1/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/YafeiXie1/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/YafeiXie1/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/YafeiXie1/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/YafeiXie1/secp256k1/events",
        "forks_url": "https://api.github.com/repos/YafeiXie1/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/YafeiXie1/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/YafeiXie1/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/YafeiXie1/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/YafeiXie1/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/YafeiXie1/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/YafeiXie1/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/YafeiXie1/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/YafeiXie1/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/YafeiXie1/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:YafeiXie1/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/YafeiXie1/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/YafeiXie1/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/YafeiXie1/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/YafeiXie1/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/YafeiXie1/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/YafeiXie1/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/YafeiXie1/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/YafeiXie1/secp256k1/hooks",
        "svn_url": "https://github.com/YafeiXie1/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 10549,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-29T13:42:16Z",
        "created_at": "2023-07-16T19:06:56Z",
        "updated_at": "2023-07-27T07:02:29Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "6b9507adf684f088f665354608685255d0bd162f",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 985,
        "stargazers_count": 1822,
        "watchers_count": 1822,
        "size": 10575,
        "default_branch": "master",
        "open_issues_count": 139,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-29T13:42:19Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-08-29T01:28:39Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
      }
    },
    "author_association": "NONE",
    "draft": false,
    "additions": 611,
    "deletions": 0,
    "changed_files": 1,
    "commits": 2,
    "review_comments": 7,
    "comments": 1
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDM1YmU5MDNhODJkY2YwZDJkYjhiYTNiOGE5ZWI1NmY1ZmJjY2EyMjA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "tree": {
        "sha": "12369dfdfc237ca12c87f8b2167f94cfd1392a64",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/12369dfdfc237ca12c87f8b2167f94cfd1392a64"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0e00fc7d10af4035cb22749c6f9a8973eeb87f7d",
          "sha": "0e00fc7d10af4035cb22749c6f9a8973eeb87f7d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0e00fc7d10af4035cb22749c6f9a8973eeb87f7d"
        }
      ],
      "message": "add fuzz tests about field operations.",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-07-27T07:38:53Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-07-27T07:38:53Z"
      },
      "sha": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220"
    },
    {
      "event": "labeled",
      "id": 9932898945,
      "node_id": "LE_lADOAP4Jqs5stZtszwAAAAJQDAKB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9932898945",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-27T08:31:51Z",
      "label": {
        "name": "assurance",
        "color": "A6DF3D"
      }
    },
    {
      "event": "reviewed",
      "id": 1557693365,
      "node_id": "PRR_kwDOAP4Jqs5c2IO1",
      "url": null,
      "actor": null,
      "commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#pullrequestreview-1557693365",
      "submitted_at": "2023-08-01T20:35:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGQ1OWM2M2E5MDRhMGRiZjNmNDcyOWJhMGQxMGJmZTdlZmUwYjgwNjA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "tree": {
        "sha": "886709462a20519bafbab69de20ce2f58f2eb1aa",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/886709462a20519bafbab69de20ce2f58f2eb1aa"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 886709462a20519bafbab69de20ce2f58f2eb1aa\nparent 35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220\nparent 6b9507adf684f088f665354608685255d0bd162f\nauthor OliverX <114428701+YafeiXie1@users.noreply.github.com> 1692603976 +0100\ncommitter GitHub <noreply@github.com> 1692603976 +0100\n\nMerge branch 'bitcoin-core:master' into fuzz\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJk4xZICRBK7hj4Ov3rIwAAT2gIAKcT20O83ytj/jafjQwUeaCN\nFcWl8tBPwnQ4qi04L90vpUUc+0APvbV+YbpJl36ISrs5fQaNENbfgj1LOtwyCadW\nzA0epx7zd/xAdr/5STaZRCpZ/wMXd/cdJb14hxMVAchAbEVht9zfkT0JQlLhrpBG\niLsuenWfLLRgfuG0KfNXrc7I2kd96U2adkYuGPWStgtE4MqLAHjvG3TxauMJId99\nzzcDZPJ85y7d5s7iE9EhHUhuaPRDUB2Cj4ez2Cc82xkhQOZIDq6PUlmjCkYW6mrZ\nm8/PwBF3mGSMOM/tbb+63WT8WMUjDvRLZZCaUJqQK19oxQ8/0gIOu19b3Mi0iKI=\n=Ioeu\n-----END PGP SIGNATURE-----\n"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
          "sha": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220"
        },
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6b9507adf684f088f665354608685255d0bd162f",
          "sha": "6b9507adf684f088f665354608685255d0bd162f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6b9507adf684f088f665354608685255d0bd162f"
        }
      ],
      "message": "Merge branch 'bitcoin-core:master' into fuzz",
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2023-08-21T07:46:16Z"
      },
      "author": {
        "name": "OliverX",
        "email": "114428701+YafeiXie1@users.noreply.github.com",
        "date": "2023-08-21T07:46:16Z"
      },
      "sha": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060"
    },
    {
      "event": "commented",
      "id": 1686435265,
      "node_id": "IC_kwDOAP4Jqs5khPXB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1686435265",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:24:50Z",
      "updated_at": "2023-08-21T14:24:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "Superseded by #1407 ",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#issuecomment-1686435265",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385"
    },
    {
      "event": "closed",
      "id": 10146229102,
      "node_id": "CE_lADOAP4Jqs5stZtszwAAAAJcwytu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10146229102",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:24:55Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 10221290997,
      "node_id": "HRDE_lADOAP4Jqs5stZtszwAAAAJhPIX1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10221290997",
      "actor": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T13:28:58Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281068828",
      "pull_request_review_id": 1557693365,
      "id": 1281068828,
      "node_id": "PRRC_kwDOAP4Jqs5MW48c",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (size % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Test the field element equality and comparison operations. */\n+static void fuzz_field_equality(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe;    \n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        CHECK(secp256k1_fe_equal(&fe, &fe));\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe));\n+        CHECK(secp256k1_fe_cmp_var(&fe, &fe) == 0);\n+    }\n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        unsigned char b32[32];        \n+        if (secp256k1_fe_set_b32_limit(&fe, data)) {\n+            secp256k1_fe_set_b32_mod(&fe2, data);\n+            CHECK(secp256k1_fe_cmp_var(&fe, &fe2) == 0);\n+            secp256k1_fe_get_b32(b32, &fe);\n+            CHECK(secp256k1_memcmp_var(b32, data, 32) == 0);       \n+        } else {\n+            secp256k1_fe_set_b32_mod(&fe2, data);\n+            secp256k1_fe_get_b32(b32, &fe2);\n+            CHECK(secp256k1_memcmp_var(b32, data, 32) == 0);\n+        } \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        secp256k1_fe_storage fes;     \n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        secp256k1_fe_to_storage(&fes, &fe);\n+        secp256k1_fe_from_storage(&fe2, &fes);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        r2 = b;\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);       \n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        secp256k1_fe_add(&r1, &c);\n+        r2 = c;\n+        secp256k1_fe_add(&r2, &b);\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, zero, r1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        CHECK(secp256k1_fe_equal_var(&r1, &a));\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, negate;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_negate(&negate, &a, 1);\n+        secp256k1_fe_add(&a, &negate);\n+        CHECK(secp256k1_fe_normalizes_to_zero_var(&a));\n+    }\n+}\n+\n+/* Test addition of field element and an integer */ \n+static void fuzz_field_add_integer(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        int v = size;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_int(&r1, v);\n+        secp256k1_fe_add(&r1, &a);\n+        r2 = a;\n+        secp256k1_fe_add_int(&r2, v);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test the half value of a field element */ \n+static void fuzz_field_half(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        fe2 = fe;\n+        secp256k1_fe_half(&fe);\n+        secp256k1_fe_add(&fe, &fe);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+        secp256k1_fe_add(&fe2, &fe2);\n+        secp256k1_fe_half(&fe2);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+    }\n+}\n+\n+/* Test commutativity of multiplication on two field elements */\n+static void fuzz_field_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_mul(&r1, &a, &b);\n+        secp256k1_fe_mul(&r2, &b, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of multiplication on field elements */\n+static void fuzz_field_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);       \n+        secp256k1_fe_mul(&r1, &a, &b);\n+        secp256k1_fe_mul(&r1, &r1, &c);\n+        secp256k1_fe_mul(&r2, &b, &c);\n+        secp256k1_fe_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of multiplication on field elements */\n+static void fuzz_field_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2, r3;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);\n+        r1 = a;       \n+        secp256k1_fe_add(&r1, &b);\n+        secp256k1_fe_mul(&r1, &r1, &c);\n+        secp256k1_fe_mul(&r2, &a, &c);\n+        secp256k1_fe_mul(&r3, &b, &c);\n+        secp256k1_fe_add(&r2, &r3);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test field multiplication with 0 */ \n+static void fuzz_field_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, zero, r1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_mul(&r1, &a, &zero);\n+        CHECK(secp256k1_fe_is_zero(&r1));\n+    }\n+}\n+\n+/* Test multiplication of field element with an integer */\n+static void fuzz_field_mul_integer(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        r1 = a;\n+        secp256k1_fe_mul_int(&r1, 3);\n+        r2 = a;\n+        secp256k1_fe_add(&r2, &a);\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square of a field element */\n+static void fuzz_field_sqr(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_sqr(&r1, &a);\n+        secp256k1_fe_mul(&r2, &a, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square of negative field element */\n+static void fuzz_field_sqr_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_negate(&b, &a, 1);\n+        secp256k1_fe_sqr(&r1, &a);\n+        secp256k1_fe_sqr(&r2, &b);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square root of a field element */\n+static void fuzz_field_sqrt(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_sqr(&b, &a);\n+        secp256k1_fe_sqrt(&r1, &b);\n+        secp256k1_fe_negate(&r2, &r1, 1);\n+        secp256k1_fe_add(&r1, &a); \n+        secp256k1_fe_add(&r2, &a);\n+        secp256k1_fe_normalize(&r1); \n+        secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+    }\n+}\n+\n+/* Test square root of negative field element */\n+static void fuzz_field_sqrt_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_normalize(&a);\n+        if (!secp256k1_fe_is_zero(&a)) {\n+            secp256k1_fe_negate(&b, &a, 1);\n+            int ret = secp256k1_fe_sqrt(&r1, &a);\n+            int ret2 = secp256k1_fe_sqrt(&r2, &b);\n+            CHECK((ret2 == 0) || (ret == 0));\n+        } else {\n+            secp256k1_fe_sqrt(&r1, &a);\n+            CHECK(secp256k1_fe_is_zero(&r1));\n+        }\n+    }\n+}\n+\n+/* Test field inverse */\n+static void fuzz_field_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_fe a, r1, r2, r3;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_inv(&r1, &a);\n+        if (secp256k1_fe_normalizes_to_zero(&a)) {\n+            CHECK(secp256k1_fe_normalizes_to_zero(&r1));\n+        }\n+        else {\n+            secp256k1_fe_mul(&r2, &a, &r1);\n+            secp256k1_fe_add_int(&r2, -1);\n+            CHECK(secp256k1_fe_normalizes_to_zero(&r2));\n+        }\n+    }\n+} \n+\n+/* Test conditional move of field elements */\n+static void fuzz_field_cmov(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b, r1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_fe_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_fe_equal_var(&r1, &b));\n+        } else {\n+            secp256k1_fe_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_fe_equal_var(&r1, &a));\n+        }\n+    }\n+}\n+\n+/* Test conditional move of fe_storage */\n+static void fuzz_field_storage_cmov(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage as, bs, rs1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_to_storage(&as, &a);\n+        secp256k1_fe_to_storage(&bs, &b);\n+        int flag = size % 2;\n+        rs1 = as;\n+        if (flag) {            \n+            secp256k1_fe_storage_cmov(&rs1, &bs, 1);\n+            CHECK(secp256k1_memcmp_var(&rs1, &bs, 32) == 0);\n+        } else {\n+            secp256k1_fe_storage_cmov(&rs1, &bs, 0);\n+            CHECK(secp256k1_memcmp_var(&rs1, &as, 32) == 0);\n+        }\n+    }\n+}\n+\n+typedef void (*fuzz_function)(const uint8_t* data, size_t size);\n+\n+static fuzz_function selected_fuzz_function = NULL;\n+\n+int LLVMFuzzerInitialize(int *argc, char ***argv) {\n+    const char* test_name = getenv(\"FUZZ\");\n+    if (!test_name) {\n+        fprintf(stderr, \"Select a fuzz test using the FUZZ environment variable\\n\");\n+        assert(false);\n+    }\n+    if (strcmp(test_name, \"scalar_add_commutativty\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_add_commutativty;\n+    } else if (strcmp(test_name, \"scalar_add_associativity\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_add_associativity;\n+    } else if (strcmp(test_name, \"scalar_add_zero\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_add_zero;\n+    } else if (strcmp(test_name, \"scalar_add_complements\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_add_complements;\n+    } else if (strcmp(test_name, \"scalar_mul_commutativity\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_mul_commutativity;\n+    } else if (strcmp(test_name, \"scalar_mul_associativity\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_mul_associativity;\n+    } else if (strcmp(test_name, \"scalar_mul_distributivity\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_mul_distributivity;\n+    } else if (strcmp(test_name, \"scalar_mul_one\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_mul_one;\n+    } else if (strcmp(test_name, \"scalar_mul_zero\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_mul_zero;\n+    } else if (strcmp(test_name, \"scalar_inverse\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_inverse;\n+    } else if (strcmp(test_name, \"scalar_inverse_var\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_inverse_var;\n+    } else if (strcmp(test_name, \"scalar_negate\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_negate;\n+    } else if (strcmp(test_name, \"scalar_shift\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_shift;\n+    } else if (strcmp(test_name, \"scalar_split_lambda\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_split_lambda;\n+    } else if (strcmp(test_name, \"scalar_cmov\") == 0) {\n+        selected_fuzz_function = &fuzz_scalar_cmov;\n+    } else if (strcmp(test_name, \"field_equality\") == 0) {\n+        selected_fuzz_function = &fuzz_field_equality;\n+    } else if (strcmp(test_name, \"field_b32_and_fe\") == 0) {\n+        selected_fuzz_function = &fuzz_field_b32_and_fe;\n+    } else if (strcmp(test_name, \"field_fe_and_storage\") == 0) {\n+        selected_fuzz_function = &fuzz_field_fe_and_storage;\n+    } else if (strcmp(test_name, \"field_add_commutativty\") == 0) {\n+        selected_fuzz_function = &fuzz_field_add_commutativty;\n+    } else if (strcmp(test_name, \"field_add_associativity\") == 0) {\n+        selected_fuzz_function = &fuzz_field_add_associativity;\n+    } else if (strcmp(test_name, \"field_add_zero\") == 0) {\n+        selected_fuzz_function = &fuzz_field_add_zero;\n+    } else if (strcmp(test_name, \"field_add_negate\") == 0) {\n+        selected_fuzz_function = &fuzz_field_add_negate;\n+    } else if (strcmp(test_name, \"field_add_integer\") == 0) {\n+        selected_fuzz_function = &fuzz_field_add_integer;\n+    } else if (strcmp(test_name, \"field_half\") == 0) {\n+        selected_fuzz_function = &fuzz_field_half;\n+    } else if (strcmp(test_name, \"field_mul_commutativity\") == 0) {\n+        selected_fuzz_function = &fuzz_field_mul_commutativity;\n+    } else if (strcmp(test_name, \"field_mul_associativity\") == 0) {\n+        selected_fuzz_function = &fuzz_field_mul_associativity;\n+    } else if (strcmp(test_name, \"field_mul_distributivity\") == 0) {\n+        selected_fuzz_function = &fuzz_field_mul_distributivity;\n+    } else if (strcmp(test_name, \"field_mul_zero\") == 0) {\n+        selected_fuzz_function = &fuzz_field_mul_zero;\n+    } else if (strcmp(test_name, \"field_mul_integer\") == 0) {\n+        selected_fuzz_function = &fuzz_field_mul_integer;\n+    } else if (strcmp(test_name, \"field_sqr\") == 0) {\n+        selected_fuzz_function = &fuzz_field_sqr;\n+    } else if (strcmp(test_name, \"field_sqr_negate\") == 0) {\n+        selected_fuzz_function = &fuzz_field_sqr_negate;\n+    } else if (strcmp(test_name, \"field_sqrt\") == 0) {\n+        selected_fuzz_function = &fuzz_field_sqrt;\n+    } else if (strcmp(test_name, \"field_sqrt_negate\") == 0) {\n+        selected_fuzz_function = &fuzz_field_sqrt_negate;\n+    } else if (strcmp(test_name, \"field_inverse\") == 0) {\n+        selected_fuzz_function = &fuzz_field_inverse;\n+    } else if (strcmp(test_name, \"field_cmov\") == 0) {\n+        selected_fuzz_function = &fuzz_field_cmov;\n+    } else if (strcmp(test_name, \"field_storage_cmov\") == 0) {\n+        selected_fuzz_function = &fuzz_field_storage_cmov;\n+    } else {\n+        fprintf(stderr, \"Unknown fuzz test selected using FUZZ environment variable: %s\\n\", test_name);\n+        assert(false);",
      "path": "src/fuzz.c",
      "position": 598,
      "original_position": 598,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`false` doesn't exist as a keyword in C89 (which the libsecp256k1 source code tries to use with the least amount of extensions possible). You can use `assert(0);`.",
      "created_at": "2023-08-01T19:35:48Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281068828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281068828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 598,
      "original_line": 598,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281069415",
      "pull_request_review_id": 1557693365,
      "id": 1281069415,
      "node_id": "PRRC_kwDOAP4Jqs5MW5Fn",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (size % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Test the field element equality and comparison operations. */\n+static void fuzz_field_equality(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe;    \n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        CHECK(secp256k1_fe_equal(&fe, &fe));\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe));\n+        CHECK(secp256k1_fe_cmp_var(&fe, &fe) == 0);\n+    }\n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        unsigned char b32[32];        \n+        if (secp256k1_fe_set_b32_limit(&fe, data)) {\n+            secp256k1_fe_set_b32_mod(&fe2, data);\n+            CHECK(secp256k1_fe_cmp_var(&fe, &fe2) == 0);\n+            secp256k1_fe_get_b32(b32, &fe);\n+            CHECK(secp256k1_memcmp_var(b32, data, 32) == 0);       \n+        } else {\n+            secp256k1_fe_set_b32_mod(&fe2, data);\n+            secp256k1_fe_get_b32(b32, &fe2);\n+            CHECK(secp256k1_memcmp_var(b32, data, 32) == 0);\n+        } \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        secp256k1_fe_storage fes;     \n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        secp256k1_fe_to_storage(&fes, &fe);\n+        secp256k1_fe_from_storage(&fe2, &fes);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        r2 = b;\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);       \n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        secp256k1_fe_add(&r1, &c);\n+        r2 = c;\n+        secp256k1_fe_add(&r2, &b);\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, zero, r1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        CHECK(secp256k1_fe_equal_var(&r1, &a));\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, negate;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_negate(&negate, &a, 1);\n+        secp256k1_fe_add(&a, &negate);\n+        CHECK(secp256k1_fe_normalizes_to_zero_var(&a));\n+    }\n+}\n+\n+/* Test addition of field element and an integer */ \n+static void fuzz_field_add_integer(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        int v = size;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_int(&r1, v);\n+        secp256k1_fe_add(&r1, &a);\n+        r2 = a;\n+        secp256k1_fe_add_int(&r2, v);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test the half value of a field element */ \n+static void fuzz_field_half(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe, fe2;\n+        secp256k1_fe_set_b32_mod(&fe, data);\n+        fe2 = fe;\n+        secp256k1_fe_half(&fe);\n+        secp256k1_fe_add(&fe, &fe);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+        secp256k1_fe_add(&fe2, &fe2);\n+        secp256k1_fe_half(&fe2);\n+        CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n+    }\n+}\n+\n+/* Test commutativity of multiplication on two field elements */\n+static void fuzz_field_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_mul(&r1, &a, &b);\n+        secp256k1_fe_mul(&r2, &b, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of multiplication on field elements */\n+static void fuzz_field_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);       \n+        secp256k1_fe_mul(&r1, &a, &b);\n+        secp256k1_fe_mul(&r1, &r1, &c);\n+        secp256k1_fe_mul(&r2, &b, &c);\n+        secp256k1_fe_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of multiplication on field elements */\n+static void fuzz_field_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_fe a, b, c, r1, r2, r3;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_set_b32_mod(&b, data + 32);\n+        secp256k1_fe_set_b32_mod(&c, data + 64);\n+        r1 = a;       \n+        secp256k1_fe_add(&r1, &b);\n+        secp256k1_fe_mul(&r1, &r1, &c);\n+        secp256k1_fe_mul(&r2, &a, &c);\n+        secp256k1_fe_mul(&r3, &b, &c);\n+        secp256k1_fe_add(&r2, &r3);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test field multiplication with 0 */ \n+static void fuzz_field_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, zero, r1;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_mul(&r1, &a, &zero);\n+        CHECK(secp256k1_fe_is_zero(&r1));\n+    }\n+}\n+\n+/* Test multiplication of field element with an integer */\n+static void fuzz_field_mul_integer(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        r1 = a;\n+        secp256k1_fe_mul_int(&r1, 3);\n+        r2 = a;\n+        secp256k1_fe_add(&r2, &a);\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square of a field element */\n+static void fuzz_field_sqr(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_sqr(&r1, &a);\n+        secp256k1_fe_mul(&r2, &a, &a);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square of negative field element */\n+static void fuzz_field_sqr_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_negate(&b, &a, 1);\n+        secp256k1_fe_sqr(&r1, &a);\n+        secp256k1_fe_sqr(&r2, &b);\n+        CHECK(secp256k1_fe_equal_var(&r1, &r2));\n+    }\n+}\n+\n+/* Test square root of a field element */\n+static void fuzz_field_sqrt(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_sqr(&b, &a);\n+        secp256k1_fe_sqrt(&r1, &b);\n+        secp256k1_fe_negate(&r2, &r1, 1);\n+        secp256k1_fe_add(&r1, &a); \n+        secp256k1_fe_add(&r2, &a);\n+        secp256k1_fe_normalize(&r1); \n+        secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+    }\n+}\n+\n+/* Test square root of negative field element */\n+static void fuzz_field_sqrt_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_fe a, b, r1, r2;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_normalize(&a);\n+        if (!secp256k1_fe_is_zero(&a)) {\n+            secp256k1_fe_negate(&b, &a, 1);\n+            int ret = secp256k1_fe_sqrt(&r1, &a);\n+            int ret2 = secp256k1_fe_sqrt(&r2, &b);\n+            CHECK((ret2 == 0) || (ret == 0));\n+        } else {\n+            secp256k1_fe_sqrt(&r1, &a);\n+            CHECK(secp256k1_fe_is_zero(&r1));\n+        }\n+    }\n+}\n+\n+/* Test field inverse */\n+static void fuzz_field_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_fe a, r1, r2, r3;\n+        secp256k1_fe_set_b32_mod(&a, data);\n+        secp256k1_fe_inv(&r1, &a);\n+        if (secp256k1_fe_normalizes_to_zero(&a)) {\n+            CHECK(secp256k1_fe_normalizes_to_zero(&r1));\n+        }\n+        else {",
      "path": "src/fuzz.c",
      "position": 467,
      "original_position": 467,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Coding style nit: `} else {` can go on one line.",
      "created_at": "2023-08-01T19:36:21Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281069415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281069415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 467,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281116684",
      "pull_request_review_id": 1557693365,
      "id": 1281116684,
      "node_id": "PRRC_kwDOAP4Jqs5MXEoM",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {",
      "path": "src/fuzz.c",
      "position": 130,
      "original_position": 130,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style nit: `} else {` on one line.",
      "created_at": "2023-08-01T20:23:20Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281116684",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281116684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 130,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281116901",
      "pull_request_review_id": 1557693365,
      "id": 1281116901,
      "node_id": "PRRC_kwDOAP4Jqs5MXErl",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {",
      "path": "src/fuzz.c",
      "position": 146,
      "original_position": 146,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style nit: `} else {` on one line.",
      "created_at": "2023-08-01T20:23:37Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281116901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281116901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281118305",
      "pull_request_review_id": 1557693365,
      "id": 1281118305,
      "node_id": "PRRC_kwDOAP4Jqs5MXFBh",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (size % 15);",
      "path": "src/fuzz.c",
      "position": 170,
      "original_position": 170,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't recommend using the fuzzer input's length as input itself; I don't think it's really designed to covney much information.\r\n\r\nSuggestion: `bit = 1 + (data[32] % 15)`, and `if (size >= 33) {`.",
      "created_at": "2023-08-01T20:25:10Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281118305",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281118305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281118786",
      "pull_request_review_id": 1557693365,
      "id": 1281118786,
      "node_id": "PRRC_kwDOAP4Jqs5MXFJC",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        ",
      "path": "src/fuzz.c",
      "position": 12,
      "original_position": 12,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Tiny nit, but I think it's a bit more readable to use `if (size >= 64) {` (here and elsewhere), as the 64 is the actual size we need.",
      "created_at": "2023-08-01T20:25:43Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281118786",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281118786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 12,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281126667",
      "pull_request_review_id": 1557693365,
      "id": 1281126667,
      "node_id": "PRRC_kwDOAP4Jqs5MXHEL",
      "diff_hunk": "@@ -0,0 +1,611 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size > 95) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size > 31) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        }\n+        else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size > 31) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (size % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size > 63) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Test the field element equality and comparison operations. */\n+static void fuzz_field_equality(const uint8_t *data, size_t size) {\n+    if (size > 31) {\n+        secp256k1_fe fe;    \n+        secp256k1_fe_set_b32_mod(&fe, data);",
      "path": "src/fuzz.c",
      "position": 212,
      "original_position": 212,
      "commit_id": "d59c63a904a0dbf3f4729ba0d10bfe7efe0b8060",
      "original_commit_id": "35be903a82dcf0d2db8ba3b8a9eb56f5fbcca220",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This will only construct very \"benign\" field elements, which are perhaps not the most likely ones to trigger issues.\r\n\r\nGoing beyond this is non-trivial though. You'll probably want to write a helper function to construct a field element with specified representation directly (so the `fe.d[0..4]` elements, in particular) and then bail out if it turns out to be invalid. Then you'll need to set magnitude/normalization appropriately as well.\r\n\r\nThis will involve a number of changes, and you'll want to read up on the field element representation (see `field_5x52.h`, let's ignore the 26-bit field for now). It'll also mean some refactoring of `secp256k1_fe_impl_verify`.",
      "created_at": "2023-08-01T20:35:13Z",
      "updated_at": "2023-08-01T20:35:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385#discussion_r1281126667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1281126667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    }
  ]
}