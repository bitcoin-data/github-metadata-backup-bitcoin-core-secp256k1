{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319",
    "id": 46112035,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NDYxMTIwMzU=",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/319.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/319.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/67f7da40874a42b85cb653634446e92821474315",
    "number": 319,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Extensive interface and operations tests for secp256k1_ec_pubkey_parse. (and some API paranoia improvements)",
    "user": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": " This also makes use of optional valgrind instrumentation if -DVALGRIND\n     is set.\n\n```\nThis also moves secp256k1.c above secp256k1.h in tests.c or otherwise\n we get non-null macros on the public functions which may defeat some\n of the VERIFY checks.\n```\n",
    "labels": [],
    "created_at": "2015-09-27T23:56:44Z",
    "updated_at": "2019-08-13T06:26:44Z",
    "closed_at": "2015-10-14T12:32:33Z",
    "mergeable_state": "unknown",
    "merged_at": "2015-10-14T12:32:33Z",
    "merge_commit_sha": "74fbc04f8e03e81fd5ec72f9c23982c7bbd55616",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "gmaxwell:ec_pubkey_parse_test",
      "ref": "ec_pubkey_parse_test",
      "sha": "67f7da40874a42b85cb653634446e92821474315",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "7450ef171db18361962ce1cabc5f3f233648789b",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 948,
        "stargazers_count": 1768,
        "watchers_count": 1768,
        "size": 10062,
        "default_branch": "master",
        "open_issues_count": 142,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-12T16:38:48Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-06-12T17:38:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 415,
    "deletions": 3,
    "changed_files": 2,
    "commits": 2,
    "review_comments": 10,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 143605586,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0MzYwNTU4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/143605586",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-27T23:58:14Z",
      "updated_at": "2015-09-27T23:58:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "Perhaps foolishly I made the flags handling in secp256k1_ec_pubkey_serialize absolutely strict. Is this what we want to do? ... would we really ever want to add any more flags there? (hybrid? 0_o).\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#issuecomment-143605586",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTAxNjA6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "commented",
      "id": 144279925,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0NDI3OTkyNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/144279925",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-30T04:39:37Z",
      "updated_at": "2015-09-30T04:39:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Okay, flags test gone.\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#issuecomment-144279925",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTAxNjE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTAxNjU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTAxNjg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTAxNzE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "commented",
      "id": 147734338,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0NzczNDMzOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/147734338",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-10-13T14:36:29Z",
      "updated_at": "2015-10-13T14:36:29Z",
      "author_association": "MEMBER",
      "body": "ACK with tiny nits.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#issuecomment-147734338",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZWUyY2I0MDA3ZDA3ZDBhZGQ1Mjg5NGZmOTM1ZWM5NzIyMmNhZTk1Zg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ee2cb4007d07d0add52894ff935ec97222cae95f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ee2cb4007d07d0add52894ff935ec97222cae95f",
      "tree": {
        "sha": "c369bb467c2f4aaa70c2dc04dd98ab082dd98cbe",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c369bb467c2f4aaa70c2dc04dd98ab082dd98cbe"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7450ef171db18361962ce1cabc5f3f233648789b",
          "sha": "7450ef171db18361962ce1cabc5f3f233648789b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7450ef171db18361962ce1cabc5f3f233648789b"
        }
      ],
      "message": "Add ARG_CHECKs to secp256k1_ec_pubkey_parse/secp256k1_ec_pubkey_serialize\n\nThis also makes secp256k1_ec_pubkey_parse's init of pubkey more unconditional.",
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-10-13T19:39:58Z"
      },
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-09-27T23:45:12Z"
      },
      "sha": "ee2cb4007d07d0add52894ff935ec97222cae95f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NjdmN2RhNDA4NzRhNDJiODVjYjY1MzYzNDQ0NmU5MjgyMTQ3NDMxNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/67f7da40874a42b85cb653634446e92821474315",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/67f7da40874a42b85cb653634446e92821474315",
      "tree": {
        "sha": "9b111c1807a42d82ccd0702e6cba21f6e3b2c5df",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/9b111c1807a42d82ccd0702e6cba21f6e3b2c5df"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ee2cb4007d07d0add52894ff935ec97222cae95f",
          "sha": "ee2cb4007d07d0add52894ff935ec97222cae95f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ee2cb4007d07d0add52894ff935ec97222cae95f"
        }
      ],
      "message": "Extensive interface and operations tests for secp256k1_ec_pubkey_parse.\n\nThis also makes use of optional valgrind instrumentation if -DVALGRIND\n is set.\n\nThis also moves secp256k1.c above secp256k1.h in tests.c or otherwise\n we get non-null macros on the public functions which may defeat some\n of the VERIFY checks.",
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-10-13T19:47:55Z"
      },
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-09-27T23:47:01Z"
      },
      "sha": "67f7da40874a42b85cb653634446e92821474315"
    },
    {
      "event": "commented",
      "id": 147903233,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0NzkwMzIzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/147903233",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-10-14T02:00:39Z",
      "updated_at": "2015-10-14T02:00:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nits should all be corrected now.\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#issuecomment-147903233",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/319"
    },
    {
      "event": "merged",
      "id": 435143997,
      "node_id": "MDExOk1lcmdlZEV2ZW50NDM1MTQzOTk3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/435143997",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/67f7da40874a42b85cb653634446e92821474315",
      "created_at": "2015-10-14T12:32:33Z"
    },
    {
      "event": "closed",
      "id": 435143998,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDM1MTQzOTk4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/435143998",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-10-14T12:32:33Z"
    },
    {
      "event": "referenced",
      "id": 435144000,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQzNTE0NDAwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/435144000",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c98df263edcef836a229745320c0718d550975f9",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/c98df263edcef836a229745320c0718d550975f9",
      "created_at": "2015-10-14T12:32:33Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40743932",
      "pull_request_review_id": null,
      "id": 40743932,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzOTMy",
      "diff_hunk": "@@ -159,6 +162,11 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     secp256k1_ge Q;\n \n     (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output != NULL);\n+    ARG_CHECK(outputlen != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK((flags | SECP256K1_EC_COMPRESSED) == SECP256K1_EC_COMPRESSED);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 21,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "475880283fa7014c59ebc3a16dd010b9443fb2ee",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is more advanced flag checking in #324. Can you leave it for now?\n",
      "created_at": "2015-09-29T23:30:39Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r40743932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40743932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40744651",
      "pull_request_review_id": null,
      "id": 40744651,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ0NjUx",
      "diff_hunk": "@@ -159,6 +162,11 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     secp256k1_ge Q;\n \n     (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output != NULL);\n+    ARG_CHECK(outputlen != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK((flags | SECP256K1_EC_COMPRESSED) == SECP256K1_EC_COMPRESSED);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 21,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "475880283fa7014c59ebc3a16dd010b9443fb2ee",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure.  Do you mean leave all this checking out or just the flag part?\n",
      "created_at": "2015-09-29T23:41:31Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r40744651",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40744651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40750560",
      "pull_request_review_id": null,
      "id": 40750560,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNTYw",
      "diff_hunk": "@@ -159,6 +162,11 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     secp256k1_ge Q;\n \n     (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output != NULL);\n+    ARG_CHECK(outputlen != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK((flags | SECP256K1_EC_COMPRESSED) == SECP256K1_EC_COMPRESSED);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 21,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "475880283fa7014c59ebc3a16dd010b9443fb2ee",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just the flag part.\n",
      "created_at": "2015-09-30T01:24:10Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r40750560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40750560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40803815",
      "pull_request_review_id": null,
      "id": 40803815,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzODE1",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&\n+                ((i == 4) || ((i & 251) == ysign)) && ((pubkeyclen == 33) || (pubkeyclen == 65));\n+            if (xpass || ypass) {\n+                /* These cases must parse. */\n+                unsigned char pubkeyo[65];\n+                size_t outl;\n+                memset(&pubkey, 0, sizeof(pubkey));\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                ecount = 0;\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                outl = 65;\n+                VG_UNDEF(pubkeyo, 65);\n+                CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+                VG_CHECK(pubkeyo, outl);\n+                CHECK(outl == 33);\n+                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n+                if (ypass) {\n+                    /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n+                    CHECK(pubkeyo[0] == ysign);\n+                    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 1);\n+                    memset(&pubkey, 0, sizeof(pubkey));\n+                    VG_UNDEF(&pubkey, sizeof(pubkey));\n+                    secp256k1_pubkey_save(&pubkey, &ge);\n+                    VG_CHECK(&pubkey, sizeof(pubkey));\n+                    outl = 65;\n+                    VG_UNDEF(pubkeyo, 65);\n+                    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, 0) == 1);\n+                    VG_CHECK(pubkeyo, outl);\n+                    CHECK(outl == 65);\n+                    CHECK(pubkeyo[0] == 4);\n+                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                }\n+                CHECK(ecount == 0);\n+            } else {\n+                /* These cases must fail to parse. */\n+                memset(&pubkey, 0xfe, sizeof(pubkey));\n+                ecount = 0;\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 0);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                CHECK(ecount == 0);\n+                CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+                CHECK(ecount == 1);\n+            }\n+        }\n+    }\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+}\n+\n+void run_ec_pubkey_parse_test(void) {\n+#define SECP256K1_EC_PARSE_TEST_NVALID (12)\n+    const unsigned char valid[SECP256K1_EC_PARSE_TEST_NVALID][64] = {\n+        {\n+            /* Point with leading and trailing zeros in x and y serialization. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x52,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x64, 0xef, 0xa1, 0x7b, 0x77, 0x61, 0xe1, 0xe4, 0x27, 0x06, 0x98, 0x9f, 0xb4, 0x83,\n+            0xb8, 0xd2, 0xd4, 0x9b, 0xf7, 0x8f, 0xae, 0x98, 0x03, 0xf0, 0x99, 0xb8, 0x34, 0xed, 0xeb, 0x00\n+        },\n+        {\n+            /* Point with x equal to a 3rd root of unity.*/\n+            0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10, 0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,\n+            0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95, 0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with largest x. (1/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0x0e, 0x99, 0x4b, 0x14, 0xea, 0x72, 0xf8, 0xc3, 0xeb, 0x95, 0xc7, 0x1e, 0xf6, 0x92, 0x57, 0x5e,\n+            0x77, 0x50, 0x58, 0x33, 0x2d, 0x7e, 0x52, 0xd0, 0x99, 0x5c, 0xf8, 0x03, 0x88, 0x71, 0xb6, 0x7d,\n+        },\n+        {\n+            /* Point with largest x. (2/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0xf1, 0x66, 0xb4, 0xeb, 0x15, 0x8d, 0x07, 0x3c, 0x14, 0x6a, 0x38, 0xe1, 0x09, 0x6d, 0xa8, 0xa1,\n+            0x88, 0xaf, 0xa7, 0xcc, 0xd2, 0x81, 0xad, 0x2f, 0x66, 0xa3, 0x07, 0xfb, 0x77, 0x8e, 0x45, 0xb2,\n+        },\n+        {\n+            /* Point with smallest x. (1/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with smallest x. (2/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* Point with largest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with smallest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NXVALID (4)\n+    const unsigned char onlyxvalid[SECP256K1_EC_PARSE_TEST_NXVALID][64] = {\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (3/3)*/\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* x on curve, y is from y^2 = x^3 + 8. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NINVALID (7)\n+    const unsigned char invalid[SECP256K1_EC_PARSE_TEST_NINVALID][64] = {\n+        {\n+            /* x is third root of -8, y is abs(x^3+7); also on the curve for y^2 = x^3 + 9. */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 244,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "719f0c3c9db908ea06702a52654be77ae94425ee",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think 'abs' has much meaning in a finite field...\n",
      "created_at": "2015-09-30T14:55:06Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r40803815",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40803815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40840592",
      "pull_request_review_id": null,
      "id": 40840592,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNTky",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&\n+                ((i == 4) || ((i & 251) == ysign)) && ((pubkeyclen == 33) || (pubkeyclen == 65));\n+            if (xpass || ypass) {\n+                /* These cases must parse. */\n+                unsigned char pubkeyo[65];\n+                size_t outl;\n+                memset(&pubkey, 0, sizeof(pubkey));\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                ecount = 0;\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                outl = 65;\n+                VG_UNDEF(pubkeyo, 65);\n+                CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+                VG_CHECK(pubkeyo, outl);\n+                CHECK(outl == 33);\n+                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n+                if (ypass) {\n+                    /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n+                    CHECK(pubkeyo[0] == ysign);\n+                    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 1);\n+                    memset(&pubkey, 0, sizeof(pubkey));\n+                    VG_UNDEF(&pubkey, sizeof(pubkey));\n+                    secp256k1_pubkey_save(&pubkey, &ge);\n+                    VG_CHECK(&pubkey, sizeof(pubkey));\n+                    outl = 65;\n+                    VG_UNDEF(pubkeyo, 65);\n+                    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, 0) == 1);\n+                    VG_CHECK(pubkeyo, outl);\n+                    CHECK(outl == 65);\n+                    CHECK(pubkeyo[0] == 4);\n+                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                }\n+                CHECK(ecount == 0);\n+            } else {\n+                /* These cases must fail to parse. */\n+                memset(&pubkey, 0xfe, sizeof(pubkey));\n+                ecount = 0;\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 0);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                CHECK(ecount == 0);\n+                CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+                CHECK(ecount == 1);\n+            }\n+        }\n+    }\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+}\n+\n+void run_ec_pubkey_parse_test(void) {\n+#define SECP256K1_EC_PARSE_TEST_NVALID (12)\n+    const unsigned char valid[SECP256K1_EC_PARSE_TEST_NVALID][64] = {\n+        {\n+            /* Point with leading and trailing zeros in x and y serialization. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x52,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x64, 0xef, 0xa1, 0x7b, 0x77, 0x61, 0xe1, 0xe4, 0x27, 0x06, 0x98, 0x9f, 0xb4, 0x83,\n+            0xb8, 0xd2, 0xd4, 0x9b, 0xf7, 0x8f, 0xae, 0x98, 0x03, 0xf0, 0x99, 0xb8, 0x34, 0xed, 0xeb, 0x00\n+        },\n+        {\n+            /* Point with x equal to a 3rd root of unity.*/\n+            0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10, 0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,\n+            0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95, 0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with largest x. (1/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0x0e, 0x99, 0x4b, 0x14, 0xea, 0x72, 0xf8, 0xc3, 0xeb, 0x95, 0xc7, 0x1e, 0xf6, 0x92, 0x57, 0x5e,\n+            0x77, 0x50, 0x58, 0x33, 0x2d, 0x7e, 0x52, 0xd0, 0x99, 0x5c, 0xf8, 0x03, 0x88, 0x71, 0xb6, 0x7d,\n+        },\n+        {\n+            /* Point with largest x. (2/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0xf1, 0x66, 0xb4, 0xeb, 0x15, 0x8d, 0x07, 0x3c, 0x14, 0x6a, 0x38, 0xe1, 0x09, 0x6d, 0xa8, 0xa1,\n+            0x88, 0xaf, 0xa7, 0xcc, 0xd2, 0x81, 0xad, 0x2f, 0x66, 0xa3, 0x07, 0xfb, 0x77, 0x8e, 0x45, 0xb2,\n+        },\n+        {\n+            /* Point with smallest x. (1/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with smallest x. (2/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* Point with largest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with smallest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NXVALID (4)\n+    const unsigned char onlyxvalid[SECP256K1_EC_PARSE_TEST_NXVALID][64] = {\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (3/3)*/\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* x on curve, y is from y^2 = x^3 + 8. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NINVALID (7)\n+    const unsigned char invalid[SECP256K1_EC_PARSE_TEST_NINVALID][64] = {\n+        {\n+            /* x is third root of -8, y is abs(x^3+7); also on the curve for y^2 = x^3 + 9. */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 244,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "719f0c3c9db908ea06702a52654be77ae94425ee",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you mean sqrt?\n",
      "created_at": "2015-09-30T19:36:22Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r40840592",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/40840592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41868676",
      "pull_request_review_id": null,
      "id": 41868676,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4Njc2",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&",
      "path": "src/tests.c",
      "position": null,
      "original_position": 71,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "e80959175b02fd8b66f2a3daa7fb767ba26f9848",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm confused about what ypass means, if it can also be true for 33-byte pubkeys?\n",
      "created_at": "2015-10-13T14:02:23Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r41868676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41868676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1806,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41870904",
      "pull_request_review_id": null,
      "id": 41870904,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcwOTA0",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&",
      "path": "src/tests.c",
      "position": null,
      "original_position": 71,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "e80959175b02fd8b66f2a3daa7fb767ba26f9848",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Got it. It means \"when taking the current prefix byte + subsequence of input, we can parse and reserialize the result as uncompressed, and it will be identical to the input\". Took me 10 minutes :)\n",
      "created_at": "2015-10-13T14:19:15Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r41870904",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41870904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1806,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41872316",
      "pull_request_review_id": null,
      "id": 41872316,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMzE2",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&\n+                ((i == 4) || ((i & 251) == ysign)) && ((pubkeyclen == 33) || (pubkeyclen == 65));\n+            if (xpass || ypass) {\n+                /* These cases must parse. */\n+                unsigned char pubkeyo[65];\n+                size_t outl;\n+                memset(&pubkey, 0, sizeof(pubkey));\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                ecount = 0;\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                outl = 65;\n+                VG_UNDEF(pubkeyo, 65);\n+                CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+                VG_CHECK(pubkeyo, outl);\n+                CHECK(outl == 33);\n+                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n+                if (ypass) {\n+                    /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n+                    CHECK(pubkeyo[0] == ysign);\n+                    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 1);\n+                    memset(&pubkey, 0, sizeof(pubkey));\n+                    VG_UNDEF(&pubkey, sizeof(pubkey));\n+                    secp256k1_pubkey_save(&pubkey, &ge);\n+                    VG_CHECK(&pubkey, sizeof(pubkey));\n+                    outl = 65;\n+                    VG_UNDEF(pubkeyo, 65);\n+                    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, 0) == 1);\n+                    VG_CHECK(pubkeyo, outl);\n+                    CHECK(outl == 65);\n+                    CHECK(pubkeyo[0] == 4);\n+                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                }\n+                CHECK(ecount == 0);\n+            } else {\n+                /* These cases must fail to parse. */\n+                memset(&pubkey, 0xfe, sizeof(pubkey));\n+                ecount = 0;\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 0);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                CHECK(ecount == 0);\n+                CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+                CHECK(ecount == 1);\n+            }\n+        }\n+    }\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+}\n+\n+void run_ec_pubkey_parse_test(void) {\n+#define SECP256K1_EC_PARSE_TEST_NVALID (12)\n+    const unsigned char valid[SECP256K1_EC_PARSE_TEST_NVALID][64] = {\n+        {\n+            /* Point with leading and trailing zeros in x and y serialization. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x52,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x64, 0xef, 0xa1, 0x7b, 0x77, 0x61, 0xe1, 0xe4, 0x27, 0x06, 0x98, 0x9f, 0xb4, 0x83,\n+            0xb8, 0xd2, 0xd4, 0x9b, 0xf7, 0x8f, 0xae, 0x98, 0x03, 0xf0, 0x99, 0xb8, 0x34, 0xed, 0xeb, 0x00\n+        },\n+        {\n+            /* Point with x equal to a 3rd root of unity.*/\n+            0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10, 0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,\n+            0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95, 0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with largest x. (1/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0x0e, 0x99, 0x4b, 0x14, 0xea, 0x72, 0xf8, 0xc3, 0xeb, 0x95, 0xc7, 0x1e, 0xf6, 0x92, 0x57, 0x5e,\n+            0x77, 0x50, 0x58, 0x33, 0x2d, 0x7e, 0x52, 0xd0, 0x99, 0x5c, 0xf8, 0x03, 0x88, 0x71, 0xb6, 0x7d,\n+        },\n+        {\n+            /* Point with largest x. (2/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0xf1, 0x66, 0xb4, 0xeb, 0x15, 0x8d, 0x07, 0x3c, 0x14, 0x6a, 0x38, 0xe1, 0x09, 0x6d, 0xa8, 0xa1,\n+            0x88, 0xaf, 0xa7, 0xcc, 0xd2, 0x81, 0xad, 0x2f, 0x66, 0xa3, 0x07, 0xfb, 0x77, 0x8e, 0x45, 0xb2,\n+        },\n+        {\n+            /* Point with smallest x. (1/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with smallest x. (2/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* Point with largest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with smallest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NXVALID (4)\n+    const unsigned char onlyxvalid[SECP256K1_EC_PARSE_TEST_NXVALID][64] = {\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (3/3)*/\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* x on curve, y is from y^2 = x^3 + 8. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NINVALID (7)\n+    const unsigned char invalid[SECP256K1_EC_PARSE_TEST_NINVALID][64] = {\n+        {\n+            /* x is third root of -8, y is -1 * (x^3+7); also on the curve for y^2 = x^3 + 9. */\n+            0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c,\n+            0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0xf4, 0x84, 0x14, 0x5c, 0xb0, 0x14, 0x9b, 0x82, 0x5d, 0xff, 0x41, 0x2f, 0xa0, 0x52, 0xa8, 0x3f,\n+            0xcb, 0x72, 0xdb, 0x61, 0xd5, 0x6f, 0x37, 0x70, 0xce, 0x06, 0x6b, 0x73, 0x49, 0xa2, 0xaa, 0x28,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0x0b, 0x7b, 0xeb, 0xa3, 0x4f, 0xeb, 0x64, 0x7d, 0xa2, 0x00, 0xbe, 0xd0, 0x5f, 0xad, 0x57, 0xc0,\n+            0x34, 0x8d, 0x24, 0x9e, 0x2a, 0x90, 0xc8, 0x8f, 0x31, 0xf9, 0x94, 0x8b, 0xb6, 0x5d, 0x52, 0x07,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x8f, 0x53, 0x7e, 0xef, 0xdf, 0xc1, 0x60, 0x6a, 0x07, 0x27, 0xcd, 0x69, 0xb4, 0xa7, 0x33, 0x3d,\n+            0x38, 0xed, 0x44, 0xe3, 0x93, 0x2a, 0x71, 0x79, 0xee, 0xcb, 0x4b, 0x6f, 0xba, 0x93, 0x60, 0xdc,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x70, 0xac, 0x81, 0x10, 0x20, 0x3e, 0x9f, 0x95, 0xf8, 0xd8, 0x32, 0x96, 0x4b, 0x58, 0xcc, 0xc2,\n+            0xc7, 0x12, 0xbb, 0x1c, 0x6c, 0xd5, 0x8e, 0x86, 0x11, 0x34, 0xb4, 0x8f, 0x45, 0x6c, 0x9b, 0x53\n+        }\n+    };\n+    const unsigned char pubkeyc[65] = {\n+        /* Serialization of G. */\n+        0x04, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+        0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+        0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08,\n+        0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4,\n+        0xB8\n+    };\n+    unsigned char shortkey[2];\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    int32_t i;\n+    int32_t ecount;\n+    int32_t ecount2;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    /* Zero length claimed, fail, zeroize, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(shortkey, 2);\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 0) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 1);\n+    /* Length one claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 256 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i;\n+        VG_UNDEF(&shortkey[1], 1);\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 1) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* Length two claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 65536 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i & 255;\n+        shortkey[1] = i >> 8;\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 2) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* 33 bytes claimed on otherwise valid input starting with 0x04, fail, zeroize output, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));",
      "path": "src/tests.c",
      "position": null,
      "original_position": 346,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "e80959175b02fd8b66f2a3daa7fb767ba26f9848",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems it starts with 0xfe, not with 0x04?\n",
      "created_at": "2015-10-13T14:28:20Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r41872316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41872316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2082,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41872853",
      "pull_request_review_id": null,
      "id": 41872853,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyODUz",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&\n+                ((i == 4) || ((i & 251) == ysign)) && ((pubkeyclen == 33) || (pubkeyclen == 65));\n+            if (xpass || ypass) {\n+                /* These cases must parse. */\n+                unsigned char pubkeyo[65];\n+                size_t outl;\n+                memset(&pubkey, 0, sizeof(pubkey));\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                ecount = 0;\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                outl = 65;\n+                VG_UNDEF(pubkeyo, 65);\n+                CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+                VG_CHECK(pubkeyo, outl);\n+                CHECK(outl == 33);\n+                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n+                if (ypass) {\n+                    /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n+                    CHECK(pubkeyo[0] == ysign);\n+                    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 1);\n+                    memset(&pubkey, 0, sizeof(pubkey));\n+                    VG_UNDEF(&pubkey, sizeof(pubkey));\n+                    secp256k1_pubkey_save(&pubkey, &ge);\n+                    VG_CHECK(&pubkey, sizeof(pubkey));\n+                    outl = 65;\n+                    VG_UNDEF(pubkeyo, 65);\n+                    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, 0) == 1);\n+                    VG_CHECK(pubkeyo, outl);\n+                    CHECK(outl == 65);\n+                    CHECK(pubkeyo[0] == 4);\n+                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                }\n+                CHECK(ecount == 0);\n+            } else {\n+                /* These cases must fail to parse. */\n+                memset(&pubkey, 0xfe, sizeof(pubkey));\n+                ecount = 0;\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 0);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                CHECK(ecount == 0);\n+                CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+                CHECK(ecount == 1);\n+            }\n+        }\n+    }\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+}\n+\n+void run_ec_pubkey_parse_test(void) {\n+#define SECP256K1_EC_PARSE_TEST_NVALID (12)\n+    const unsigned char valid[SECP256K1_EC_PARSE_TEST_NVALID][64] = {\n+        {\n+            /* Point with leading and trailing zeros in x and y serialization. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x52,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x64, 0xef, 0xa1, 0x7b, 0x77, 0x61, 0xe1, 0xe4, 0x27, 0x06, 0x98, 0x9f, 0xb4, 0x83,\n+            0xb8, 0xd2, 0xd4, 0x9b, 0xf7, 0x8f, 0xae, 0x98, 0x03, 0xf0, 0x99, 0xb8, 0x34, 0xed, 0xeb, 0x00\n+        },\n+        {\n+            /* Point with x equal to a 3rd root of unity.*/\n+            0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10, 0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,\n+            0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95, 0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with largest x. (1/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0x0e, 0x99, 0x4b, 0x14, 0xea, 0x72, 0xf8, 0xc3, 0xeb, 0x95, 0xc7, 0x1e, 0xf6, 0x92, 0x57, 0x5e,\n+            0x77, 0x50, 0x58, 0x33, 0x2d, 0x7e, 0x52, 0xd0, 0x99, 0x5c, 0xf8, 0x03, 0x88, 0x71, 0xb6, 0x7d,\n+        },\n+        {\n+            /* Point with largest x. (2/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0xf1, 0x66, 0xb4, 0xeb, 0x15, 0x8d, 0x07, 0x3c, 0x14, 0x6a, 0x38, 0xe1, 0x09, 0x6d, 0xa8, 0xa1,\n+            0x88, 0xaf, 0xa7, 0xcc, 0xd2, 0x81, 0xad, 0x2f, 0x66, 0xa3, 0x07, 0xfb, 0x77, 0x8e, 0x45, 0xb2,\n+        },\n+        {\n+            /* Point with smallest x. (1/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with smallest x. (2/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* Point with largest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with smallest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NXVALID (4)\n+    const unsigned char onlyxvalid[SECP256K1_EC_PARSE_TEST_NXVALID][64] = {\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (3/3)*/\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* x on curve, y is from y^2 = x^3 + 8. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NINVALID (7)\n+    const unsigned char invalid[SECP256K1_EC_PARSE_TEST_NINVALID][64] = {\n+        {\n+            /* x is third root of -8, y is -1 * (x^3+7); also on the curve for y^2 = x^3 + 9. */\n+            0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c,\n+            0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0xf4, 0x84, 0x14, 0x5c, 0xb0, 0x14, 0x9b, 0x82, 0x5d, 0xff, 0x41, 0x2f, 0xa0, 0x52, 0xa8, 0x3f,\n+            0xcb, 0x72, 0xdb, 0x61, 0xd5, 0x6f, 0x37, 0x70, 0xce, 0x06, 0x6b, 0x73, 0x49, 0xa2, 0xaa, 0x28,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0x0b, 0x7b, 0xeb, 0xa3, 0x4f, 0xeb, 0x64, 0x7d, 0xa2, 0x00, 0xbe, 0xd0, 0x5f, 0xad, 0x57, 0xc0,\n+            0x34, 0x8d, 0x24, 0x9e, 0x2a, 0x90, 0xc8, 0x8f, 0x31, 0xf9, 0x94, 0x8b, 0xb6, 0x5d, 0x52, 0x07,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x8f, 0x53, 0x7e, 0xef, 0xdf, 0xc1, 0x60, 0x6a, 0x07, 0x27, 0xcd, 0x69, 0xb4, 0xa7, 0x33, 0x3d,\n+            0x38, 0xed, 0x44, 0xe3, 0x93, 0x2a, 0x71, 0x79, 0xee, 0xcb, 0x4b, 0x6f, 0xba, 0x93, 0x60, 0xdc,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x70, 0xac, 0x81, 0x10, 0x20, 0x3e, 0x9f, 0x95, 0xf8, 0xd8, 0x32, 0x96, 0x4b, 0x58, 0xcc, 0xc2,\n+            0xc7, 0x12, 0xbb, 0x1c, 0x6c, 0xd5, 0x8e, 0x86, 0x11, 0x34, 0xb4, 0x8f, 0x45, 0x6c, 0x9b, 0x53\n+        }\n+    };\n+    const unsigned char pubkeyc[65] = {\n+        /* Serialization of G. */\n+        0x04, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+        0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+        0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08,\n+        0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4,\n+        0xB8\n+    };\n+    unsigned char shortkey[2];\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    int32_t i;\n+    int32_t ecount;\n+    int32_t ecount2;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    /* Zero length claimed, fail, zeroize, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(shortkey, 2);\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 0) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 1);\n+    /* Length one claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 256 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i;\n+        VG_UNDEF(&shortkey[1], 1);\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 1) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* Length two claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 65536 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i & 255;\n+        shortkey[1] = i >> 8;\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 2) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* 33 bytes claimed on otherwise valid input starting with 0x04, fail, zeroize output, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));",
      "path": "src/tests.c",
      "position": null,
      "original_position": 346,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "e80959175b02fd8b66f2a3daa7fb767ba26f9848",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nevermind, pubkeyc vs pubkey...\n",
      "created_at": "2015-10-13T14:31:53Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r41872853",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41872853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2082,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41873381",
      "pull_request_review_id": null,
      "id": 41873381,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMzgx",
      "diff_hunk": "@@ -1752,6 +1763,395 @@ void run_endomorphism_tests(void) {\n }\n #endif\n \n+static void counting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts. */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)++;\n+}\n+\n+static void uncounting_illegal_callback_fn(const char* str, void* data) {\n+    /* Dummy callback function that just counts (backwards). */\n+    int32_t *p;\n+    (void)str;\n+    p = data;\n+    (*p)--;\n+}\n+\n+void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n+    unsigned char pubkeyc[65];\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ge ge;\n+    size_t pubkeyclen;\n+    int32_t ecount;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    for (pubkeyclen = 3; pubkeyclen <= 65; pubkeyclen++) {\n+        /* Smaller sizes are tested exhaustively elsewhere. */\n+        int32_t i;\n+        memcpy(&pubkeyc[1], input, 64);\n+        VG_UNDEF(&pubkeyc[pubkeyclen], 65 - pubkeyclen);\n+        for (i = 0; i < 256; i++) {\n+            /* Try all type bytes. */\n+            int xpass;\n+            int ypass;\n+            int ysign;\n+            pubkeyc[0] = i;\n+            /* What sign does this point have? */\n+            ysign = (input[63] & 1) + 2;\n+            /* For the current type (i) do we expect parsing to work? Handled all of compressed/uncompressed/hybrid. */\n+            xpass = xvalid && (pubkeyclen == 33) && ((i & 254) == 2);\n+            ypass = xvalid && yvalid && ((i & 4) == ((pubkeyclen == 65) << 2)) &&\n+                ((i == 4) || ((i & 251) == ysign)) && ((pubkeyclen == 33) || (pubkeyclen == 65));\n+            if (xpass || ypass) {\n+                /* These cases must parse. */\n+                unsigned char pubkeyo[65];\n+                size_t outl;\n+                memset(&pubkey, 0, sizeof(pubkey));\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                ecount = 0;\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                outl = 65;\n+                VG_UNDEF(pubkeyo, 65);\n+                CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+                VG_CHECK(pubkeyo, outl);\n+                CHECK(outl == 33);\n+                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n+                if (ypass) {\n+                    /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n+                    CHECK(pubkeyo[0] == ysign);\n+                    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 1);\n+                    memset(&pubkey, 0, sizeof(pubkey));\n+                    VG_UNDEF(&pubkey, sizeof(pubkey));\n+                    secp256k1_pubkey_save(&pubkey, &ge);\n+                    VG_CHECK(&pubkey, sizeof(pubkey));\n+                    outl = 65;\n+                    VG_UNDEF(pubkeyo, 65);\n+                    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, 0) == 1);\n+                    VG_CHECK(pubkeyo, outl);\n+                    CHECK(outl == 65);\n+                    CHECK(pubkeyo[0] == 4);\n+                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                }\n+                CHECK(ecount == 0);\n+            } else {\n+                /* These cases must fail to parse. */\n+                memset(&pubkey, 0xfe, sizeof(pubkey));\n+                ecount = 0;\n+                VG_UNDEF(&pubkey, sizeof(pubkey));\n+                CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 0);\n+                VG_CHECK(&pubkey, sizeof(pubkey));\n+                CHECK(ecount == 0);\n+                CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+                CHECK(ecount == 1);\n+            }\n+        }\n+    }\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+}\n+\n+void run_ec_pubkey_parse_test(void) {\n+#define SECP256K1_EC_PARSE_TEST_NVALID (12)\n+    const unsigned char valid[SECP256K1_EC_PARSE_TEST_NVALID][64] = {\n+        {\n+            /* Point with leading and trailing zeros in x and y serialization. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x52,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x64, 0xef, 0xa1, 0x7b, 0x77, 0x61, 0xe1, 0xe4, 0x27, 0x06, 0x98, 0x9f, 0xb4, 0x83,\n+            0xb8, 0xd2, 0xd4, 0x9b, 0xf7, 0x8f, 0xae, 0x98, 0x03, 0xf0, 0x99, 0xb8, 0x34, 0xed, 0xeb, 0x00\n+        },\n+        {\n+            /* Point with x equal to a 3rd root of unity.*/\n+            0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10, 0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,\n+            0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95, 0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with largest x. (1/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0x0e, 0x99, 0x4b, 0x14, 0xea, 0x72, 0xf8, 0xc3, 0xeb, 0x95, 0xc7, 0x1e, 0xf6, 0x92, 0x57, 0x5e,\n+            0x77, 0x50, 0x58, 0x33, 0x2d, 0x7e, 0x52, 0xd0, 0x99, 0x5c, 0xf8, 0x03, 0x88, 0x71, 0xb6, 0x7d,\n+        },\n+        {\n+            /* Point with largest x. (2/2) */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2c,\n+            0xf1, 0x66, 0xb4, 0xeb, 0x15, 0x8d, 0x07, 0x3c, 0x14, 0x6a, 0x38, 0xe1, 0x09, 0x6d, 0xa8, 0xa1,\n+            0x88, 0xaf, 0xa7, 0xcc, 0xd2, 0x81, 0xad, 0x2f, 0x66, 0xa3, 0x07, 0xfb, 0x77, 0x8e, 0x45, 0xb2,\n+        },\n+        {\n+            /* Point with smallest x. (1/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Point with smallest x. (2/2) */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* Point with largest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with largest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+        },\n+        {\n+            /* Point with smallest y. (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Point with smallest y. (3/3) */\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NXVALID (4)\n+    const unsigned char onlyxvalid[SECP256K1_EC_PARSE_TEST_NXVALID][64] = {\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (1/3) */\n+            0x1f, 0xe1, 0xe5, 0xef, 0x3f, 0xce, 0xb5, 0xc1, 0x35, 0xab, 0x77, 0x41, 0x33, 0x3c, 0xe5, 0xa6,\n+            0xe8, 0x0d, 0x68, 0x16, 0x76, 0x53, 0xf6, 0xb2, 0xb2, 0x4b, 0xcb, 0xcf, 0xaa, 0xaf, 0xf5, 0x07,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (2/3) */\n+            0xcb, 0xb0, 0xde, 0xab, 0x12, 0x57, 0x54, 0xf1, 0xfd, 0xb2, 0x03, 0x8b, 0x04, 0x34, 0xed, 0x9c,\n+            0xb3, 0xfb, 0x53, 0xab, 0x73, 0x53, 0x91, 0x12, 0x99, 0x94, 0xa5, 0x35, 0xd9, 0x25, 0xf6, 0x73,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* Valid if y overflow ignored (y = 1 mod p). (3/3)*/\n+            0x14, 0x6d, 0x3b, 0x65, 0xad, 0xd9, 0xf5, 0x4c, 0xcc, 0xa2, 0x85, 0x33, 0xc8, 0x8e, 0x2c, 0xbc,\n+            0x63, 0xf7, 0x44, 0x3e, 0x16, 0x58, 0x78, 0x3a, 0xb4, 0x1f, 0x8e, 0xf9, 0x7c, 0x2a, 0x10, 0xb5,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+        },\n+        {\n+            /* x on curve, y is from y^2 = x^3 + 8. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n+        }\n+    };\n+#define SECP256K1_EC_PARSE_TEST_NINVALID (7)\n+    const unsigned char invalid[SECP256K1_EC_PARSE_TEST_NINVALID][64] = {\n+        {\n+            /* x is third root of -8, y is -1 * (x^3+7); also on the curve for y^2 = x^3 + 9. */\n+            0x0a, 0x2d, 0x2b, 0xa9, 0x35, 0x07, 0xf1, 0xdf, 0x23, 0x37, 0x70, 0xc2, 0xa7, 0x97, 0x96, 0x2c,\n+            0xc6, 0x1f, 0x6d, 0x15, 0xda, 0x14, 0xec, 0xd4, 0x7d, 0x8d, 0x27, 0xae, 0x1c, 0xd5, 0xf8, 0x53,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0x42, 0x18, 0xf2, 0x0a, 0xe6, 0xc6, 0x46, 0xb3, 0x63, 0xdb, 0x68, 0x60, 0x58, 0x22, 0xfb, 0x14,\n+            0x26, 0x4c, 0xa8, 0xd2, 0x58, 0x7f, 0xdd, 0x6f, 0xbc, 0x75, 0x0d, 0x58, 0x7e, 0x76, 0xa7, 0xee,\n+        },\n+        {\n+            /* Valid if x overflow ignored (x = 1 mod p). */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x30,\n+            0xbd, 0xe7, 0x0d, 0xf5, 0x19, 0x39, 0xb9, 0x4c, 0x9c, 0x24, 0x97, 0x9f, 0xa7, 0xdd, 0x04, 0xeb,\n+            0xd9, 0xb3, 0x57, 0x2d, 0xa7, 0x80, 0x22, 0x90, 0x43, 0x8a, 0xf2, 0xa6, 0x81, 0x89, 0x54, 0x41,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0xf4, 0x84, 0x14, 0x5c, 0xb0, 0x14, 0x9b, 0x82, 0x5d, 0xff, 0x41, 0x2f, 0xa0, 0x52, 0xa8, 0x3f,\n+            0xcb, 0x72, 0xdb, 0x61, 0xd5, 0x6f, 0x37, 0x70, 0xce, 0x06, 0x6b, 0x73, 0x49, 0xa2, 0xaa, 0x28,\n+        },\n+        {\n+            /* x is -1, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 5. */\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2e,\n+            0x0b, 0x7b, 0xeb, 0xa3, 0x4f, 0xeb, 0x64, 0x7d, 0xa2, 0x00, 0xbe, 0xd0, 0x5f, 0xad, 0x57, 0xc0,\n+            0x34, 0x8d, 0x24, 0x9e, 0x2a, 0x90, 0xc8, 0x8f, 0x31, 0xf9, 0x94, 0x8b, 0xb6, 0x5d, 0x52, 0x07,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x8f, 0x53, 0x7e, 0xef, 0xdf, 0xc1, 0x60, 0x6a, 0x07, 0x27, 0xcd, 0x69, 0xb4, 0xa7, 0x33, 0x3d,\n+            0x38, 0xed, 0x44, 0xe3, 0x93, 0x2a, 0x71, 0x79, 0xee, 0xcb, 0x4b, 0x6f, 0xba, 0x93, 0x60, 0xdc,\n+        },\n+        {\n+            /* x is zero, y is the result of the sqrt ladder; also on the curve for y^2 = x^3 - 7. */\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x70, 0xac, 0x81, 0x10, 0x20, 0x3e, 0x9f, 0x95, 0xf8, 0xd8, 0x32, 0x96, 0x4b, 0x58, 0xcc, 0xc2,\n+            0xc7, 0x12, 0xbb, 0x1c, 0x6c, 0xd5, 0x8e, 0x86, 0x11, 0x34, 0xb4, 0x8f, 0x45, 0x6c, 0x9b, 0x53\n+        }\n+    };\n+    const unsigned char pubkeyc[65] = {\n+        /* Serialization of G. */\n+        0x04, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+        0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+        0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08,\n+        0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4,\n+        0xB8\n+    };\n+    unsigned char shortkey[2];\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    int32_t i;\n+    int32_t ecount;\n+    int32_t ecount2;\n+    ecount = 0;\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    /* Zero length claimed, fail, zeroize, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(shortkey, 2);\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 0) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 1);\n+    /* Length one claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 256 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i;\n+        VG_UNDEF(&shortkey[1], 1);\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 1) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* Length two claimed, fail, zeroize, no illegal arg error. */\n+    for (i = 0; i < 65536 ; i++) {\n+        memset(&pubkey, 0xfe, sizeof(pubkey));\n+        ecount = 0;\n+        shortkey[0] = i & 255;\n+        shortkey[1] = i >> 8;\n+        VG_UNDEF(&pubkey, sizeof(pubkey));\n+        CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, shortkey, 2) == 0);\n+        VG_CHECK(&pubkey, sizeof(pubkey));\n+        CHECK(ecount == 0);\n+        CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+        CHECK(ecount == 1);\n+    }\n+    /* 33 bytes claimed on otherwise valid input starting with 0x04, fail, zeroize output, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, 33) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 1);\n+    /* NULL pubkey, illegal arg error. Pubkey isn't rewritten before this step, since it's NULL into the parser. */\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, NULL, pubkeyc, 65) == 0);\n+    CHECK(ecount == 2);\n+    /* NULL input string. Illegal arg and zeroize output. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, NULL, 65) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 2);\n+    /* 64 bytes claimed on input starting with 0x04, fail, zeroize output, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, 64) == 0);\n+    VG_CHECK(&pubkey, sizeof(pubkey));\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_pubkey_load(ctx, &ge, &pubkey) == 0);\n+    CHECK(ecount == 1);\n+    /* 66 bytes claimed, fail, zeroize output, no illegal arg error. */\n+    memset(&pubkey, 0xfe, sizeof(pubkey));\n+    ecount = 0;\n+    VG_UNDEF(&pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, 66) == 0);",
      "path": "src/tests.c",
      "position": 382,
      "original_position": 379,
      "commit_id": "67f7da40874a42b85cb653634446e92821474315",
      "original_commit_id": "e80959175b02fd8b66f2a3daa7fb767ba26f9848",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That looks like an error. We know ec_pubkey_parse won't go look beyond the 65th byte, but it's a bit ugly that the correctness of the test code relies on that. Can you add a padding byte to pubkeyc?\n",
      "created_at": "2015-10-13T14:35:35Z",
      "updated_at": "2015-10-13T19:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/319#discussion_r41873381",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/41873381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/319"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2116,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}