{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479",
    "id": 1667499858,
    "node_id": "PR_kwDOAP4Jqs5jZAdS",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1479.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1479.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
    "number": 1479,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add module \"musig\" that implements MuSig2 multi-signatures (BIP 327)",
    "user": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "EDIT: based on #1518. Closes #1452. Most of the code is a copy from [libsecp256k1-zkp](https://github.com/BlockstreamResearch/secp256k1-zkp). The API added in this PR is identical with the exception of two modifications:\r\n\r\n1. I removed the unused `scratch_space` argument from `secp256k1_musig_pubkey_agg`. This argument was intended to allow using `ecmult_multi` algorithms for key aggregation in the future. But at this point it's unclear whether the `scratch_space` object will remain in its current form (see #1302).\r\n2. Support for adaptor signatures was removed and therefore the `adaptor` argument of `musig_nonce_process` was also removed.\r\n\r\nIn contrast to the module in libsecp256k1-zkp, the module is non-experimental. I slightly cleaned up parts of the module, adjusted the code to the new definition of the VERIFY_CHECK macro and applied some simplifications that were possible because the module is now in the upstream repo (`ge_from_bytes`, `ge_to_bytes`). You can follow the changes I made to the libsecp256k1-zkp module at https://github.com/jonasnick/secp256k1-zkp/commits/musig2-upstream/.\r\n",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2024-01-06T20:40:28Z",
    "updated_at": "2024-06-30T12:50:34Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "37cbbeb8e1d5702e812f5b687225a94da66ab556",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "jonasnick:musig2-module",
      "ref": "musig2-module",
      "sha": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 57937974,
        "node_id": "MDEwOlJlcG9zaXRvcnk1NzkzNzk3NA==",
        "name": "secp256k1",
        "full_name": "jonasnick/secp256k1",
        "owner": {
          "login": "jonasnick",
          "id": 2582071,
          "node_id": "MDQ6VXNlcjI1ODIwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasnick",
          "html_url": "https://github.com/jonasnick",
          "followers_url": "https://api.github.com/users/jonasnick/followers",
          "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasnick/orgs",
          "repos_url": "https://api.github.com/users/jonasnick/repos",
          "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasnick/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasnick/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/jonasnick/secp256k1",
        "archive_url": "https://api.github.com/repos/jonasnick/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasnick/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasnick/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasnick/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasnick/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasnick/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasnick/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasnick/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasnick/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/jonasnick/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/jonasnick/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/jonasnick/secp256k1/events",
        "forks_url": "https://api.github.com/repos/jonasnick/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/jonasnick/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasnick/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasnick/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasnick/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasnick/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasnick/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasnick/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/jonasnick/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/jonasnick/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasnick/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasnick/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasnick/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasnick/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/jonasnick/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasnick/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasnick/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasnick/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/jonasnick/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/jonasnick/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/jonasnick/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasnick/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/jonasnick/secp256k1/hooks",
        "svn_url": "https://github.com/jonasnick/secp256k1",
        "language": "C",
        "forks_count": 4,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 12619,
        "default_branch": "master",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-05T14:50:17Z",
        "created_at": "2016-05-03T03:14:21Z",
        "updated_at": "2023-03-16T11:44:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 973,
        "stargazers_count": 2004,
        "watchers_count": 2004,
        "size": 11920,
        "default_branch": "master",
        "open_issues_count": 136,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-29T11:58:30Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2024-06-29T23:54:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 4370,
    "deletions": 28,
    "changed_files": 27,
    "commits": 4,
    "review_comments": 54,
    "comments": 6
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 11409680923,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoEeob",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11409680923",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-06T21:56:46Z"
    },
    {
      "event": "reviewed",
      "id": 1807791233,
      "node_id": "PRR_kwDOAP4Jqs5rwLSB",
      "url": null,
      "actor": null,
      "commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1807791233",
      "submitted_at": "2024-01-07T11:46:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1807791809,
      "node_id": "PRR_kwDOAP4Jqs5rwLbB",
      "url": null,
      "actor": null,
      "commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1807791809",
      "submitted_at": "2024-01-07T11:51:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411233157,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoKZmF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411233157",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T13:33:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411264369,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoKhNx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411264369",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T13:53:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411364230,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoK5mG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411364230",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T14:51:09Z"
    },
    {
      "event": "subscribed",
      "id": 11412133109,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKoN1T1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11412133109",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T22:40:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11414208869,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoVwFl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11414208869",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T07:51:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11414322009,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoWLtZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11414322009",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T08:06:21Z"
    },
    {
      "event": "subscribed",
      "id": 11421573982,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKox2Ne",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11421573982",
      "actor": {
        "login": "Synapsensei",
        "id": 99158059,
        "node_id": "U_kgDOBekIKw",
        "avatar_url": "https://avatars.githubusercontent.com/u/99158059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Synapsensei",
        "html_url": "https://github.com/Synapsensei",
        "followers_url": "https://api.github.com/users/Synapsensei/followers",
        "following_url": "https://api.github.com/users/Synapsensei/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Synapsensei/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Synapsensei/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Synapsensei/subscriptions",
        "organizations_url": "https://api.github.com/users/Synapsensei/orgs",
        "repos_url": "https://api.github.com/users/Synapsensei/repos",
        "events_url": "https://api.github.com/users/Synapsensei/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Synapsensei/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T19:15:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11456989422,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKq48ju",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11456989422",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T13:58:31Z"
    },
    {
      "event": "commented",
      "id": 1887221226,
      "node_id": "IC_kwDOAP4Jqs5wfLXq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1887221226",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T14:01:04Z",
      "updated_at": "2024-01-11T14:01:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on top of master to get https://github.com/bitcoin-core/secp256k1/pull/1480 which allowed dropping a commit. Old state is preserved at https://github.com/jonasnick/secp256k1/tree/musig2-module-backup.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1887221226",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "labeled",
      "id": 11458130949,
      "node_id": "LE_lADOAP4Jqs57T9BRzwAAAAKq9TQF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11458130949",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T15:25:05Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 1830151789,
      "node_id": "PRR_kwDOAP4Jqs5tFeZt",
      "url": null,
      "actor": null,
      "commit_id": "70bb68536d27d44ed0b0ae76be6790ae38d77ef6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "needs rebase :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1830151789",
      "submitted_at": "2024-01-18T16:55:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 1906155742,
      "node_id": "IC_kwDOAP4Jqs5xnaDe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1906155742",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T14:19:46Z",
      "updated_at": "2024-01-23T14:19:46Z",
      "author_association": "NONE",
      "body": "FWIW, we have JVM bindings on top of this branch in https://github.com/ACINQ/secp256k1-kmp/pull/93 and an implementation of swap-in-potentiam (musig2 key-path with alternative delayed script path) in https://github.com/ACINQ/bitcoin-kmp/pull/107 and everything is working fine, and the API is easy enough to use!",
      "user": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1906155742",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11575114955,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKx7jzL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575114955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:21:27Z"
    },
    {
      "event": "commented",
      "id": 1906775928,
      "node_id": "IC_kwDOAP4Jqs5xpxd4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1906775928",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:30Z",
      "updated_at": "2024-01-23T19:23:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.\r\n\r\nThanks @t-bast, that's good to hear.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1906775928",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 11575138578,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAKx7pkS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575138578",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:30Z"
    },
    {
      "event": "subscribed",
      "id": 11575138592,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKx7pkg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575138592",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:31Z"
    },
    {
      "event": "commented",
      "id": 1920536530,
      "node_id": "IC_kwDOAP4Jqs5yeQ_S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1920536530",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-01T05:21:26Z",
      "updated_at": "2024-02-13T04:19:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Attaching a visualization for the API flow.\r\n\r\n![musig2-api-flowchart](https://github.com/bitcoin-core/secp256k1/assets/56887198/9a7ce10a-4803-4ffe-aaf8-8832dc6ba108)\r\n\r\nEdit: The above visualization is incorrect. I will update it with the correct one soon.",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1920536530",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 1862362444,
      "node_id": "PRR_kwDOAP4Jqs5vAWVM",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1862362444",
      "submitted_at": "2024-02-05T10:27:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1864630385,
      "node_id": "PRR_kwDOAP4Jqs5vJABx",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1864630385",
      "submitted_at": "2024-02-06T10:21:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1922290796,
      "node_id": "PRR_kwDOAP4Jqs5yk9Rs",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1922290796",
      "submitted_at": "2024-03-07T12:18:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12065677534,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAALPK6De",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12065677534",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-10T14:57:47Z"
    },
    {
      "event": "reviewed",
      "id": 1935966419,
      "node_id": "PRR_kwDOAP4Jqs5zZIDT",
      "url": null,
      "actor": null,
      "commit_id": "2512e4b9431363cbd2998ce2ac43ab90c8134d37",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1935966419",
      "submitted_at": "2024-03-14T08:25:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1986650201,
      "node_id": "PRR_kwDOAP4Jqs52aeBZ",
      "url": null,
      "actor": null,
      "commit_id": "3b6c90a93fb55b2ea5fc629762bf4c3c569211cf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I'm also using the heapsort commits in #1471. What do you think about splitting out the sort commits into their own PR? Also fine with cherry-picking for now, but figured I'd mention it since it might simplify both of our PRs.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1986650201",
      "submitted_at": "2024-04-08T14:43:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12495477081,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAALoydlZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495477081",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:29:26Z"
    },
    {
      "event": "commented",
      "id": 2059792383,
      "node_id": "IC_kwDOAP4Jqs56xe__",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2059792383",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:39Z",
      "updated_at": "2024-04-16T19:32:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "@josibake \r\n\r\n>  What do you think about splitting out the sort commits into their own PR?\r\n\r\nThat's a good idea. In particular, if more fixups are needed for the sort commits. See #1518.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2059792383",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 12495520191,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAALoyoG_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495520191",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:40Z"
    },
    {
      "event": "subscribed",
      "id": 12495520202,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAALoyoHK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495520202",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:41Z"
    },
    {
      "event": "referenced",
      "id": 12716573112,
      "node_id": "REFE_lADOAP4Jqs57T9BRzwAAAAL194G4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12716573112",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "bb528cfb08761fde75c68751de7ded747ed51e84",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/bb528cfb08761fde75c68751de7ded747ed51e84",
      "created_at": "2024-05-06T15:18:33Z"
    },
    {
      "event": "commented",
      "id": 2148502564,
      "node_id": "IC_kwDOAP4Jqs6AD4wk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2148502564",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T22:17:04Z",
      "updated_at": "2024-06-04T22:17:04Z",
      "author_association": "MEMBER",
      "body": "Rebase perhaps? It'd be nice to get this in soon.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2148502564",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGVjNWIyMTY3NGM2MmFmMmI4ZmFmODcwZDllM2FkMjA0YzU4MzUyNGE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ec5b21674c62af2b8faf870d9e3ad204c583524a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ec5b21674c62af2b8faf870d9e3ad204c583524a",
      "tree": {
        "sha": "ee7bcb23658226c6d2a2bb74f08f7d53c1443223",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ee7bcb23658226c6d2a2bb74f08f7d53c1443223"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ee7bcb23658226c6d2a2bb74f08f7d53c1443223\nparent 1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704556410 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1717597180 +0000\n\ngroup: add ge_to_bytes and ge_from_bytes\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmZgc/8ACgkQSGHb8mIS\nNgVhCg//agS9E+BT8IeN07sCTsJGQJryYU1Tyq1NzX5Z+fUJg7H/MFexlrrTPXIe\nTYXhbYV+G4XcPy3QkaUPLxLDxAUN2u0XkJHMylAWPUePuAsqQsVCOe/Wf0EBRzwK\nGjueetAwvLaJCTkEA62ocTQ3PRMTn7TqjVaVRBNXcUfiwRFKF82TnRohyrHUIYs0\n742oG0Cqhh1z1G+6lTvYFNCPIM3b4mTw0VxLdGI7/W4I4Wu3hKv6F10PAmDIcY05\nb7IZhG7TU47hTN/xK+/JDN5e0akoTrOBKYn7tOCtBOm1R6jzEdIyqUUajTU3sVtL\nMDYh1E4gp0CdsOefmYbWg6cbAivFm1f72Q/FT+YbsJ455mHPR2V8DaPsDQTodvrC\nypVvSHFMJqI+hUm4wbvjeBR3y2f5B1AsY2vAn98pagmwMu9MdNVeuoeuNEqSRr9T\nOdxh7nn3x6J+h2qmfVAUOZ8KxaPOKw9XQTfiFngVdwkvF8oRADXcsVNJ6K1NSXUb\n3t/4nwZzWEIro1Jh2rfISmndyxEEqxPY4DGfzuW7BLhsKhTWGNfIYdJCJIwCvwWO\nfOSx4etuVVYVK2gfNyHrkyT9kl7lSTyrvzkrpTHR1rZ0SqbH2PtPu2X6yviBgnMV\nwmlJzNIbE7TQV+4gQmx4mpkBqCaJohfEw01QlyEpSfPIUSXD4no=\n=jPpX\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a",
          "sha": "1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a"
        }
      ],
      "message": "group: add ge_to_bytes and ge_from_bytes",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T14:19:40Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T15:53:30Z"
      },
      "sha": "ec5b21674c62af2b8faf870d9e3ad204c583524a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdmNjlmNGI5MTcxM2YwYjVhZmNjMTU5ZTE1NDllOGIyYjc1YjRmNjA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7f69f4b91713f0b5afcc159e1549e8b2b75b4f60",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7f69f4b91713f0b5afcc159e1549e8b2b75b4f60",
      "tree": {
        "sha": "264f7c035f00a335d7c2320f8d1d5d58c12cf423",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/264f7c035f00a335d7c2320f8d1d5d58c12cf423"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 264f7c035f00a335d7c2320f8d1d5d58c12cf423\nparent ec5b21674c62af2b8faf870d9e3ad204c583524a\nauthor Jonas Nick <jonasd.nick@gmail.com> 1717595301 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1717597271 +0000\n\ngroup: add ge_to_bytes_ext and ge_from_bytes_ext\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmZgdFcACgkQSGHb8mIS\nNgXCJg/+PeVwJeIzpsIrMIa7pZdLlrF+Ii/+LlxXvYqkorDGv4VQ8VjZpfjVjaUX\nq6Dl1hRSIgSbrxWVXS9mILHfFvVeLh1T33kBpWJFTWIus74zDci1v0EII1TzcHDe\ntl4WAKChEGFL41vrJjboKKJw3uX+r9nU5pzBJ35Ov+6GxZBoSooMtStvEfco1VTi\nf9q8eBBr9p0TwG9E+zU6FvYviV7er2ZRlo36v7lgAi4FvUB8nx2lNDXTn8zIUkDg\nLCrOrAU4S0s0Dc1Qwob8XwhxQDFHbbsyCNfsd5dU9Rvo39LDGPToN3fsA1UsDEcf\n3c/w3c8xhhwqtljk6tL/STgN/fZDuZQQO0W1HGJZ+ou+FimhyGcn/TdypIvvonHC\n/TkjvGYL77hJgjYft86GAg49nGknSBvs3VlQ8/8Zdax9ArFCvsPAt8Tyg1pmYv79\nsYhBvjp14xnmYcjJQoCuX9ZfxaqqsQ+RxF0fpKTqYd/o5Bjf8HYI82297seQEafa\nxZ+qGYGiy9Xo2EC5WhvB8hjpIF3jUTIVGAqhgiD1hWu0AuYupIW2wNpPBoEFtREN\nd5Cyb9ILtIft5MIDIWmpdWyIYJqDBeBEPemRgnwOvwE82LGlKhJJUQdRB/H8l9zJ\nkB4awrfmnS2Yhca4akEwOeACTnoNLfucYoYySb/7bIHxGXKFE2A=\n=u6DR\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ec5b21674c62af2b8faf870d9e3ad204c583524a",
          "sha": "ec5b21674c62af2b8faf870d9e3ad204c583524a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ec5b21674c62af2b8faf870d9e3ad204c583524a"
        }
      ],
      "message": "group: add ge_to_bytes_ext and ge_from_bytes_ext",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T14:21:11Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T13:48:21Z"
      },
      "sha": "7f69f4b91713f0b5afcc159e1549e8b2b75b4f60"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM5MzYyNjY0ZTY3MmVmZWVlOGEwYzFlZTg3NzkwNzE0MzJiNzgzOTQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c9362664e672efeee8a0c1ee8779071432b78394",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c9362664e672efeee8a0c1ee8779071432b78394",
      "tree": {
        "sha": "ad4fbbeabe48dfa0687c502154ac7205045e75ed",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ad4fbbeabe48dfa0687c502154ac7205045e75ed"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ad4fbbeabe48dfa0687c502154ac7205045e75ed\nparent 7f69f4b91713f0b5afcc159e1549e8b2b75b4f60\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704569478 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1717597275 +0000\n\nAdd module \"musig\" that implements MuSig2 multi-signatures (BIP 327)\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmZgdFsACgkQSGHb8mIS\nNgUcEA/+KKaf4t5mzsJ9RCRhHprQ+HZWUn8a3hdbKqKgmO7U/DNJiO41gO0XyUiy\n037UhIcy9PeFeAo3rI0HKjKL0slpzr7N0kVHLuj+sWt3GB/JR4uJdiQ6zLPf0oKY\nbIXttveCGNx8Ihz9qY9w2CbnMCIU0dUfklEvbH7gPokq7YEN2EjVaHZ8oHAt4ULF\nKDzgPY32ix1QA4I/UySoLLfj/LqgNR/EKQ83dwjoQr7fK/XW+r42ytGiXMdZRvJq\nTorss/3OgjUdqpOXIQodeypA4cEm+PzERPK4HMeBBLF1AxY75jata2B0/MTeYkmx\nEPSH7oajeDPvaHPTcnS8atl5YCNBEK+Zsg3IG558PV0MZUdZ1o++BpSQZWQzTqzn\nnsGYZ9hXuN2G8+wyzCRXkwH3/3ATo/yzi7/eXeC/283zMHJl9lRJL/bufCdKvVQ0\nh4NR6SR3Y/i00R4CeH8ewG1mYEfQFOMRreGz1XD1NViSLOQaBS9SolJDBoXC7fQM\nJChDcXGyJ4eSu6KWR+r5pLKBH/sqK8uJMwy/DNL9st3LY1Z3BB47JZ6JezRW5otW\nMbwLZZdRD7FDAyicLp5yld894/2dVUosoVrH+epqAyjumxBTdu0crQaTLl3myWxV\ncIWZV5dZX5XGbAf6w5YDbAOZrGZHwokCn3bmwhYSwYfTcmH3xz8=\n=yiYX\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7f69f4b91713f0b5afcc159e1549e8b2b75b4f60",
          "sha": "7f69f4b91713f0b5afcc159e1549e8b2b75b4f60",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7f69f4b91713f0b5afcc159e1549e8b2b75b4f60"
        }
      ],
      "message": "Add module \"musig\" that implements MuSig2 multi-signatures (BIP 327)",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T14:21:15Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T19:31:18Z"
      },
      "sha": "c9362664e672efeee8a0c1ee8779071432b78394"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc3NDg5YmY0MjJlMzcxNGI1YTVmNjQyN2I5N2VhNGVmOTFiZDM0ZGM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "tree": {
        "sha": "6a3ece833da0e84c79abb2a649c77d65cf90dbf3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/6a3ece833da0e84c79abb2a649c77d65cf90dbf3"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6a3ece833da0e84c79abb2a649c77d65cf90dbf3\nparent c9362664e672efeee8a0c1ee8779071432b78394\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704572247 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1717597275 +0000\n\nbuild: allow enabling the musig module in cmake\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmZgdFsACgkQSGHb8mIS\nNgUl8g//VXvJ2QwBktBU9vSYMiFstYgZgkRwS6Zp34nNqdFGWP4quwJXVKHtHb/r\nGxTAeX1JFbeL3U/+cr9iwE3udIpFuHgCISyJeK4wxcT40yekXllNW0HkLKDZNkU6\nyereO+lXuttgLMJLO6YZi2jMcOzvBR387DIcECIxGKvQR63XMN6toE7y6Q2e8Xvt\nPm39B9E8aexDWorjkDQG9cPAzYZny4Lqo3ST3ugB2JYLGsvGaxLDwjiFIa/uvpDN\n3uWP0xbslENsIMVcr9oi8XnuVhysC1XTh2VONk+9nzwBE3s4Rhn7Qr4y3VgcpP2i\nhmdjoa+obIbpTBfmbA8AM2JtuzwSWiTIIymeZnoYV6KQkkiZuOhJ4qAI0RE8KPk5\nmewimopnmQgJoFnPFm5KYp75u1AsX/hPK25ew7Jvz4MFzxXHKNqdMPiw898SMcLX\neTMKlw19iAjycQzWu+CAL3o2za7XeuomhRIrFaYF4fVdDiqkgwsFjv9LpGwaN/NB\nE+JYzO6LjJ637n+kMNfLfIBa7V1WB7WoHrU2amynGGPGQfvuRyZzIyM+LVlILJJa\nfKEWko8eFSWBy65vtclYd1Nyvpapnbx9jfVRJOsxYk642i0r7QI7IyhWxfy4Y0q3\nhBsBwsJfG9NiWVGCJ63G6F9nqXNYTTDaCK5P2v01XQQtj5YrPkM=\n=gd9Z\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c9362664e672efeee8a0c1ee8779071432b78394",
          "sha": "c9362664e672efeee8a0c1ee8779071432b78394",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c9362664e672efeee8a0c1ee8779071432b78394"
        }
      ],
      "message": "build: allow enabling the musig module in cmake",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T14:21:15Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T20:17:27Z"
      },
      "sha": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13052745774,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMKARgu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13052745774",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-05T14:50:19Z"
    },
    {
      "event": "reviewed",
      "id": 2135640276,
      "node_id": "PRR_kwDOAP4Jqs5_S0jU",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looked mostly at the API header and the example so far, left a few nits. I noticed that the generated test vector headers differs in a few lines when generated with the data from the bips repo (master branch), probably that's due to the recent bump from 1.0.0 to 1.0.1 (https://github.com/bitcoin/bips/pull/1591).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2135640276",
      "submitted_at": "2024-06-24T13:47:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1981965588,
      "node_id": "PRR_kwDOAP4Jqs52ImUU",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1981965588",
      "submitted_at": "2024-06-25T13:13:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2138282721,
      "node_id": "PRR_kwDOAP4Jqs5_c5rh",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2138282721",
      "submitted_at": "2024-06-26T16:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2145962171,
      "node_id": "PRR_kwDOAP4Jqs5_6Mi7",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2145962171",
      "submitted_at": "2024-06-27T17:04:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2148574147,
      "node_id": "PRR_kwDOAP4Jqs6AEKPD",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2148574147",
      "submitted_at": "2024-06-28T17:45:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2150045420,
      "node_id": "PRR_kwDOAP4Jqs6AJxbs",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2150045420",
      "submitted_at": "2024-06-30T12:50:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443989873",
      "pull_request_review_id": 1807791233,
      "id": 1443989873,
      "node_id": "PRRC_kwDOAP4Jqs5WEYlx",
      "diff_hunk": "@@ -240,6 +240,22 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_pubkey_cmp(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey *pk1,\n+    const secp256k1_pubkey *pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Remind me what the difference was to the function `secp256k1_ec_pubkey_cmp`. Is there no difference and we simply overlooked this? I suspect what happened is this:\r\n - When we had x-only keys as input to key agg, we had to add a comparison function for x-only keys (to extrakeys module)\r\n - Then we switched to compressed keys as input, and we changed the comparison function to also take compressed keys, not noticing that there's one already in `secp256k1.h` ",
      "created_at": "2024-01-07T11:46:49Z",
      "updated_at": "2024-01-07T11:46:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1443989873",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443989873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443990557",
      "pull_request_review_id": 1807791809,
      "id": 1443990557,
      "node_id": "PRRC_kwDOAP4Jqs5WEYwd",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should simply get rid of this branch entirely, see https://github.com/bitcoin-core/secp256k1/issues/1352. I can work on a PR next week.",
      "created_at": "2024-01-07T11:51:30Z",
      "updated_at": "2024-01-07T11:51:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1443990557",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443990557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444010274",
      "pull_request_review_id": 1807811494,
      "id": 1444010274,
      "node_id": "PRRC_kwDOAP4Jqs5WEdki",
      "diff_hunk": "@@ -240,6 +240,22 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_pubkey_cmp(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey *pk1,\n+    const secp256k1_pubkey *pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "in_reply_to_id": 1443989873,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no difference. I removed the commit.",
      "created_at": "2024-01-07T13:53:51Z",
      "updated_at": "2024-01-07T13:53:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444010274",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444010274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444827194",
      "pull_request_review_id": 1809353957,
      "id": 1444827194,
      "node_id": "PRRC_kwDOAP4Jqs5WHlA6",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See #1480 ",
      "created_at": "2024-01-08T15:26:17Z",
      "updated_at": "2024-01-08T15:26:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444827194",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444827194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444877973",
      "pull_request_review_id": 1809438784,
      "id": 1444877973,
      "node_id": "PRRC_kwDOAP4Jqs5WHxaV",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes thanks! I considered doing this but didn't want to make this PR dependent on a separate issue.",
      "created_at": "2024-01-08T15:50:28Z",
      "updated_at": "2024-01-08T15:50:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444877973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444877973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1448907322",
      "pull_request_review_id": 1815652691,
      "id": 1448907322,
      "node_id": "PRRC_kwDOAP4Jqs5WXJI6",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Got rid of this by rebasing.",
      "created_at": "2024-01-11T13:59:08Z",
      "updated_at": "2024-01-11T13:59:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1448907322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1448907322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457727273",
      "pull_request_review_id": 1830151789,
      "id": 1457727273,
      "node_id": "PRRC_kwDOAP4Jqs5W4ycp",
      "diff_hunk": "@@ -240,6 +240,21 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Sort public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *\n+ *  Args:     ctx: pointer to a context object\n+ *  In:   pubkeys: array of pointers to pubkeys to sort\n+ *      n_pubkeys: number of elements in the pubkeys array\n+ */\n+SECP256K1_API int secp256k1_pubkey_sort(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey **pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "e1ba262f16fd821ec48e8570d4d2990111ec0ef3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this function should be in the main module because it works on `secp256k1_pubkey` objects, and the comparison function is also there. (Extrakeys would make sense for x-only, I guess.) I don't think code size is an issue, the heap sort implementation should be tiny.",
      "created_at": "2024-01-18T16:50:28Z",
      "updated_at": "2024-01-18T16:55:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1457727273",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457727273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457733653",
      "pull_request_review_id": 1830151789,
      "id": 1457733653,
      "node_id": "PRRC_kwDOAP4Jqs5W40AV",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,\n+     * parity_acc is 1. Otherwise, parity_acc is 0. */\n+    int parity_acc;\n+} secp256k1_keyagg_cache_internal;\n+\n+/* musig_ge_to_bytes_ext and musig_ge_from_bytes_ext are identical to ge_save and ge_load\n+ * except that they allow saving and loading the point at infinity */\n+static void secp256k1_musig_ge_to_bytes_ext(unsigned char *data, secp256k1_ge *ge);\n+\n+static void secp256k1_musig_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data);",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 34,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "fce0857aa09a1af71bb3f8a45379fbc3c7768db1",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think these should be in `group.h`, even though they'll be used only by the musig module. Infinity can be helpful in other contexts, and conceptually it's a group function.\r\n\r\nAnyway, the comment needs to be updated `ge_save` and `ge_load` have been renamed. ",
      "created_at": "2024-01-18T16:55:17Z",
      "updated_at": "2024-01-18T16:55:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1457733653",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457733653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 30,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477961061",
      "pull_request_review_id": 1862362444,
      "id": 1477961061,
      "node_id": "PRRC_kwDOAP4Jqs5YF-Vl",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 186,
      "original_position": 186,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we recommend that users sort their pubkeys before aggregating them? The `musig_pubkey_agg` API documentation simply says the user \"can\" do it.\r\n\r\nIf we recommend the sorting step, including it in the example file would be helpful.",
      "created_at": "2024-02-05T10:23:29Z",
      "updated_at": "2024-02-05T10:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1477961061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477961061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477997628",
      "pull_request_review_id": 1862418731,
      "id": 1477997628,
      "node_id": "PRRC_kwDOAP4Jqs5YGHQ8",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 186,
      "original_position": 186,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1477961061,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think there's no catch-all recommendation. BIP327 says \"The aggregate public key produced by KeyAgg (regardless of the type) depends on the order of the individual public keys. If the application does not have a canonical order of the signers, the individual public keys can be sorted with the KeySort algorithm to ensure that the aggregate public key is independent of the order of signers.\"\r\n\r\nIn other words: If in your application, the collection of pubkeys (or signers represented by them) is conceptually an (ordered) list, then don't bother with sorting. If in your application, the collection of pubkeys is conceptually an (unordered) set, i.e., the application doesn't want to care about the order of pubkeys, then sort to make sure the set has a canonical serialization. \r\n\r\nPerhaps we can explain this somewhere in more detail, either in the API docs or in the example. ",
      "created_at": "2024-02-05T10:52:21Z",
      "updated_at": "2024-02-05T10:52:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1477997628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477997628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1479443648",
      "pull_request_review_id": 1864630385,
      "id": 1479443648,
      "node_id": "PRRC_kwDOAP4Jqs5YLoTA",
      "diff_hunk": "",
      "path": "src/modules/musig/session_impl.h",
      "position": 1,
      "original_position": 1,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there any specific reason for avoiding sha256 mid-state optimization in the `musig_compute_noncehash` and `nonce_function_musig` functions?",
      "created_at": "2024-02-06T09:13:54Z",
      "updated_at": "2024-02-06T10:21:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1479443648",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1479443648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1516062204",
      "pull_request_review_id": 1922290796,
      "id": 1516062204,
      "node_id": "PRRC_kwDOAP4Jqs5aXUX8",
      "diff_hunk": "@@ -0,0 +1,518 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *     REUSED in subsequent calls to this function.\n+ *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n+ *     session_id32 can instead be a counter (that must never repeat!). However,\n+ *     it is recommended to always choose session_id32 uniformly at random.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 325,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should probably rename this. Despite this big fat warning, `session_id` itself sounds like a public value. \r\n\r\nBrain dump:\r\n -  `session_nonce`: too easy to confuse with the sec nonce\r\n -  `session_rand`: but what if it's counter\r\n -  `session_seed`: okayish\r\n\r\nBut now that I think about this again, I believe that the confusion stems from the fact that we have these two modes: It's either random and secret, or a counter, but that's only okay if you provide a seckey. A single name that fits both scenarios is necessarily imprecise. \r\n\r\nI think a better approach is to provide two different functions, e.g., `secp256k1_musig_nonce_gen` and `secp256k1_musig_nonce_gen_with_counter` (like in the BIP where we have CounterNonceGen as a separate algorithm). Then we can have clear argument names, even very verbose ones like `session_secret_rand` and `nonrepeating_counter`. Moreover, we can enforce the presence of the seckey in the counter function.",
      "created_at": "2024-03-07T12:18:51Z",
      "updated_at": "2024-03-07T12:25:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1516062204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1516062204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518231802",
      "pull_request_review_id": 1925740508,
      "id": 1518231802,
      "node_id": "PRRC_kwDOAP4Jqs5afmD6",
      "diff_hunk": "",
      "path": "src/modules/musig/session_impl.h",
      "position": 1,
      "original_position": 1,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1479443648,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Because apparently I had been to lazy so far :D. I added this optimization.",
      "created_at": "2024-03-08T19:54:58Z",
      "updated_at": "2024-03-08T19:54:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518231802",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518231802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232232",
      "pull_request_review_id": 1925741106,
      "id": 1518232232,
      "node_id": "PRRC_kwDOAP4Jqs5afmKo",
      "diff_hunk": "@@ -240,6 +240,21 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Sort public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *\n+ *  Args:     ctx: pointer to a context object\n+ *  In:   pubkeys: array of pointers to pubkeys to sort\n+ *      n_pubkeys: number of elements in the pubkeys array\n+ */\n+SECP256K1_API int secp256k1_pubkey_sort(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey **pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "e1ba262f16fd821ec48e8570d4d2990111ec0ef3",
      "in_reply_to_id": 1457727273,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's reasonable. Done.",
      "created_at": "2024-03-08T19:55:27Z",
      "updated_at": "2024-03-08T19:55:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518232232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232357",
      "pull_request_review_id": 1925741325,
      "id": 1518232357,
      "node_id": "PRRC_kwDOAP4Jqs5afmMl",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,\n+     * parity_acc is 1. Otherwise, parity_acc is 0. */\n+    int parity_acc;\n+} secp256k1_keyagg_cache_internal;\n+\n+/* musig_ge_to_bytes_ext and musig_ge_from_bytes_ext are identical to ge_save and ge_load\n+ * except that they allow saving and loading the point at infinity */\n+static void secp256k1_musig_ge_to_bytes_ext(unsigned char *data, secp256k1_ge *ge);\n+\n+static void secp256k1_musig_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data);",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 34,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "fce0857aa09a1af71bb3f8a45379fbc3c7768db1",
      "in_reply_to_id": 1457733653,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, done.",
      "created_at": "2024-03-08T19:55:36Z",
      "updated_at": "2024-03-08T19:55:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518232357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 30,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518866600",
      "pull_request_review_id": 1926554452,
      "id": 1518866600,
      "node_id": "PRRC_kwDOAP4Jqs5aiBCo",
      "diff_hunk": "@@ -0,0 +1,518 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *     REUSED in subsequent calls to this function.\n+ *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n+ *     session_id32 can instead be a counter (that must never repeat!). However,\n+ *     it is recommended to always choose session_id32 uniformly at random.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 325,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1516062204,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed. I split the two nonce_gen functions.",
      "created_at": "2024-03-10T14:25:41Z",
      "updated_at": "2024-03-10T14:25:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518866600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518866600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524409269",
      "pull_request_review_id": 1935966419,
      "id": 1524409269,
      "node_id": "PRRC_kwDOAP4Jqs5a3KO1",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should then drop the condition \"If you do not provide a seckey,\"",
      "created_at": "2024-03-14T08:13:43Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524409269",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524409269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524421899",
      "pull_request_review_id": 1935966419,
      "id": 1524421899,
      "node_id": "PRRC_kwDOAP4Jqs5a3NUL",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 68,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seckey is mandatory for this function anyway.\r\n\r\nI think usually I would suggest moving this big explainer at the top of the module, so that it covers both functions and does not need to be repeated. But in this case of a big fat warning, it's probably better to keep it in the docstring, where it's harder to miss...",
      "created_at": "2024-03-14T08:18:14Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524421899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524421899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 392,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524427434",
      "pull_request_review_id": 1935966419,
      "id": 1524427434,
      "node_id": "PRRC_kwDOAP4Jqs5a3Oqq",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524409269,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could also add a reference to the new function, maybe below the numbered list.\r\n\r\nsomething like \"If you don't have access to good randomness, but you have access to a non-repeating counter, then see ...\"",
      "created_at": "2024-03-14T08:20:11Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524427434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524427434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524437469",
      "pull_request_review_id": 1935966419,
      "id": 1524437469,
      "node_id": "PRRC_kwDOAP4Jqs5a3RHd",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 65,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could expand a bit to mention that this includes cases where the same seckey is used on multiple devices. (Any other precautions to mention?)",
      "created_at": "2024-03-14T08:25:27Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524437469",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524437469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 381,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1555961371",
      "pull_request_review_id": 1986650201,
      "id": 1555961371,
      "node_id": "PRRC_kwDOAP4Jqs5cvhYb",
      "diff_hunk": "@@ -282,4 +283,38 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     return ret;\n }\n \n+/* This struct wraps a const context pointer to satisfy the secp256k1_hsort api\n+ * which expects a non-const cmp_data pointer. */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+} secp256k1_pubkey_sort_cmp_data;\n+\n+static int secp256k1_pubkey_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(((secp256k1_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+                                     *(secp256k1_pubkey **)pk1,\n+                                     *(secp256k1_pubkey **)pk2);\n+}\n+\n+int secp256k1_pubkey_sort(const secp256k1_context* ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys) {\n+    secp256k1_pubkey_sort_cmp_data cmp_data;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkeys != NULL);\n+\n+    cmp_data.ctx = ctx;\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "26dde295d0ad12a011fc4062ad642852f7ff68fa",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/pull/1479/commits/26dde295d0ad12a011fc4062ad642852f7ff68fa (\"extrakeys: add secp256k1_pubkey_sort\"):\r\n\r\nDoes it make sense to move this block into the `secp256k1_sort` function? I ended up copying these lines while writing a `secp256k1_silentpayments_recipient_sort` function, which made me realize anyone else would also need to copy these lines when writing a sort function for heapsort.",
      "created_at": "2024-04-08T14:41:15Z",
      "updated_at": "2024-04-08T14:43:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1555961371",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1555961371"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 305,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567811652",
      "pull_request_review_id": 2004387164,
      "id": 1567811652,
      "node_id": "PRRC_kwDOAP4Jqs5dcuhE",
      "diff_hunk": "@@ -282,4 +283,38 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     return ret;\n }\n \n+/* This struct wraps a const context pointer to satisfy the secp256k1_hsort api\n+ * which expects a non-const cmp_data pointer. */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+} secp256k1_pubkey_sort_cmp_data;\n+\n+static int secp256k1_pubkey_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(((secp256k1_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+                                     *(secp256k1_pubkey **)pk1,\n+                                     *(secp256k1_pubkey **)pk2);\n+}\n+\n+int secp256k1_pubkey_sort(const secp256k1_context* ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys) {\n+    secp256k1_pubkey_sort_cmp_data cmp_data;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkeys != NULL);\n+\n+    cmp_data.ctx = ctx;\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "26dde295d0ad12a011fc4062ad642852f7ff68fa",
      "in_reply_to_id": 1555961371,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You mean into `secp256k1_hsort`? I'd guess the wrong warning is emitted when `secp256k1_hsort` is called and therefore it would be to late when the warning was disabled in `secp256k1_hsort`.",
      "created_at": "2024-04-16T18:52:20Z",
      "updated_at": "2024-04-16T18:52:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567811652",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567811652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 305,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567814921",
      "pull_request_review_id": 2004392491,
      "id": 1567814921,
      "node_id": "PRRC_kwDOAP4Jqs5dcvUJ",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524409269,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added both suggestions.",
      "created_at": "2024-04-16T18:55:20Z",
      "updated_at": "2024-04-16T18:55:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567814921",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567814921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815429",
      "pull_request_review_id": 2004393323,
      "id": 1567815429,
      "node_id": "PRRC_kwDOAP4Jqs5dcvcF",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 68,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524421899,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "dropped mention of seckey",
      "created_at": "2024-04-16T18:55:51Z",
      "updated_at": "2024-04-16T18:55:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567815429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 392,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815998",
      "pull_request_review_id": 2004394236,
      "id": 1567815998,
      "node_id": "PRRC_kwDOAP4Jqs5dcvk-",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 65,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524437469,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-04-16T18:56:24Z",
      "updated_at": "2024-04-16T18:56:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567815998",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 381,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648385148",
      "pull_request_review_id": 1981965588,
      "id": 1648385148,
      "node_id": "PRRC_kwDOAP4Jqs5iQFx8",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 31,
      "original_position": 31,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: why does `second_pk_x` need to be normalized?",
      "created_at": "2024-06-21T04:01:55Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648385148",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648385148"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 31,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648470153",
      "pull_request_review_id": 1981965588,
      "id": 1648470153,
      "node_id": "PRRC_kwDOAP4Jqs5iQaiJ",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 148,
      "original_position": 148,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: micro nit: s/`x`/`pk_x`",
      "created_at": "2024-06-21T06:21:17Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648470153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648470153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648649839",
      "pull_request_review_id": 1981965588,
      "id": 1648649839,
      "node_id": "PRRC_kwDOAP4Jqs5iRGZv",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 219,
      "original_position": 219,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: slightly confused here and in [L277](https://github.com/bitcoin-core/secp256k1/blob/c9362664e672efeee8a0c1ee8779071432b78394/src/modules/musig/keyagg_impl.h#L277). is a `VERIFY_CHECK` instead of `return 0` sufficient for these failures? ",
      "created_at": "2024-06-21T08:59:25Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648649839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648649839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 219,
      "original_line": 219,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650591872",
      "pull_request_review_id": 1981965588,
      "id": 1650591872,
      "node_id": "PRRC_kwDOAP4Jqs5iYgiA",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));",
      "path": "src/modules/musig/session_impl.h",
      "position": 481,
      "original_position": 481,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: nit: remove double (()).",
      "created_at": "2024-06-24T08:40:52Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650591872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650591872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 481,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650935751",
      "pull_request_review_id": 2135640276,
      "id": 1650935751,
      "node_id": "PRRC_kwDOAP4Jqs5iZ0fH",
      "diff_hunk": "@@ -7,6 +7,13 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [Unreleased]\n \n+#### Added\n+ - New module `musig` implements the MuSig2 multisignature scheme according to the [BIP 327 specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki). See:\n+   - Header file `include/secp256k1_musig.h` which defines the new API.\n+   - Document `doc/musig.md` for further notes on API usage.\n+   - Usage example `examples/musig.c`.\n+ - Added `secp256k1_ec_pubkey_sort` which sorts an array of public keys (see `include/secp256k1.h`).",
      "path": "CHANGELOG.md",
      "position": 9,
      "original_position": 9,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This line can be removed, as the function was already added in the last release 0.5.0\r\n```suggestion\r\n```",
      "created_at": "2024-06-24T12:17:56Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650935751",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650935751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650937773",
      "pull_request_review_id": 2135640276,
      "id": 1650937773,
      "node_id": "PRRC_kwDOAP4Jqs5iZ0-t",
      "diff_hunk": "@@ -432,6 +444,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ECDH=1\"\n fi\n \n+if test x\"$enable_module_ellswift\" = x\"yes\"; then\n+  SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\n+fi\n+",
      "path": "configure.ac",
      "position": 33,
      "original_position": 33,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This code block already exists about 30 lines above (was it intended to be moved from top to bottom?).",
      "created_at": "2024-06-24T12:19:36Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650937773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650937773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 447,
      "original_start_line": 447,
      "start_side": "RIGHT",
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651017476",
      "pull_request_review_id": 2135640276,
      "id": 1651017476,
      "node_id": "PRRC_kwDOAP4Jqs5iaIcE",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3",
      "path": "examples/musig.c",
      "position": 37,
      "original_position": 37,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Verified that the example also succeeds with larger values of `N_SIGNERS`, like e.g. 15000. At some point if the limit is increased further (e.g. 20000), segmentation faults occur on my machine, I guess this happens due to some stack limits being exceeded.",
      "created_at": "2024-06-24T13:14:20Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651017476",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651017476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 36,
      "original_start_line": 36,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651022302",
      "pull_request_review_id": 2135640276,
      "id": 1651022302,
      "node_id": "PRRC_kwDOAP4Jqs5iaJne",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;",
      "path": "examples/musig.c",
      "position": 44,
      "original_position": 44,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            return 0;\r\n```",
      "created_at": "2024-06-24T13:17:48Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651022302",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651022302"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 44,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651029879",
      "pull_request_review_id": 2135640276,
      "id": 1651029879,
      "node_id": "PRRC_kwDOAP4Jqs5iaLd3",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the",
      "path": "examples/musig.c",
      "position": 69,
      "original_position": 69,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n    /* Note that we did not provide an output_pk argument, because the\r\n```",
      "created_at": "2024-06-24T13:23:13Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651029879",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651029879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 69,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651039249",
      "pull_request_review_id": 2135640276,
      "id": 1651039249,
      "node_id": "PRRC_kwDOAP4Jqs5iaNwR",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Tweaking................\");\n+    /* Optionally tweak the aggregate key */\n+    if (!tweak(ctx, &agg_pk, &cache)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Signing message.........\");",
      "path": "examples/musig.c",
      "position": 200,
      "original_position": 200,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: if an operation takes longer, it would be nice to see this message already before the function call following returns\r\n```suggestion\r\n    printf(\"Signing message.........\"); fflush(stdout);\r\n```\r\n(noticed this for larger values of N_SIGNERS, for the value of 3 chosen here it shouldn't matter though even on slow hardware)",
      "created_at": "2024-06-24T13:28:39Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651039249",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651039249"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651407455",
      "pull_request_review_id": 2136423614,
      "id": 1651407455,
      "node_id": "PRRC_kwDOAP4Jqs5ibnpf",
      "diff_hunk": "@@ -432,6 +444,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ECDH=1\"\n fi\n \n+if test x\"$enable_module_ellswift\" = x\"yes\"; then\n+  SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\n+fi\n+",
      "path": "configure.ac",
      "position": 33,
      "original_position": 33,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1650937773,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the duplication was just introduced as a mistake when rebasing after https://github.com/bitcoin-core/secp256k1/pull/1482 ",
      "created_at": "2024-06-24T17:47:10Z",
      "updated_at": "2024-06-24T17:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651407455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651407455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 447,
      "original_start_line": 447,
      "start_side": "RIGHT",
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652109381",
      "pull_request_review_id": 1981965588,
      "id": 1652109381,
      "node_id": "PRRC_kwDOAP4Jqs5ieTBF",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    secp256k1_fe_normalize_var(&pk.x);\n+    /* TODO Cache mu */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pk);\n+    secp256k1_scalar_mul(&sk, &sk, &mu);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_scalar_negate(&k[0], &k[0]);\n+        secp256k1_scalar_negate(&k[1], &k[1]);\n+    }\n+\n+    /* Sign */\n+    secp256k1_scalar_mul(&s, &session_i.challenge, &sk);\n+    secp256k1_scalar_mul(&k[1], &session_i.noncecoef, &k[1]);\n+    secp256k1_scalar_add(&k[0], &k[0], &k[1]);\n+    secp256k1_scalar_add(&s, &s, &k[0]);\n+    secp256k1_musig_partial_sig_save(partial_sig, &s);\n+    secp256k1_musig_partial_sign_clear(&sk, k);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_verify(const secp256k1_context* ctx, const secp256k1_musig_partial_sig *partial_sig, const secp256k1_musig_pubnonce *pubnonce, const secp256k1_pubkey *pubkey, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    secp256k1_scalar mu, e, s;\n+    secp256k1_gej pkj;\n+    secp256k1_ge nonce_pt[2];\n+    secp256k1_gej rj;\n+    secp256k1_gej tmp;\n+    secp256k1_ge pkp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(pubnonce != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+\n+    /* Compute \"effective\" nonce rj = aggnonce[0] + b*aggnonce[1] */\n+    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + aggnonce[0] + b*aggnonce[1] */\n+    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&rj, &nonce_pt[1]);\n+    secp256k1_ecmult(&rj, &rj, &session_i.noncecoef, NULL);\n+    secp256k1_gej_add_ge_var(&rj, &rj, &nonce_pt[0], NULL);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pubkey)) {\n+        return 0;\n+    }\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    /* Multiplying the challenge by the KeyAgg coefficient is equivalent\n+     * to multiplying the signer's public key by the coefficient, except\n+     * much easier to do. */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pkp);\n+    secp256k1_scalar_mul(&e, &session_i.challenge, &mu);\n+\n+    /* Negate e if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let g' = g⋅gacc mod n\" and the multiplication \"g'⋅e\"\n+     * in the specification. */\n+    if (secp256k1_fe_is_odd(&cache_i.pk.y)\n+            != cache_i.parity_acc) {\n+        secp256k1_scalar_negate(&e, &e);\n+    }\n+\n+    if (!secp256k1_musig_partial_sig_load(ctx, &s, partial_sig)) {\n+        return 0;\n+    }\n+    /* Compute -s*G + e*pkj + rj (e already includes the keyagg coefficient mu) */\n+    secp256k1_scalar_negate(&s, &s);\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+    secp256k1_ecmult(&tmp, &pkj, &e, &s);\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_gej_neg(&rj, &rj);\n+    }\n+    secp256k1_gej_add_var(&tmp, &tmp, &rj, NULL);\n+\n+    return secp256k1_gej_is_infinity(&tmp);\n+}\n+\n+int secp256k1_musig_partial_sig_agg(const secp256k1_context* ctx, unsigned char *sig64, const secp256k1_musig_session *session, const secp256k1_musig_partial_sig * const* partial_sigs, size_t n_sigs) {\n+    size_t i;\n+    secp256k1_musig_session_internal session_i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(partial_sigs != NULL);\n+    ARG_CHECK(n_sigs > 0);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+    for (i = 0; i < n_sigs; i++) {\n+        secp256k1_scalar term;\n+        if (!secp256k1_musig_partial_sig_load(ctx, &term, partial_sigs[i])) {\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &term);",
      "path": "src/modules/musig/session_impl.h",
      "position": 796,
      "original_position": 796,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: don't we need to do the `e⋅g⋅tacc` part of this equation `s = s1 + ... + su + e⋅g⋅tacc mod n`?",
      "created_at": "2024-06-25T07:06:12Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1652109381",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652109381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 796,
      "original_line": 796,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652542038",
      "pull_request_review_id": 2138282721,
      "id": 1652542038,
      "node_id": "PRRC_kwDOAP4Jqs5if8pW",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.",
      "path": "examples/musig.c",
      "position": 12,
      "original_position": 12,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  include/secp256k1_musig.h and doc/musig.md.\r\n```",
      "created_at": "2024-06-25T10:57:22Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1652542038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652542038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 12,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655153854",
      "pull_request_review_id": 2138282721,
      "id": 1655153854,
      "node_id": "PRRC_kwDOAP4Jqs5ip6S-",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}",
      "path": "src/modules/musig/session_impl.h",
      "position": 278,
      "original_position": 278,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shouldn't this function call `_musig_partial_sig_load`, in order to check the 4 bytes magic and verify that the scalar doesn't overflow? (similar to the `_musig_{pub,agg}nonce_serialize` functions which also call `_musig_{pub,agg}nonce_load` first)",
      "created_at": "2024-06-26T16:09:51Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655153854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655153854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 272,
      "original_start_line": 272,
      "start_side": "RIGHT",
      "line": 278,
      "original_line": 278,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655213103",
      "pull_request_review_id": 2138282721,
      "id": 1655213103,
      "node_id": "PRRC_kwDOAP4Jqs5iqIwv",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": 240,
      "original_position": 240,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: IIUC, `agg_pk` can be directly retrieved in the `_musig_pubkey_agg` call:\r\n```suggestion\r\n *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\r\n```\r\n(that's how it's also done in the API description for the x-only tweaking function below)",
      "created_at": "2024-06-26T16:43:59Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655213103",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655213103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 239,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": 240,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655222415",
      "pull_request_review_id": 2138282721,
      "id": 1655222415,
      "node_id": "PRRC_kwDOAP4Jqs5iqLCP",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)",
      "path": "include/secp256k1_musig.h",
      "position": 244,
      "original_position": 244,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: not sure how strict we want to be here to match the exact API, but with all parameters considered, it would look like e.g.\r\n\r\n```suggestion\r\n *  secp256k1_ec_pubkey_serialize(..., buf2, &outlen, agg_pk, ...)\r\n```",
      "created_at": "2024-06-26T16:49:37Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655222415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655222415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655226973",
      "pull_request_review_id": 2138282721,
      "id": 1655226973,
      "node_id": "PRRC_kwDOAP4Jqs5iqMJd",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": 282,
      "original_position": 282,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\r\n```",
      "created_at": "2024-06-26T16:52:27Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655226973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655226973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657472337",
      "pull_request_review_id": 2145962171,
      "id": 1657472337,
      "node_id": "PRRC_kwDOAP4Jqs5iywVR",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);",
      "path": "src/modules/musig/session_impl.h",
      "position": 300,
      "original_position": 300,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, could also check the lower bound of `prefix_size`:\r\n```suggestion\r\n    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\r\n```",
      "created_at": "2024-06-27T16:51:42Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657472337",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657472337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 300,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657475037",
      "pull_request_review_id": 2145962171,
      "id": 1657475037,
      "node_id": "PRRC_kwDOAP4Jqs5iyw_d",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": 485,
      "original_position": 485,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could use the _write_be64 helper here:\r\n```suggestion\r\n    secp256k1_write_be64(buf, nonrepeating_cnt);\r\n```",
      "created_at": "2024-06-27T16:54:00Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657475037",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657475037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 483,
      "original_start_line": 483,
      "start_side": "RIGHT",
      "line": 485,
      "original_line": 485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657483220",
      "pull_request_review_id": 2145962171,
      "id": 1657483220,
      "node_id": "PRRC_kwDOAP4Jqs5iyy_U",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */",
      "path": "src/modules/musig/session_impl.h",
      "position": 361,
      "original_position": 361,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this comment a leftover? I couldn't figure out to what `sizeof` it refers to and where a subtraction happens.",
      "created_at": "2024-06-27T17:01:10Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657483220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657483220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 361,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659076501",
      "pull_request_review_id": 2148574147,
      "id": 1659076501,
      "node_id": "PRRC_kwDOAP4Jqs5i43-V",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {",
      "path": "src/modules/musig/session_impl.h",
      "position": 613,
      "original_position": 613,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've noticed that the aggregated nonce points are converted from affine to jacobi coordinates here, and then again from jacobi to affine inside `secp256k1_musig_nonce_process_internal`. Could pass as affine coordinates to the internal function instead in order to do only one conversion there. With the following patch, the tests still pass:\r\n\r\n<details>\r\n<summary>Patch</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/musig/session_impl.h b/src/modules/musig/session_impl.h\r\nindex b0ea45d..b073ec0 100644\r\n--- a/src/modules/musig/session_impl.h\r\n+++ b/src/modules/musig/session_impl.h\r\n@@ -557,14 +557,14 @@ static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1\r\n     return 1;\r\n }\r\n \r\n-static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\r\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\r\n     unsigned char noncehash[32];\r\n     secp256k1_ge fin_nonce_pt;\r\n     secp256k1_gej fin_nonce_ptj;\r\n-    secp256k1_ge aggnonce[2];\r\n+    secp256k1_gej aggnoncej[2];\r\n \r\n-    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\r\n-    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\r\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\r\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\r\n     if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\r\n         return 0;\r\n     }\r\n@@ -588,7 +588,6 @@ static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigne\r\n int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\r\n     secp256k1_keyagg_cache_internal cache_i;\r\n     secp256k1_ge aggnonce_pt[2];\r\n-    secp256k1_gej aggnonce_ptj[2];\r\n     unsigned char fin_nonce[32];\r\n     secp256k1_musig_session_internal session_i;\r\n     unsigned char agg_pk32[32];\r\n@@ -607,10 +606,8 @@ int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_\r\n     if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\r\n         return 0;\r\n     }\r\n-    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\r\n-    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\r\n \r\n-    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\r\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pt, agg_pk32, msg32)) {\r\n         return 0;\r\n     }\r\n```\r\n</details>",
      "created_at": "2024-06-28T17:16:39Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659076501",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659076501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 610,
      "original_start_line": 610,
      "start_side": "RIGHT",
      "line": 613,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659078837",
      "pull_request_review_id": 2148574147,
      "id": 1659078837,
      "node_id": "PRRC_kwDOAP4Jqs5i44i1",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);",
      "path": "src/modules/musig/session_impl.h",
      "position": 627,
      "original_position": 627,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: could assign the result directly rather than adding (session_i.s_part is zero at this point):\r\n```suggestion\r\n        session_i.s_part = e_tmp;\r\n```",
      "created_at": "2024-06-28T17:19:16Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659078837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659078837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 627,
      "original_line": 627,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659104375",
      "pull_request_review_id": 2148574147,
      "id": 1659104375,
      "node_id": "PRRC_kwDOAP4Jqs5i4-x3",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);",
      "path": "src/modules/musig/session_impl.h",
      "position": 677,
      "original_position": 677,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: though it doesn't hurt, normalizing doesn't seem to be necessary, considering that `pk` is created via deserialization (`_musig_secnonce_load` -> `_ge_from_bytes` -> `_ge_from_storage` -> `_fe_from_storage`), where the group element's coordinates x and y are always normalized initially. Same for `pk.x` below.",
      "created_at": "2024-06-28T17:39:59Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659104375",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659104375"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 677,
      "original_line": 677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660173809",
      "pull_request_review_id": 2150045420,
      "id": 1660173809,
      "node_id": "PRRC_kwDOAP4Jqs5i9D3x",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": 359,
      "original_position": 359,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering that `rand` contains secret data, should it be cleared at the end of the function? (same for `buf` and `sha_tmp` in the loop below I guess)",
      "created_at": "2024-06-30T12:46:20Z",
      "updated_at": "2024-06-30T12:50:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1660173809",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660173809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 357,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": 359,
      "original_line": 359,
      "side": "RIGHT"
    }
  ]
}