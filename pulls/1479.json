{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479",
    "id": 1667499858,
    "node_id": "PR_kwDOAP4Jqs5jZAdS",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1479.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1479.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/168c92011f5ddae8d7fe28d166b68f126459548a",
    "number": 1479,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add module \"musig\" that implements MuSig2 multi-signatures (BIP 327)",
    "user": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "EDIT: based on #1518. Closes #1452. Most of the code is a copy from [libsecp256k1-zkp](https://github.com/BlockstreamResearch/secp256k1-zkp). The API added in this PR is identical with the exception of two modifications:\r\n\r\n1. I removed the unused `scratch_space` argument from `secp256k1_musig_pubkey_agg`. This argument was intended to allow using `ecmult_multi` algorithms for key aggregation in the future. But at this point it's unclear whether the `scratch_space` object will remain in its current form (see #1302).\r\n2. Support for adaptor signatures was removed and therefore the `adaptor` argument of `musig_nonce_process` was also removed.\r\n\r\nIn contrast to the module in libsecp256k1-zkp, the module is non-experimental. I slightly cleaned up parts of the module, adjusted the code to the new definition of the VERIFY_CHECK macro and applied some simplifications that were possible because the module is now in the upstream repo (`ge_from_bytes`, `ge_to_bytes`). You can follow the changes I made to the libsecp256k1-zkp module at https://github.com/jonasnick/secp256k1-zkp/commits/musig2-upstream/.\r\n",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2024-01-06T20:40:28Z",
    "updated_at": "2024-10-07T15:05:48Z",
    "closed_at": "2024-10-07T15:05:48Z",
    "mergeable_state": "unknown",
    "merged_at": "2024-10-07T15:05:48Z",
    "merge_commit_sha": "3660fe5e2a968e1e327ef8890de0824d66a7d028",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "jonasnick:musig2-module",
      "ref": "musig2-module",
      "sha": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 57937974,
        "node_id": "MDEwOlJlcG9zaXRvcnk1NzkzNzk3NA==",
        "name": "secp256k1",
        "full_name": "jonasnick/secp256k1",
        "owner": {
          "login": "jonasnick",
          "id": 2582071,
          "node_id": "MDQ6VXNlcjI1ODIwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasnick",
          "html_url": "https://github.com/jonasnick",
          "followers_url": "https://api.github.com/users/jonasnick/followers",
          "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasnick/orgs",
          "repos_url": "https://api.github.com/users/jonasnick/repos",
          "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasnick/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasnick/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/jonasnick/secp256k1",
        "archive_url": "https://api.github.com/repos/jonasnick/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasnick/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasnick/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasnick/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasnick/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasnick/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasnick/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasnick/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasnick/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/jonasnick/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/jonasnick/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/jonasnick/secp256k1/events",
        "forks_url": "https://api.github.com/repos/jonasnick/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/jonasnick/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasnick/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasnick/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasnick/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasnick/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasnick/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasnick/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/jonasnick/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/jonasnick/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasnick/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasnick/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasnick/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasnick/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/jonasnick/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasnick/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasnick/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasnick/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/jonasnick/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/jonasnick/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/jonasnick/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasnick/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/jonasnick/secp256k1/hooks",
        "svn_url": "https://github.com/jonasnick/secp256k1",
        "language": "C",
        "forks_count": 4,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 13505,
        "default_branch": "master",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-07T14:04:51Z",
        "created_at": "2016-05-03T03:14:21Z",
        "updated_at": "2023-03-16T11:44:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "4c57c7a5a9531874e965379119621f1ab500f2fe",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1003,
        "stargazers_count": 2063,
        "watchers_count": 2063,
        "size": 11996,
        "default_branch": "master",
        "open_issues_count": 146,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-07T15:05:46Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2024-10-07T15:31:32Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 4493,
    "deletions": 28,
    "changed_files": 29,
    "commits": 5,
    "review_comments": 294,
    "comments": 24
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 11409680923,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoEeob",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11409680923",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-06T21:56:46Z"
    },
    {
      "event": "reviewed",
      "id": 1807791233,
      "node_id": "PRR_kwDOAP4Jqs5rwLSB",
      "url": null,
      "actor": null,
      "commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1807791233",
      "submitted_at": "2024-01-07T11:46:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1807791809,
      "node_id": "PRR_kwDOAP4Jqs5rwLbB",
      "url": null,
      "actor": null,
      "commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1807791809",
      "submitted_at": "2024-01-07T11:51:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411233157,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoKZmF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411233157",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T13:33:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411264369,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoKhNx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411264369",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T13:53:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11411364230,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoK5mG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11411364230",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T14:51:09Z"
    },
    {
      "event": "subscribed",
      "id": 11412133109,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKoN1T1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11412133109",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-07T22:40:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11414208869,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoVwFl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11414208869",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T07:51:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11414322009,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKoWLtZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11414322009",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T08:06:21Z"
    },
    {
      "event": "subscribed",
      "id": 11421573982,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKox2Ne",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11421573982",
      "actor": {
        "login": "Synapsensei",
        "id": 99158059,
        "node_id": "U_kgDOBekIKw",
        "avatar_url": "https://avatars.githubusercontent.com/u/99158059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Synapsensei",
        "html_url": "https://github.com/Synapsensei",
        "followers_url": "https://api.github.com/users/Synapsensei/followers",
        "following_url": "https://api.github.com/users/Synapsensei/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Synapsensei/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Synapsensei/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Synapsensei/subscriptions",
        "organizations_url": "https://api.github.com/users/Synapsensei/orgs",
        "repos_url": "https://api.github.com/users/Synapsensei/repos",
        "events_url": "https://api.github.com/users/Synapsensei/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Synapsensei/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T19:15:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11456989422,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKq48ju",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11456989422",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T13:58:31Z"
    },
    {
      "event": "commented",
      "id": 1887221226,
      "node_id": "IC_kwDOAP4Jqs5wfLXq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1887221226",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T14:01:04Z",
      "updated_at": "2024-01-11T14:01:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on top of master to get https://github.com/bitcoin-core/secp256k1/pull/1480 which allowed dropping a commit. Old state is preserved at https://github.com/jonasnick/secp256k1/tree/musig2-module-backup.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1887221226",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "labeled",
      "id": 11458130949,
      "node_id": "LE_lADOAP4Jqs57T9BRzwAAAAKq9TQF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11458130949",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T15:25:05Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 1830151789,
      "node_id": "PRR_kwDOAP4Jqs5tFeZt",
      "url": null,
      "actor": null,
      "commit_id": "70bb68536d27d44ed0b0ae76be6790ae38d77ef6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "needs rebase :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1830151789",
      "submitted_at": "2024-01-18T16:55:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 1906155742,
      "node_id": "IC_kwDOAP4Jqs5xnaDe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1906155742",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T14:19:46Z",
      "updated_at": "2024-01-23T14:19:46Z",
      "author_association": "NONE",
      "body": "FWIW, we have JVM bindings on top of this branch in https://github.com/ACINQ/secp256k1-kmp/pull/93 and an implementation of swap-in-potentiam (musig2 key-path with alternative delayed script path) in https://github.com/ACINQ/bitcoin-kmp/pull/107 and everything is working fine, and the API is easy enough to use!",
      "user": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1906155742",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11575114955,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAKx7jzL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575114955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:21:27Z"
    },
    {
      "event": "commented",
      "id": 1906775928,
      "node_id": "IC_kwDOAP4Jqs5xpxd4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1906775928",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:30Z",
      "updated_at": "2024-01-23T19:23:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.\r\n\r\nThanks @t-bast, that's good to hear.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1906775928",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 11575138578,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAKx7pkS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575138578",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:30Z"
    },
    {
      "event": "subscribed",
      "id": 11575138592,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAKx7pkg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/11575138592",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-23T19:23:31Z"
    },
    {
      "event": "commented",
      "id": 1920536530,
      "node_id": "IC_kwDOAP4Jqs5yeQ_S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1920536530",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-01T05:21:26Z",
      "updated_at": "2024-02-13T04:19:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Attaching a visualization for the API flow.\r\n\r\n![musig2-api-flowchart](https://github.com/bitcoin-core/secp256k1/assets/56887198/9a7ce10a-4803-4ffe-aaf8-8832dc6ba108)\r\n\r\nEdit: The above visualization is incorrect. I will update it with the correct one soon.",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-1920536530",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 1862362444,
      "node_id": "PRR_kwDOAP4Jqs5vAWVM",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1862362444",
      "submitted_at": "2024-02-05T10:27:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1864630385,
      "node_id": "PRR_kwDOAP4Jqs5vJABx",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1864630385",
      "submitted_at": "2024-02-06T10:21:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1922290796,
      "node_id": "PRR_kwDOAP4Jqs5yk9Rs",
      "url": null,
      "actor": null,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1922290796",
      "submitted_at": "2024-03-07T12:18:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12065677534,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAALPK6De",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12065677534",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-10T14:57:47Z"
    },
    {
      "event": "reviewed",
      "id": 1935966419,
      "node_id": "PRR_kwDOAP4Jqs5zZIDT",
      "url": null,
      "actor": null,
      "commit_id": "2512e4b9431363cbd2998ce2ac43ab90c8134d37",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1935966419",
      "submitted_at": "2024-03-14T08:25:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1986650201,
      "node_id": "PRR_kwDOAP4Jqs52aeBZ",
      "url": null,
      "actor": null,
      "commit_id": "3b6c90a93fb55b2ea5fc629762bf4c3c569211cf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I'm also using the heapsort commits in #1471. What do you think about splitting out the sort commits into their own PR? Also fine with cherry-picking for now, but figured I'd mention it since it might simplify both of our PRs.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1986650201",
      "submitted_at": "2024-04-08T14:43:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12495477081,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAALoydlZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495477081",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:29:26Z"
    },
    {
      "event": "commented",
      "id": 2059792383,
      "node_id": "IC_kwDOAP4Jqs56xe__",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2059792383",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:39Z",
      "updated_at": "2024-04-16T19:32:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "@josibake \r\n\r\n>  What do you think about splitting out the sort commits into their own PR?\r\n\r\nThat's a good idea. In particular, if more fixups are needed for the sort commits. See #1518.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2059792383",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 12495520191,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAALoyoG_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495520191",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:40Z"
    },
    {
      "event": "subscribed",
      "id": 12495520202,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAALoyoHK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12495520202",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-16T19:32:41Z"
    },
    {
      "event": "referenced",
      "id": 12716573112,
      "node_id": "REFE_lADOAP4Jqs57T9BRzwAAAAL194G4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12716573112",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "bb528cfb08761fde75c68751de7ded747ed51e84",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/bb528cfb08761fde75c68751de7ded747ed51e84",
      "created_at": "2024-05-06T15:18:33Z"
    },
    {
      "event": "commented",
      "id": 2148502564,
      "node_id": "IC_kwDOAP4Jqs6AD4wk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2148502564",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T22:17:04Z",
      "updated_at": "2024-06-04T22:17:04Z",
      "author_association": "MEMBER",
      "body": "Rebase perhaps? It'd be nice to get this in soon.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2148502564",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13052745774,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMKARgu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13052745774",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-05T14:50:19Z"
    },
    {
      "event": "reviewed",
      "id": 2135640276,
      "node_id": "PRR_kwDOAP4Jqs5_S0jU",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looked mostly at the API header and the example so far, left a few nits. I noticed that the generated test vector headers differs in a few lines when generated with the data from the bips repo (master branch), probably that's due to the recent bump from 1.0.0 to 1.0.1 (https://github.com/bitcoin/bips/pull/1591).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2135640276",
      "submitted_at": "2024-06-24T13:47:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 1981965588,
      "node_id": "PRR_kwDOAP4Jqs52ImUU",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-1981965588",
      "submitted_at": "2024-06-25T13:13:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2138282721,
      "node_id": "PRR_kwDOAP4Jqs5_c5rh",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2138282721",
      "submitted_at": "2024-06-26T16:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2145962171,
      "node_id": "PRR_kwDOAP4Jqs5_6Mi7",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2145962171",
      "submitted_at": "2024-06-27T17:04:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2148574147,
      "node_id": "PRR_kwDOAP4Jqs6AEKPD",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2148574147",
      "submitted_at": "2024-06-28T17:45:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2150045420,
      "node_id": "PRR_kwDOAP4Jqs6AJxbs",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2150045420",
      "submitted_at": "2024-06-30T12:50:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2144558746,
      "node_id": "PRR_kwDOAP4Jqs5_016a",
      "url": null,
      "actor": null,
      "commit_id": "77489bf422e3714b5a5f6427b97ea4ef91bd34dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2144558746",
      "submitted_at": "2024-07-01T09:58:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13456598209,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMiE2TB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456598209",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T13:48:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13456943217,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMiGKhx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456943217",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:08:06Z"
    },
    {
      "event": "commented",
      "id": 2220617012,
      "node_id": "IC_kwDOAP4Jqs6EW-00",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2220617012",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:09:17Z",
      "updated_at": "2024-07-10T14:09:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks a lot @stratospher @theStack for the review! I think I addressed all comments and I rebased on master.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2220617012",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 13456964709,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAMiGPxl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456964709",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:09:19Z"
    },
    {
      "event": "subscribed",
      "id": 13456964731,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAMiGPx7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456964731",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:09:19Z"
    },
    {
      "event": "mentioned",
      "id": 13456964751,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAMiGPyP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456964751",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:09:19Z"
    },
    {
      "event": "subscribed",
      "id": 13456964762,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAMiGPya",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13456964762",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T14:09:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13467309574,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMittYG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13467309574",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T07:26:24Z"
    },
    {
      "event": "commented",
      "id": 2222227111,
      "node_id": "IC_kwDOAP4Jqs6EdH6n",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2222227111",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T07:26:35Z",
      "updated_at": "2024-07-11T07:26:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "rebased again",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2222227111",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2171216906,
      "node_id": "PRR_kwDOAP4Jqs6BaiQK",
      "url": null,
      "actor": null,
      "commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2171216906",
      "submitted_at": "2024-07-11T08:25:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 2222354082,
      "node_id": "IC_kwDOAP4Jqs6Edm6i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2222354082",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T08:36:48Z",
      "updated_at": "2024-07-11T08:36:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "Just left a comment in the silent payments PR about checking test vectors, which is relevant here too: https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673629197",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2222354082",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "commented",
      "id": 2222404226,
      "node_id": "IC_kwDOAP4Jqs6EdzKC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2222404226",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T09:02:36Z",
      "updated_at": "2024-07-11T09:02:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Just left a comment in the silent payments PR about checking test vectors, which is relevant here too: [#1519 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673629197)\r\n\r\nThis would only work if we included the json test vectors from the BIP.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2222404226",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13468827310,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMizf6u",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13468827310",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T09:25:03Z"
    },
    {
      "event": "commented",
      "id": 2223291083,
      "node_id": "IC_kwDOAP4Jqs6EhLrL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223291083",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T15:47:20Z",
      "updated_at": "2024-07-11T15:47:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "> This would only work if we included the json test vectors from the BIP.\r\n\r\nOkay yeah, I think this has a non-zero benefit because then CI can test the py script and the repo is self-contained, but it's not clear if it's worth the hassle, in particular given that the PR is already in a pretty mature state.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2223291083",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "commented",
      "id": 2223345722,
      "node_id": "IC_kwDOAP4Jqs6EhZA6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223345722",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T16:14:42Z",
      "updated_at": "2024-07-11T16:14:42Z",
      "author_association": "MEMBER",
      "body": "> Okay yeah, I think this has a non-zero benefit because then CI can test the py script and the repo is self-contained, but it's not clear if it's worth the hassle, in particular given that the PR is already in a pretty mature state.\r\n\r\nSeems like this could be opened as an issue and left for a follow-up PR? I agree its a non-zero benefit, but not worth delaying this PR for.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2223345722",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2185574313,
      "node_id": "PRR_kwDOAP4Jqs6CRTep",
      "url": null,
      "actor": null,
      "commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2185574313",
      "submitted_at": "2024-07-18T16:20:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2191726645,
      "node_id": "PRR_kwDOAP4Jqs6Coxg1",
      "url": null,
      "actor": null,
      "commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Working my way through `src/modules/musig/keyagg_impl.h`, left some suggestions but nothing blocking so feel free to ignore",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2191726645",
      "submitted_at": "2024-07-22T15:43:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2193548751,
      "node_id": "PRR_kwDOAP4Jqs6CvuXP",
      "url": null,
      "actor": null,
      "commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Don't want to repeat the same comment in multiple places so I'll try to summarise here:\r\n\r\nIt seems there are quite a few internal functions where `ctx` is in the signature only for `ARG_CHECK` and/or functions that could be `void` return an error for `ARG_CHECK`. I'll revisit the public API of the module and take a look at the example to make sure I'm not missing something, but couldn't the magic bytes be checked before calling these internal functions and other `ARG_CHECKS` be moved to the public facing functions? The reason I think this is better is it simplifies the internal functions quite a bit and it also feels strange to me to be checking for illegal argument errors this deep in the internals of the module. It seems to me we should only get an illegal argument from a public facing function. Checking for illegal arguments inside internal functions feels indicates to me we aren't validating inputs earlier on in the public facing functions.\r\n\r\nAgain, I could be missing something here, so more just throwing this out for discussion.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2193548751",
      "submitted_at": "2024-07-23T10:43:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13628017272,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMsSwp4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13628017272",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T09:59:17Z"
    },
    {
      "event": "commented",
      "id": 2247461278,
      "node_id": "IC_kwDOAP4Jqs6F9Yme",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2247461278",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T10:04:40Z",
      "updated_at": "2024-07-24T10:04:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @josibake @theStack for the review! I should have addressed all comments except for the \"don't use ARG_CHECK in internal functions one\":\r\n\r\n> It seems there are quite a few internal functions where ctx is in the signature only for ARG_CHECK and/or functions that could be void return an error for ARG_CHECK.\r\n\r\nI agree that internal functions should avoid ARG_CHECKs where possible. In the case of the magic bytes, I think it's best to check the bytes where they are used, i.e., in the `_load` functions. If we'd check the magic bytes in the calling code, the code would be more fragile. A similar `ARG_CHECK` happens in `secp256k1_pubkey_load` in secp256k1.c.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2247461278",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 13628091853,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAMsTC3N",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13628091853",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T10:04:41Z"
    },
    {
      "event": "subscribed",
      "id": 13628091870,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAMsTC3e",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13628091870",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T10:04:41Z"
    },
    {
      "event": "mentioned",
      "id": 13628091889,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAAMsTC3x",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13628091889",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T10:04:41Z"
    },
    {
      "event": "subscribed",
      "id": 13628091905,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAAMsTC4B",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13628091905",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T10:04:41Z"
    },
    {
      "event": "commented",
      "id": 2249609932,
      "node_id": "IC_kwDOAP4Jqs6GFlLM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2249609932",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T07:07:07Z",
      "updated_at": "2024-07-25T07:07:07Z",
      "author_association": "MEMBER",
      "body": "> I think it's best to check the bytes where they are used, i.e., in the _load functions\r\n\r\nThinking about this more (and taking a second look at the code), this is a really good point. Just to convince myself, I started working on a patch that moves the `_load` functions out of the internal functions wherever possible and instead passes `cache_i` as a parameter to the internal functions. The idea here was you could reason a `cache_i` has already been validated, which would simplify the logic of the internal functions and in some cases allows us to remove `ctx` from the function signatures and make some of the internal functions void. However, this ended up making `cache_i` an In/Out param and overall did feel more brittle. \r\n\r\nFeel free to resolve my review comments re: `ARG_CHECK`.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2249609932",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2198554629,
      "node_id": "PRR_kwDOAP4Jqs6DC0gF",
      "url": null,
      "actor": null,
      "commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "The example is great and really helped me understand how the full two round protocol is supposed to work. Left some nits, but nothing blocking",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2198554629",
      "submitted_at": "2024-07-25T09:40:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13652236789,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMtvJn1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13652236789",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T19:45:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13652497410,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMtwJQC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13652497410",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T20:14:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13658479223,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMuG9p3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13658479223",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T09:10:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13658583281,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMuHXDx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13658583281",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T09:19:26Z"
    },
    {
      "event": "reviewed",
      "id": 2204550917,
      "node_id": "PRR_kwDOAP4Jqs6DZscF",
      "url": null,
      "actor": null,
      "commit_id": "cf20ad88cd15bd21fcae9e3e7080d310434a21ce",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Went through another review round, LGTM, only found some nits that I left below. Haven't looked closer at CI changes and ctime-tests yet.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2204550917",
      "submitted_at": "2024-07-29T10:56:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13682093741,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAMvhC6t",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13682093741",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-29T14:59:44Z"
    },
    {
      "event": "reviewed",
      "id": 2215272669,
      "node_id": "PRR_kwDOAP4Jqs6ECmDd",
      "url": null,
      "actor": null,
      "commit_id": "398051cba6052c77f801b0aa57f1b0f161b0b12d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2215272669",
      "submitted_at": "2024-08-02T13:58:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2217743071,
      "node_id": "PRR_kwDOAP4Jqs6EMBLf",
      "url": null,
      "actor": null,
      "commit_id": "398051cba6052c77f801b0aa57f1b0f161b0b12d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Light code-review ACK 398051cba6052c77f801b0aa57f1b0f161b0b12d\r\n\r\nReviewed the implementation code thoroughly and verified that it matches the BIP327 specification, and that all best practices that I'm aware of are followed (in particular, cleaning of secret data). Spent only a relatively small time looking at test and CI code.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2217743071",
      "submitted_at": "2024-08-04T13:04:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13763001682,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAAM0Vr1S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13763001682",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-05T11:43:53Z"
    },
    {
      "event": "reviewed",
      "id": 2219784078,
      "node_id": "PRR_kwDOAP4Jqs6ETzeO",
      "url": null,
      "actor": null,
      "commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Light re-ACK 5dccc7b4578fb583df60290fc363220cbacb7a03",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2219784078",
      "submitted_at": "2024-08-05T20:11:28Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2220582552,
      "node_id": "PRR_kwDOAP4Jqs6EW2aY",
      "url": null,
      "actor": null,
      "commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin-core/secp256k1/commit/5dccc7b4578fb583df60290fc363220cbacb7a03\r\n\r\nThanks for all the hard work on this, @jonasnick; I realise a lot of my feedback was on style 😅 Verified to the best of my ability that this conforms to the BIP327 spec, and that the module is well-tested (mainly by running and checking the `gcov` results and manually inspecting the tests). Overall, I found the module to be very well organised and easy to follow. I left one last nit regarding singular vs plural arguments, but not a blocker.\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2220582552",
      "submitted_at": "2024-08-06T08:37:49Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 2306523445,
      "node_id": "IC_kwDOAP4Jqs6JesE1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2306523445",
      "actor": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T08:02:48Z",
      "updated_at": "2024-08-23T08:02:48Z",
      "author_association": "NONE",
      "body": "Hey all, thanks for the hard work on this feature! We're actively using this in our tests for lightning stuff: we haven't thoroughly reviewed the code (we don't have the C skills to give a good enough review) but we've found the API simple enough to use so concept ACK :+1: \r\n\r\nAre there any blockers left on this PR or can we expect it to be integrated in the next release?",
      "user": {
        "login": "t-bast",
        "id": 31281497,
        "node_id": "MDQ6VXNlcjMxMjgxNDk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/31281497?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/t-bast",
        "html_url": "https://github.com/t-bast",
        "followers_url": "https://api.github.com/users/t-bast/followers",
        "following_url": "https://api.github.com/users/t-bast/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/t-bast/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/t-bast/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/t-bast/subscriptions",
        "organizations_url": "https://api.github.com/users/t-bast/orgs",
        "repos_url": "https://api.github.com/users/t-bast/repos",
        "events_url": "https://api.github.com/users/t-bast/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/t-bast/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2306523445",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2260334844,
      "node_id": "PRR_kwDOAP4Jqs6Gufj8",
      "url": null,
      "actor": null,
      "commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2260334844",
      "submitted_at": "2024-08-26T15:10:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "comment_deleted",
      "id": 14019511014,
      "node_id": "CDE_lADOAP4Jqs57T9BRzwAAAANDoMLm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14019511014",
      "actor": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-26T21:55:24Z"
    },
    {
      "event": "reviewed",
      "id": 2268502508,
      "node_id": "PRR_kwDOAP4Jqs6HNpns",
      "url": null,
      "actor": null,
      "commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2268502508",
      "submitted_at": "2024-08-29T11:56:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2268737645,
      "node_id": "PRR_kwDOAP4Jqs6HOjBt",
      "url": null,
      "actor": null,
      "commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2268737645",
      "submitted_at": "2024-08-29T13:22:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2274122260,
      "node_id": "PRR_kwDOAP4Jqs6HjFoU",
      "url": null,
      "actor": null,
      "commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2274122260",
      "submitted_at": "2024-08-31T18:27:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 2323015445,
      "node_id": "IC_kwDOAP4Jqs6KdmcV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2323015445",
      "actor": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-31T18:56:33Z",
      "updated_at": "2024-08-31T18:56:33Z",
      "author_association": "NONE",
      "body": "I have a question that's maybe more about MuSig itself not this PR but it may have implications that could affect the API. But firstly I want to apologize for the question not being well-researched upfront, maybe this was already addressed somewhere, I don't have that much time right now and I feel like I should speak up before this merges and cements the API.\r\n\r\nFrom my understanding the reason we have this \"toxic data\" of making sure nonces are not reused is that the counterparties could send nonces that are computed as sum of their nonce and inverse of our nonce which would allow them to compute private key. However can't the same be achieved by simply proving that they know the discrete log? Which IIUC could be done by simply single-signing the message they're going to sign (or some HMAC of it to avoid cryptographic interactions) producing a 64-byte proof. And once the nonces are proven to be random they can be deterministically derived from the message, the set of public keys and the private key. So the tradeoff would be to make all signing messages 64-byte larger to eliminate the risk that the state leaks somehow and with it also the keys or that nonces get reused by accident because of HW failure or a bug.\r\n\r\nFor an application I intend to use MuSig for I could easily have a kilobyte proof and it would still be worth the tradeoff. But I don't see any API here providing this. Sorry again if I missed it or if there's some serious problem in my reasoning that's documented somewhere. If this can be refuted with a link, you can just paste the link.\r\n\r\nThanks for consideration and all the hard work that went into this!",
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2323015445",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2274132509,
      "node_id": "PRR_kwDOAP4Jqs6HjIId",
      "url": null,
      "actor": null,
      "commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Bigheem",
        "id": 139578413,
        "node_id": "U_kgDOCFHMLQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/139578413?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Bigheem",
        "html_url": "https://github.com/Bigheem",
        "followers_url": "https://api.github.com/users/Bigheem/followers",
        "following_url": "https://api.github.com/users/Bigheem/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Bigheem/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Bigheem/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Bigheem/subscriptions",
        "organizations_url": "https://api.github.com/users/Bigheem/orgs",
        "repos_url": "https://api.github.com/users/Bigheem/repos",
        "events_url": "https://api.github.com/users/Bigheem/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Bigheem/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2274132509",
      "submitted_at": "2024-08-31T19:40:57Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 2323077793,
      "node_id": "IC_kwDOAP4Jqs6Kd1qh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2323077793",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-01T00:06:11Z",
      "updated_at": "2024-09-01T00:08:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "> From my understanding the reason we have this \"toxic data\" of making sure nonces are not reused is that the counterparties could send nonces that are computed as sum of their nonce and inverse of our nonce which would allow them to compute private key.\r\n\r\nI think you're mixing up two different issues. What you describe doesn't lead to an attack. The attacker can choose nonces that cancel out a honest signer's nonces, but the only effect this will have is that the attacker won't be able to come up with a valid partial signature and thus the protocol will fail.\r\n\r\nThis cancellation attack you describe is a concern not with nonces, but with the individual public keys in the key aggregation. Indeed, cancelling a key of an honest signer would work if the aggregate public key was just the sum of the individual keys. (This is called a \"rouge key attack\" or literally \"a key cancellation attack\"). But MuSig2 eliminates this attack vector by using a key aggregation function that is not just the sum of the keys, but instead a sum with random coefficients.\r\n\r\nBut yes, letting everyone prove knowledge of the discrete logarithm of their public individual public key using a Schnorr signature is a different way to eliminate rogue key attacks. This is used in SpeedyMuSig: https://eprint.iacr.org/2021/1375.pdf The drawback of this method is that it doesn't suffice to send these additional Schnorr signatures around during the signing protocol. For this to be secure, the signatures need to be there already at the key aggregation stage, which is possibly performed by a different party. In MuSig2, anyone (i.e., not just the involved signers) can combine some keys A and B into an aggregate key and use it, e.g., send money to it, and it will be ensured that A and B can only spend it if they work together. In SpeedyMuSig, the party who performs the key aggregation needs to see the Schnorr signatures valid for A and B before they can securely send money to the aggregate key A+B. This complicates key management and is a potential footgun (people could send to A+B without checking the additional Schnorr sigs).\r\n\r\nedit: For the actual problem with reusing nonces, see either the paper or https://delvingbitcoin.org/t/how-many-nonce-reuse-before-exposing-your-musig2-private-key/217, but both are rather involved...",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2323077793",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "commented",
      "id": 2323227203,
      "node_id": "IC_kwDOAP4Jqs6KeaJD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2323227203",
      "actor": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-01T08:18:08Z",
      "updated_at": "2024-09-01T08:18:08Z",
      "author_association": "NONE",
      "body": "Ah, OK I think I understand better now. Thanks for explaining! What I was really thinking was if all nonces are deterministic then for the same key and same message they produce the same signature so how could an attacker possibly extract additional information from that? What I was missing is there's no way for a signer to know if the pubnonce sent by another party was generated deterministically except for having some kind of ZKP that would be likely expensive to construct and verify.\r\n\r\nStill it would be nice to not have to store the secnonce on a permanent storage so maybe a viable solution for cases when there's one \"unreliable\" signer (random user with a smartphone that could kill the app at any time) and other parties are \"reliable\" (run on server 24/7, can hold the secnonces in RAM) would be for the \"unreliable\" signer to collect all nonces first and compute his own as an HMAC(secret_key, message || aggregate_pubkey || all_nonces_except_signers) and be the last one who sends pubnonce. The other signers hold their secnonces in RAM in the meantime. Does that make sense?",
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2323227203",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "commented",
      "id": 2325101102,
      "node_id": "IC_kwDOAP4Jqs6Kljou",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2325101102",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T16:54:28Z",
      "updated_at": "2024-09-02T16:54:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "@Kixunil\r\n\r\n> if all nonces are deterministic then for the same key and same message they produce the same signature so how could an attacker possibly extract additional information from that? What I was missing is there's no way for a signer to know if the pubnonce sent by another party was generated deterministically except for having some kind of ZKP that would be likely expensive to construct and verify.\r\n\r\nProving that the nonces were generated deterministically from the session parameters is the idea behind deterministic signing in [MuSig-DN](https://eprint.iacr.org/2020/1057) and [Exponent-VRFs and Their Applications](https://eprint.iacr.org/2024/397).\r\n\r\n> Does that make sense?\r\n\r\nIt sounds like you're describing a variant of the [\"Deterministic and Stateless Signing for a Single Signer\"-mode](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#modifications-to-nonce-generation) of BIP MuSig. In this mode, one signer is able to derive the nonces deterministically from the session parameters and the pubnonces of all other signers.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2325101102",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 14105865540,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAANIxm1E",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14105865540",
      "actor": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T16:54:29Z"
    },
    {
      "event": "subscribed",
      "id": 14105865548,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAANIxm1M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14105865548",
      "actor": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T16:54:30Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg1ZTIyNGRkOTdmNTIxZDcwNGU5YTJlNDFlNjg2ZTQzZDkwZGI2MzE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/85e224dd97f521d704e9a2e41e686e43d90db631",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/85e224dd97f521d704e9a2e41e686e43d90db631",
      "tree": {
        "sha": "e460da31b41311671c59790d2b49ed5bee434f20",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e460da31b41311671c59790d2b49ed5bee434f20"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e460da31b41311671c59790d2b49ed5bee434f20\nparent 1988855079fa8161521b86515e77965120fdc734\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704556410 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1725303947 +0000\n\ngroup: add ge_to_bytes and ge_from_bytes\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmbWDIsACgkQSGHb8mIS\nNgXFyg//ZLRmvkiXD9B65or6jaCojrHs6kcPRNgOjt1yvp31pezfLp2LoOGYsWKI\nT1rSpQBRfLwYneK1X/nFTMdeOActY4fsS7oRw/lz1PMfcLbZ6GcfW7xSuuec0AxD\nY+/fIfXFiIv00iYoGVBeu4HsK2yFQNQNCdomjAaDhCZi+JKbEn4oP/5k0eEPP1oo\neEAXz/NlRDTkL+9fsElyO99XxVTY9cYdcjg6+bqF84Qk8m1Trkhcih1f0VKAnq2H\nfx5IvvGgAg9DyvZr54yyfuWtpRYz3rBqtxmSe5/PtBm27rRUvruezXTGsB6q5i/G\njDa0DGmuA5hQ7rNmLszduDXjPis6fAp30+sDrPZYlEHbBVqMEuexvO3NQ9i2mF5R\n4igWMXQsL1rZIfUu8KmiJeQAFhiQQ6wYTAKfsXVqq5/YtkXbx1s6jlExIFDQEsxG\nJVK+664NXyeTlr9Wh/qSujMTqYhFq4+er2zQC2WZuKEQYYifrqN+s6nC+XFoAn0j\nFUmiFHL4l3IQSBLfNMS6KAsuSu2HlWQgXzma2V3FC08ju9Gi/BfTKY0D8yza17mP\nQ88s7qiwn4Am5UijbHaKOGMfXqAt+vyICItldgp+XBjVVpGT8jMbJRB28JrjBlIc\nQvx0tjKvW4IUiJVAajP4TLYIZTMm+28n4QCxhWvJC9hioY9Tru0=\n=wQHm\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1988855079fa8161521b86515e77965120fdc734",
          "sha": "1988855079fa8161521b86515e77965120fdc734",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1988855079fa8161521b86515e77965120fdc734"
        }
      ],
      "message": "group: add ge_to_bytes and ge_from_bytes",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-09-02T19:05:47Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T15:53:30Z"
      },
      "sha": "85e224dd97f521d704e9a2e41e686e43d90db631"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14106657101,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANI0oFN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14106657101",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T19:08:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14106939722,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANI1tFK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14106939722",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:06:23Z"
    },
    {
      "event": "commented",
      "id": 2325965458,
      "node_id": "IC_kwDOAP4Jqs6Ko2qS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2325965458",
      "actor": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T08:55:38Z",
      "updated_at": "2024-09-03T08:55:38Z",
      "author_association": "NONE",
      "body": "@jonasnick thanks for references!\r\n\r\n> It sounds like you're describing a variant of the [\"Deterministic and Stateless Signing for a Single Signer\"-mode](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#modifications-to-nonce-generation) of BIP MuSig.\r\n\r\nYes, that's what I want! From what I can see it's not currently supported by the API. Is this planned or can it be implemented some other way?",
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2325965458",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 14111697611,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAANJH2rL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14111697611",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T08:55:40Z"
    },
    {
      "event": "subscribed",
      "id": 14111697624,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAANJH2rY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14111697624",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T08:55:40Z"
    },
    {
      "event": "reviewed",
      "id": 2276830666,
      "node_id": "PRR_kwDOAP4Jqs6Hta3K",
      "url": null,
      "actor": null,
      "commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2276830666",
      "submitted_at": "2024-09-03T08:59:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "unsubscribed",
      "id": 14115887934,
      "node_id": "UE_lADOAP4Jqs57T9BRzwAAAANJX1s-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14115887934",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T14:02:33Z"
    },
    {
      "event": "reviewed",
      "id": 2286584017,
      "node_id": "PRR_kwDOAP4Jqs6ISoDR",
      "url": null,
      "actor": null,
      "commit_id": "5bd08918a81d8df7e522cd643fa4bd8930b165a7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Mostly looked through the interface and documentation.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2286584017",
      "submitted_at": "2024-09-06T18:13:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14234010779,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANQacSb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14234010779",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T14:26:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14236339950,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANQjU7u",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14236339950",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T17:08:25Z"
    },
    {
      "event": "reviewed",
      "id": 2302629278,
      "node_id": "PRR_kwDOAP4Jqs6JP1We",
      "url": null,
      "actor": null,
      "commit_id": "b6efaa53cc1838cff2995763575ac1bd1d3e87a9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2302629278",
      "submitted_at": "2024-09-13T09:32:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14246268655,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANRJM7v",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14246268655",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-13T09:47:40Z"
    },
    {
      "event": "reviewed",
      "id": 2315364170,
      "node_id": "PRR_kwDOAP4Jqs6KAadK",
      "url": null,
      "actor": null,
      "commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code-review ACK fdc09608036822afc1cebbe0c5b56cebf8ba508d\r\n\r\nReviewed once again that the code matches the specification in BIP327 and also took a closer look on the tests. Regarding the interface discussion https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747513031, I wonder if it's acceptable for now to not support (and not even mention) the use-case where users can't store the `secnonce` in volatile memory by now, and leave that for a follow-up? If a suggested way to work around that is described in the API docs (\"if you really need to do this...\"), that could be seen by users as invitation to break the rules. On the other hand, if nothing is mentioned, users might break the rules anyway and do it in an even worse way, so not sure what is better. Anyways, happy to re-review on changes in that area (e.g. suggestions in https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1761370580).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2315364170",
      "submitted_at": "2024-09-19T13:19:01Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2325041173,
      "node_id": "PRR_kwDOAP4Jqs6KlVAV",
      "url": null,
      "actor": null,
      "commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK fdc09608036822afc1cebbe0c5b56cebf8ba508d\r\n\r\nI left a bunch of nits, mostly noticed when I looked at @sipa's comments in the include file, but none of these are blockers. ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2325041173",
      "submitted_at": "2024-09-24T14:03:20Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2325429120,
      "node_id": "PRR_kwDOAP4Jqs6KmzuA",
      "url": null,
      "actor": null,
      "commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2325429120",
      "submitted_at": "2024-09-24T17:13:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14404871440,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANamOUQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14404871440",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-25T19:23:41Z"
    },
    {
      "event": "reviewed",
      "id": 2330825345,
      "node_id": "PRR_kwDOAP4Jqs6K7ZKB",
      "url": null,
      "actor": null,
      "commit_id": "55d3dc0a70367e5980759db49c4c06101db601b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2330825345",
      "submitted_at": "2024-09-26T10:47:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2330953044,
      "node_id": "PRR_kwDOAP4Jqs6K74VU",
      "url": null,
      "actor": null,
      "commit_id": "55d3dc0a70367e5980759db49c4c06101db601b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2330953044",
      "submitted_at": "2024-09-26T11:43:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14418402902,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANbZ15W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14418402902",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-26T15:09:00Z"
    },
    {
      "event": "reviewed",
      "id": 2335893606,
      "node_id": "PRR_kwDOAP4Jqs6LOuhm",
      "url": null,
      "actor": null,
      "commit_id": "5e55f093118c2517f068841f5414f767fb35c7fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "\r\nMinor API question: are there any musig API functions where the `SECP256K1_WARN_UNUSED_RESULT` attribute should be added? (Probably for the `_{pubnonce,aggnonce,partial_sig}_parse` functions, given that external data is passed in, and the nonce generation functions?)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2335893606",
      "submitted_at": "2024-09-29T17:14:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2337697756,
      "node_id": "PRR_kwDOAP4Jqs6LVm_c",
      "url": null,
      "actor": null,
      "commit_id": "5e55f093118c2517f068841f5414f767fb35c7fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code review ACK 5e55f093118c2517f068841f5414f767fb35c7fe\r\n\r\nI have not done a detailed comparison with the BIP spec.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2337697756",
      "submitted_at": "2024-09-30T18:41:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "reviewed",
      "id": 2339968050,
      "node_id": "PRR_kwDOAP4Jqs6LeRQy",
      "url": null,
      "actor": null,
      "commit_id": "5e55f093118c2517f068841f5414f767fb35c7fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 5e55f093118c2517f068841f5414f767fb35c7fe\r\n\r\n(as per `$ git diff fdc09608036822afc1cebbe0c5b56cebf8ba508d 5e55f093118c2517f068841f5414f767fb35c7fe`)\r\n\r\nAs far as I can tell, none of the unadressed questions/comments are critical.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2339968050",
      "submitted_at": "2024-10-01T11:47:53Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14536470823,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANicPEn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14536470823",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T08:40:40Z"
    },
    {
      "event": "commented",
      "id": 2396288010,
      "node_id": "IC_kwDOAP4Jqs6O1HQK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2396288010",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T08:41:20Z",
      "updated_at": "2024-10-07T08:41:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "@theStack\r\n> are there any musig API functions where the SECP256K1_WARN_UNUSED_RESULT attribute should be added?\r\n\r\nThat's a good point. I couldn't discover a consistent pattern we're currently following (e.g, `secp256k1_ec_pubkey_parse` has the warning, `secp256k1_tagged_sha256` has the warning even though it always returns 1, and `signature_parse_der`, `signature_parse_compact` don't). I think this should be made more consistent treewide with a note to CONTRIBUTING.md.\r\n\r\nThere are different rules we could follow:\r\n1. Just add the warning basically everywhere. Maybe that could be annoying sometimes if the user has data from a trusted source.\r\n2. Add it to functions returning a boolean result that would be pointless to call without checking for the result (e.g., verify).\r\n3. Add to all functions that can fail without calling a callback (e.g. they can fail because they are receiving data from untrusted sources -- at least in normal scenarios).\r\n4. Add it to all functions you need to call before verify to make sure that verify doesn't succeed due to invalid values. However, this would be defense-in-depth because it shouldn't happen anyway.\r\n5. Add it to all functions that operate on a seckey and produce a public output (e.g. sign) and all the functions the user needs to call before. This prevents that an invalid output (e.g., signature) accidentally leaks information about the seckey. However, users should already be protected from this because we zeroize the outputs if these functions fail.\r\n6. Add it to functions which sound particularly scary (nonce generation).\r\n\r\nI added it to a few more functions (following basically rules 2, 3, 4, 6), because removing the warning is backwards compatible.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2396288010",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 14536481457,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAANicRqx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14536481457",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T08:41:22Z"
    },
    {
      "event": "subscribed",
      "id": 14536481475,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAANicRrD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14536481475",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T08:41:22Z"
    },
    {
      "event": "reviewed",
      "id": 2351713476,
      "node_id": "PRR_kwDOAP4Jqs6MLEzE",
      "url": null,
      "actor": null,
      "commit_id": "352cd3bd04ed4089cf2250b66eb73a16cb53cab3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "reACK 352cd3bd04ed4089cf2250b66eb73a16cb53cab3 \r\nnit:  `musig_example` needs to be added to `.gitignore`",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2351713476",
      "submitted_at": "2024-10-07T11:59:38Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM4ZmJkYjFiOTcyMGJiNzgyNzAzMTllMzRkNjQyMjU4N2RhZjMxYjM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c8fbdb1b9720bb78270319e34d6422587daf31b3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c8fbdb1b9720bb78270319e34d6422587daf31b3",
      "tree": {
        "sha": "2e051f7de3bb0bd32baa5512366469882f542cc9",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/2e051f7de3bb0bd32baa5512366469882f542cc9"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2e051f7de3bb0bd32baa5512366469882f542cc9\nparent 85e224dd97f521d704e9a2e41e686e43d90db631\nauthor Jonas Nick <jonasd.nick@gmail.com> 1717595301 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1728309820 +0000\n\ngroup: add ge_to_bytes_ext and ge_from_bytes_ext\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmcD6j4ACgkQSGHb8mIS\nNgV1vA//SHQ9BRhCkBTxSzQ5UtxgcW4jbLhG1mPY2Ol/zBgo8IOodPah8lDVEEqr\n6dM+S23eX8nWHuATxZJ9AOEMGdsS045cV8u2iVWbJ5kmkgPDFrgIExeHmvpTH+ir\nV+JVC7BdMU0Z8NjiJT+9zmheYap5dVsy8AO1PbKQT2E8o7tx3dRpupsv/C7MjQLp\nTH84f3bxGLJMy268PO4cmFgi1zHnKuuEndcJx0ar4IlqnqR1YZcSjcI2eoohWUDG\ny/sOCWogRSID3J3L+LivFG3ENCLpWR83D6PkNHCrxo2y7IyasAgsEr6OhGebVwWm\nZubyuRr/8SkrbkdvQ2dcLr70m2874DmMv9lywvjXFFtWKvvtn5/Gaewd9NrdGam0\n5c6+ziQcRF1mo+u1I7BDRQk4g/1pXuCWQF8M3fn+6QXpNmaYSqi1fkVIC9CP1vA+\nM0LW02mlUOEfIosTley0f6FqDeuj3rs0WuR0ffzeNiwZ3pQ2CVvVkG/qBTW2eOQG\nSK9tGqPdpoUm7yzNGUdfcyNHhnp98V97auE4U0ASapQLUTNTCFNea+a5ViSL0pdW\nJs9bDg5vkzI4TAzeIrLiN4h8/t2GeS3RFjKOQ/z3Rig9sJQN2rSQD+6T/S9PQ56U\ngNwyQyWVL4qZg8S+1LIuBpk14fD5s+/rSVOsaWqOKdmcQ7/JHTo=\n=oW/Y\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/85e224dd97f521d704e9a2e41e686e43d90db631",
          "sha": "85e224dd97f521d704e9a2e41e686e43d90db631",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/85e224dd97f521d704e9a2e41e686e43d90db631"
        }
      ],
      "message": "group: add ge_to_bytes_ext and ge_from_bytes_ext",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-10-07T14:03:40Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-06-05T13:48:21Z"
      },
      "sha": "c8fbdb1b9720bb78270319e34d6422587daf31b3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDBiZTc5NjYwZjM4OGRmNjEyZjJkZGJmM2Y4MjEyMmU5YTM1ZWMwMmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0be79660f388df612f2ddbf3f82122e9a35ec02f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0be79660f388df612f2ddbf3f82122e9a35ec02f",
      "tree": {
        "sha": "92720956312817445e8b79b60c2819095ef52199",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/92720956312817445e8b79b60c2819095ef52199"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 92720956312817445e8b79b60c2819095ef52199\nparent c8fbdb1b9720bb78270319e34d6422587daf31b3\nauthor Jonas Nick <jonasd.nick@gmail.com> 1727280194 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1728309822 +0000\n\nutil: add constant-time is_zero_array function\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmcD6j4ACgkQSGHb8mIS\nNgVWgA/3d+b5lyekUr5GD9eqUYEQZGGgdNR2j8QdtZyJazuCpjmnJq55thDX7Af7\ntwnALDFTq97o6rkSDMmtdjHWuEZ4AwLL2T1KaC9kq/2OPsOGfP2ZOhNODCUSmWCa\ngGeSt1KAruhSBSIzHGhVRjMe5QBZnIZL7XbgGfkk8BLXL06ZszFL1GHXzMVgUsPL\nX+Wex7wfTRB/sY5Fk8eJlZP+EMG2FwApXMgR6sHcv/xm6etTp5hMeLMWaL9PPXRf\nr8UrQaCWNfNXriI3bAW0Wrefd7HqASaYwgcrDFvWuWnbmnFtvJByeFQ/Kr+EcQh9\n3NDF7FEiY0kWaln/bT6R1HPBeivhN1r+MUuTS/2gvdyxzagkdU3RI+Zk8VhO/aWK\nKQhzVOYKO0LGKns0CQfkUSgQ6XfskcWiPBr6hvYvLOayaOVgZAkFP4UvGy6v8zdS\np14IQbjpZ+JjGl/+4sFP3yIZjvJYfdQNEwFEMrQqlXARdNwMaf4tUpwlUIhSRCXl\nOgaq/S73YkcHZUH4bXtqfIl+pPB6AtYB1vjhFNOC7clWApFXMs0aW67RWTpzadND\nI/6hGdaJyTdFkQ5yl2vEUjBBEYNtET8uGchC8iGgH9SW7RSSQ2HzgFfObSFXCg0m\nmhzpB1rXZSHD2T4xo4HYMNoEQEA/Z2o1CtOElW5qF+j/jx1RAQ==\n=EZYJ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c8fbdb1b9720bb78270319e34d6422587daf31b3",
          "sha": "c8fbdb1b9720bb78270319e34d6422587daf31b3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c8fbdb1b9720bb78270319e34d6422587daf31b3"
        }
      ],
      "message": "util: add constant-time is_zero_array function",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-10-07T14:03:42Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-09-25T16:03:14Z"
      },
      "sha": "0be79660f388df612f2ddbf3f82122e9a35ec02f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY0MTE4NDFhNDZiMTVhYWM2ZTdjNDAzZmM3NDBlOWMwNTZjZmUwYTI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f411841a46b15aac6e7c403fc740e9c056cfe0a2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f411841a46b15aac6e7c403fc740e9c056cfe0a2",
      "tree": {
        "sha": "60dfcef3d2c35b767795bf4669bc6c5be07da213",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/60dfcef3d2c35b767795bf4669bc6c5be07da213"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 60dfcef3d2c35b767795bf4669bc6c5be07da213\nparent 0be79660f388df612f2ddbf3f82122e9a35ec02f\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704569478 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1728309822 +0000\n\nAdd module \"musig\" that implements MuSig2 multi-signatures (BIP 327)\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmcD6j4ACgkQSGHb8mIS\nNgXU4Q//QKgv1lHKrcUVzIeDicyTNNvgYfSNX4vIiBmArZgEgXvqHgGueGwMWaZH\nqZbwnCtWyN9dIay05+WzubEz8ne/CtZnFyi7xTxkYu+Mod7qtwpos7WsCxTzdXmJ\nkuOih5kiDtanNODsvVwAhcPPOZXFoFhjDttkkiXEShp1LcuKJTya6SfydREX3JRG\n1OWRCoToW8jXtb+s8SniyXFo9Oj49XY3HfBr+LWi5lwj5p+OynXRGK7Uxd26RQgW\neYCP9wu5Q/K44+Ljb9tbIy1KwYPIzVjCwXUv3w0FoQRW3n4DOrR3vkZKCx++05ba\nhsy3s7TRCaNKJua3aACUwS0BZJafwP5RKOGMjeapYRWU4jYSwoIyEQwvfD+rVhaH\nDJ93DwRMKndVG9TzATPwWw//kgPbcaoMm5L0Xg2jnQMWvl68KzXJadY+64SiQjV2\n+Lw/CgeMqWwPyCzUZYYlAiIu2xh+bhLbmu8FkzrRFP5XSOuS/SwYOx6f8by62Zwh\nt4dS43oA+fEjuVpMQ1rabAcPmELv8oxEF3H1OTby12r6ebJaQD9IT89XrvknUjyc\nie4gZtaBXEf2k4f9KnE7LMc2V7Hs7VFRUuBKJgujCc3a8OtJCUqgX7Ky8ur8oLDa\nNdaOLAkjZxNe4SB1VQVX2by2RiBdaXBSx1Vc62gG59VOPM9Fzs4=\n=q1hA\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0be79660f388df612f2ddbf3f82122e9a35ec02f",
          "sha": "0be79660f388df612f2ddbf3f82122e9a35ec02f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0be79660f388df612f2ddbf3f82122e9a35ec02f"
        }
      ],
      "message": "Add module \"musig\" that implements MuSig2 multi-signatures (BIP 327)",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-10-07T14:03:42Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T19:31:18Z"
      },
      "sha": "f411841a46b15aac6e7c403fc740e9c056cfe0a2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDE2OGM5MjAxMWY1ZGRhZThkN2ZlMjhkMTY2YjY4ZjEyNjQ1OTU0OGE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/168c92011f5ddae8d7fe28d166b68f126459548a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/168c92011f5ddae8d7fe28d166b68f126459548a",
      "tree": {
        "sha": "40de989031e8bc2352449e58d610d214a4c31cac",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/40de989031e8bc2352449e58d610d214a4c31cac"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 40de989031e8bc2352449e58d610d214a4c31cac\nparent f411841a46b15aac6e7c403fc740e9c056cfe0a2\nauthor Jonas Nick <jonasd.nick@gmail.com> 1704572247 +0000\ncommitter Jonas Nick <jonasd.nick@gmail.com> 1728309822 +0000\n\nbuild: allow enabling the musig module in cmake\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEES7uEWm9aZaad+uwjSGHb8mISNgUFAmcD6j4ACgkQSGHb8mIS\nNgUKEQ/+J+KX/RQkAJnycwyrqMfy8ACnhinAWP4bOKIoHmazgcO3giIo/7CgaGhB\nfgf/W6QyQgaxd3KupGOlU1K3uXBJG90x+94V+6uRbxys3nqz9m6y+YQ6TlyQzX+I\nB/apmlWGzYfIH4xvYF0szm8E5FPkYyNv4URb/kvJ3XVhih0QIjL3gk9CwyoGY+op\nogZXFAW5pScTj44TfuPrq4UC1QbitXp35kvOR3uD0x0vvCfjWogWolO17+e+DqGm\nQIq6Av02ylay1qhsH70VPxc13AHxDrs8EA9PCnfp3m0f6LqY6BauGlfg1BwD9/IL\nAXZGtUeOY93R3u4oC6QNFrJ1j4lWyT4kEg8hHgn6yZ4lW+y26QMAkXi1XsAz2LvE\nj+FsgG6kz4TitLR5QFCcqyXGuL3hRPAav9sAm9vrTwSVw0M4unJN3HGKUevlFdob\nVubw85KG7ECm5cj4sBKiPtwdXLUAYtBMPiIJj4B3Xu11tedY7LhQw02VqT7VDhGT\ngKwFv7uiGJK1FdJDgcN/ssRbvDiQ9i98y/nIB/Ny/58aQDecJfpx4yWVtz21SYCB\nmFY5jLXh6xgh7FWE3xFC3nfwmshxUyRCNFUO65LVpZjy5dHSU0ONSIaKqQRmM5hU\nFM3ryfMYlMLhi4qYJEZ29Nx4MXbh/X/2EBhKWe5CjbfxYGGZOVo=\n=3+E3\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f411841a46b15aac6e7c403fc740e9c056cfe0a2",
          "sha": "f411841a46b15aac6e7c403fc740e9c056cfe0a2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f411841a46b15aac6e7c403fc740e9c056cfe0a2"
        }
      ],
      "message": "build: allow enabling the musig module in cmake",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-10-07T14:03:42Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2024-01-06T20:17:27Z"
      },
      "sha": "168c92011f5ddae8d7fe28d166b68f126459548a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14541345850,
      "node_id": "HRFPE_lADOAP4Jqs57T9BRzwAAAANiu1Q6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14541345850",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:04:56Z"
    },
    {
      "event": "commented",
      "id": 2397034686,
      "node_id": "IC_kwDOAP4Jqs6O39i-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2397034686",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:06:08Z",
      "updated_at": "2024-10-07T14:06:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "> nit: musig_example needs to be added to .gitignore\r\n\r\nfixed",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2397034686",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "commented",
      "id": 2397124230,
      "node_id": "IC_kwDOAP4Jqs6O4TaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2397124230",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:40:10Z",
      "updated_at": "2024-10-07T14:40:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "reACK 168c92011f5ddae8d7fe28d166b68f126459548a",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2397124230",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "reviewed",
      "id": 2352197350,
      "node_id": "PRR_kwDOAP4Jqs6MM67m",
      "url": null,
      "actor": null,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "reACK 168c92011f5ddae8d7fe28d166b68f126459548a",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2352197350",
      "submitted_at": "2024-10-07T14:53:19Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "commented",
      "id": 2397170218,
      "node_id": "IC_kwDOAP4Jqs6O4eoq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2397170218",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:57:48Z",
      "updated_at": "2024-10-07T14:57:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "We have [an open issue](https://github.com/bitcoin-core/secp256k1/issues/961#issuecomment-2397166587) for `SECP256K1_WARN_UNUSED_RESULT`, I copied @jonasnick's comment there.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#issuecomment-2397170218",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1479"
    },
    {
      "event": "mentioned",
      "id": 14542282635,
      "node_id": "MEE_lADOAP4Jqs57T9BRzwAAAANiyZ-L",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14542282635",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:57:50Z"
    },
    {
      "event": "subscribed",
      "id": 14542282691,
      "node_id": "SE_lADOAP4Jqs57T9BRzwAAAANiyZ_D",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14542282691",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T14:57:50Z"
    },
    {
      "event": "reviewed",
      "id": 2352221543,
      "node_id": "PRR_kwDOAP4Jqs6MNA1n",
      "url": null,
      "actor": null,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 168c92011f5ddae8d7fe28d166b68f126459548a",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#pullrequestreview-2352221543",
      "submitted_at": "2024-10-07T15:01:46Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
    },
    {
      "event": "merged",
      "id": 14542433346,
      "node_id": "ME_lADOAP4Jqs57T9BRzwAAAANiy-xC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14542433346",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3660fe5e2a968e1e327ef8890de0824d66a7d028",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/3660fe5e2a968e1e327ef8890de0824d66a7d028",
      "created_at": "2024-10-07T15:05:48Z"
    },
    {
      "event": "closed",
      "id": 14542433393,
      "node_id": "CE_lADOAP4Jqs57T9BRzwAAAANiy-xx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14542433393",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T15:05:48Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443989873",
      "pull_request_review_id": 1807791233,
      "id": 1443989873,
      "node_id": "PRRC_kwDOAP4Jqs5WEYlx",
      "diff_hunk": "@@ -240,6 +240,22 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_pubkey_cmp(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey *pk1,\n+    const secp256k1_pubkey *pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Remind me what the difference was to the function `secp256k1_ec_pubkey_cmp`. Is there no difference and we simply overlooked this? I suspect what happened is this:\r\n - When we had x-only keys as input to key agg, we had to add a comparison function for x-only keys (to extrakeys module)\r\n - Then we switched to compressed keys as input, and we changed the comparison function to also take compressed keys, not noticing that there's one already in `secp256k1.h` ",
      "created_at": "2024-01-07T11:46:49Z",
      "updated_at": "2024-01-07T11:46:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1443989873",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443989873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443990557",
      "pull_request_review_id": 1807791809,
      "id": 1443990557,
      "node_id": "PRRC_kwDOAP4Jqs5WEYwd",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should simply get rid of this branch entirely, see https://github.com/bitcoin-core/secp256k1/issues/1352. I can work on a PR next week.",
      "created_at": "2024-01-07T11:51:30Z",
      "updated_at": "2024-01-07T11:51:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1443990557",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1443990557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444010274",
      "pull_request_review_id": 1807811494,
      "id": 1444010274,
      "node_id": "PRRC_kwDOAP4Jqs5WEdki",
      "diff_hunk": "@@ -240,6 +240,22 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_pubkey_cmp(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey *pk1,\n+    const secp256k1_pubkey *pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "bf1ebb890f69a2e60b51a397959146739bc284ed",
      "in_reply_to_id": 1443989873,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no difference. I removed the commit.",
      "created_at": "2024-01-07T13:53:51Z",
      "updated_at": "2024-01-07T13:53:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444010274",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444010274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444827194",
      "pull_request_review_id": 1809353957,
      "id": 1444827194,
      "node_id": "PRRC_kwDOAP4Jqs5WHlA6",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See #1480 ",
      "created_at": "2024-01-08T15:26:17Z",
      "updated_at": "2024-01-08T15:26:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444827194",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444827194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444877973",
      "pull_request_review_id": 1809438784,
      "id": 1444877973,
      "node_id": "PRRC_kwDOAP4Jqs5WHxaV",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes thanks! I considered doing this but didn't want to make this PR dependent on a separate issue.",
      "created_at": "2024-01-08T15:50:28Z",
      "updated_at": "2024-01-08T15:50:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1444877973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1444877973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1448907322",
      "pull_request_review_id": 1815652691,
      "id": 1448907322,
      "node_id": "PRRC_kwDOAP4Jqs5WXJI6",
      "diff_hunk": "@@ -247,8 +247,15 @@ static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge,\n     } else {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 1,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "04aa4e76996ad24282df58e1486508f9a51692b5",
      "in_reply_to_id": 1443990557,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Got rid of this by rebasing.",
      "created_at": "2024-01-11T13:59:08Z",
      "updated_at": "2024-01-11T13:59:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1448907322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1448907322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457727273",
      "pull_request_review_id": 1830151789,
      "id": 1457727273,
      "node_id": "PRRC_kwDOAP4Jqs5W4ycp",
      "diff_hunk": "@@ -240,6 +240,21 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Sort public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *\n+ *  Args:     ctx: pointer to a context object\n+ *  In:   pubkeys: array of pointers to pubkeys to sort\n+ *      n_pubkeys: number of elements in the pubkeys array\n+ */\n+SECP256K1_API int secp256k1_pubkey_sort(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey **pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "e1ba262f16fd821ec48e8570d4d2990111ec0ef3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this function should be in the main module because it works on `secp256k1_pubkey` objects, and the comparison function is also there. (Extrakeys would make sense for x-only, I guess.) I don't think code size is an issue, the heap sort implementation should be tiny.",
      "created_at": "2024-01-18T16:50:28Z",
      "updated_at": "2024-01-18T16:55:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1457727273",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457727273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457733653",
      "pull_request_review_id": 1830151789,
      "id": 1457733653,
      "node_id": "PRRC_kwDOAP4Jqs5W40AV",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,\n+     * parity_acc is 1. Otherwise, parity_acc is 0. */\n+    int parity_acc;\n+} secp256k1_keyagg_cache_internal;\n+\n+/* musig_ge_to_bytes_ext and musig_ge_from_bytes_ext are identical to ge_save and ge_load\n+ * except that they allow saving and loading the point at infinity */\n+static void secp256k1_musig_ge_to_bytes_ext(unsigned char *data, secp256k1_ge *ge);\n+\n+static void secp256k1_musig_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data);",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 34,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fce0857aa09a1af71bb3f8a45379fbc3c7768db1",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think these should be in `group.h`, even though they'll be used only by the musig module. Infinity can be helpful in other contexts, and conceptually it's a group function.\r\n\r\nAnyway, the comment needs to be updated `ge_save` and `ge_load` have been renamed. ",
      "created_at": "2024-01-18T16:55:17Z",
      "updated_at": "2024-01-18T16:55:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1457733653",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1457733653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 30,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477961061",
      "pull_request_review_id": 1862362444,
      "id": 1477961061,
      "node_id": "PRRC_kwDOAP4Jqs5YF-Vl",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 212,
      "original_position": 186,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we recommend that users sort their pubkeys before aggregating them? The `musig_pubkey_agg` API documentation simply says the user \"can\" do it.\r\n\r\nIf we recommend the sorting step, including it in the example file would be helpful.",
      "created_at": "2024-02-05T10:23:29Z",
      "updated_at": "2024-02-05T10:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1477961061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477961061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477997628",
      "pull_request_review_id": 1862418731,
      "id": 1477997628,
      "node_id": "PRRC_kwDOAP4Jqs5YGHQ8",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 212,
      "original_position": 186,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1477961061,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think there's no catch-all recommendation. BIP327 says \"The aggregate public key produced by KeyAgg (regardless of the type) depends on the order of the individual public keys. If the application does not have a canonical order of the signers, the individual public keys can be sorted with the KeySort algorithm to ensure that the aggregate public key is independent of the order of signers.\"\r\n\r\nIn other words: If in your application, the collection of pubkeys (or signers represented by them) is conceptually an (ordered) list, then don't bother with sorting. If in your application, the collection of pubkeys is conceptually an (unordered) set, i.e., the application doesn't want to care about the order of pubkeys, then sort to make sure the set has a canonical serialization. \r\n\r\nPerhaps we can explain this somewhere in more detail, either in the API docs or in the example. ",
      "created_at": "2024-02-05T10:52:21Z",
      "updated_at": "2024-02-05T10:52:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1477997628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1477997628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1479443648",
      "pull_request_review_id": 1864630385,
      "id": 1479443648,
      "node_id": "PRRC_kwDOAP4Jqs5YLoTA",
      "diff_hunk": "",
      "path": "src/modules/musig/session_impl.h",
      "position": 1,
      "original_position": 1,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there any specific reason for avoiding sha256 mid-state optimization in the `musig_compute_noncehash` and `nonce_function_musig` functions?",
      "created_at": "2024-02-06T09:13:54Z",
      "updated_at": "2024-02-06T10:21:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1479443648",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1479443648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1516062204",
      "pull_request_review_id": 1922290796,
      "id": 1516062204,
      "node_id": "PRRC_kwDOAP4Jqs5aXUX8",
      "diff_hunk": "@@ -0,0 +1,518 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *     REUSED in subsequent calls to this function.\n+ *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n+ *     session_id32 can instead be a counter (that must never repeat!). However,\n+ *     it is recommended to always choose session_id32 uniformly at random.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 325,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should probably rename this. Despite this big fat warning, `session_id` itself sounds like a public value. \r\n\r\nBrain dump:\r\n -  `session_nonce`: too easy to confuse with the sec nonce\r\n -  `session_rand`: but what if it's counter\r\n -  `session_seed`: okayish\r\n\r\nBut now that I think about this again, I believe that the confusion stems from the fact that we have these two modes: It's either random and secret, or a counter, but that's only okay if you provide a seckey. A single name that fits both scenarios is necessarily imprecise. \r\n\r\nI think a better approach is to provide two different functions, e.g., `secp256k1_musig_nonce_gen` and `secp256k1_musig_nonce_gen_with_counter` (like in the BIP where we have CounterNonceGen as a separate algorithm). Then we can have clear argument names, even very verbose ones like `session_secret_rand` and `nonrepeating_counter`. Moreover, we can enforce the presence of the seckey in the counter function.",
      "created_at": "2024-03-07T12:18:51Z",
      "updated_at": "2024-03-07T12:25:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1516062204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1516062204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518231802",
      "pull_request_review_id": 1925740508,
      "id": 1518231802,
      "node_id": "PRRC_kwDOAP4Jqs5afmD6",
      "diff_hunk": "",
      "path": "src/modules/musig/session_impl.h",
      "position": 1,
      "original_position": 1,
      "commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1479443648,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Because apparently I had been to lazy so far :D. I added this optimization.",
      "created_at": "2024-03-08T19:54:58Z",
      "updated_at": "2024-03-08T19:54:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518231802",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518231802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232232",
      "pull_request_review_id": 1925741106,
      "id": 1518232232,
      "node_id": "PRRC_kwDOAP4Jqs5afmKo",
      "diff_hunk": "@@ -240,6 +240,21 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Sort public keys using lexicographic order of their compressed\n+ *  serialization.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *\n+ *  Args:     ctx: pointer to a context object\n+ *  In:   pubkeys: array of pointers to pubkeys to sort\n+ *      n_pubkeys: number of elements in the pubkeys array\n+ */\n+SECP256K1_API int secp256k1_pubkey_sort(\n+    const secp256k1_context *ctx,\n+    const secp256k1_pubkey **pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 18,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "e1ba262f16fd821ec48e8570d4d2990111ec0ef3",
      "in_reply_to_id": 1457727273,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's reasonable. Done.",
      "created_at": "2024-03-08T19:55:27Z",
      "updated_at": "2024-03-08T19:55:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518232232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232357",
      "pull_request_review_id": 1925741325,
      "id": 1518232357,
      "node_id": "PRRC_kwDOAP4Jqs5afmMl",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,\n+     * parity_acc is 1. Otherwise, parity_acc is 0. */\n+    int parity_acc;\n+} secp256k1_keyagg_cache_internal;\n+\n+/* musig_ge_to_bytes_ext and musig_ge_from_bytes_ext are identical to ge_save and ge_load\n+ * except that they allow saving and loading the point at infinity */\n+static void secp256k1_musig_ge_to_bytes_ext(unsigned char *data, secp256k1_ge *ge);\n+\n+static void secp256k1_musig_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data);",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 34,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fce0857aa09a1af71bb3f8a45379fbc3c7768db1",
      "in_reply_to_id": 1457733653,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, done.",
      "created_at": "2024-03-08T19:55:36Z",
      "updated_at": "2024-03-08T19:55:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518232357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518232357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 30,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518866600",
      "pull_request_review_id": 1926554452,
      "id": 1518866600,
      "node_id": "PRRC_kwDOAP4Jqs5aiBCo",
      "diff_hunk": "@@ -0,0 +1,518 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *     REUSED in subsequent calls to this function.\n+ *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n+ *     session_id32 can instead be a counter (that must never repeat!). However,\n+ *     it is recommended to always choose session_id32 uniformly at random.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 325,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1516062204,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed. I split the two nonce_gen functions.",
      "created_at": "2024-03-10T14:25:41Z",
      "updated_at": "2024-03-10T14:25:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1518866600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1518866600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524409269",
      "pull_request_review_id": 1935966419,
      "id": 1524409269,
      "node_id": "PRRC_kwDOAP4Jqs5a3KO1",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We should then drop the condition \"If you do not provide a seckey,\"",
      "created_at": "2024-03-14T08:13:43Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524409269",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524409269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524421899",
      "pull_request_review_id": 1935966419,
      "id": 1524421899,
      "node_id": "PRRC_kwDOAP4Jqs5a3NUL",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 68,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seckey is mandatory for this function anyway.\r\n\r\nI think usually I would suggest moving this big explainer at the top of the module, so that it covers both functions and does not need to be repeated. But in this case of a big fat warning, it's probably better to keep it in the docstring, where it's harder to miss...",
      "created_at": "2024-03-14T08:18:14Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524421899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524421899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524427434",
      "pull_request_review_id": 1935966419,
      "id": 1524427434,
      "node_id": "PRRC_kwDOAP4Jqs5a3Oqq",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524409269,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could also add a reference to the new function, maybe below the numbered list.\r\n\r\nsomething like \"If you don't have access to good randomness, but you have access to a non-repeating counter, then see ...\"",
      "created_at": "2024-03-14T08:20:11Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524427434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524427434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524437469",
      "pull_request_review_id": 1935966419,
      "id": 1524437469,
      "node_id": "PRRC_kwDOAP4Jqs5a3RHd",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 65,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could expand a bit to mention that this includes cases where the same seckey is used on multiple devices. (Any other precautions to mention?)",
      "created_at": "2024-03-14T08:25:27Z",
      "updated_at": "2024-03-14T08:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1524437469",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1524437469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 381,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1555961371",
      "pull_request_review_id": 1986650201,
      "id": 1555961371,
      "node_id": "PRRC_kwDOAP4Jqs5cvhYb",
      "diff_hunk": "@@ -282,4 +283,38 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     return ret;\n }\n \n+/* This struct wraps a const context pointer to satisfy the secp256k1_hsort api\n+ * which expects a non-const cmp_data pointer. */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+} secp256k1_pubkey_sort_cmp_data;\n+\n+static int secp256k1_pubkey_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(((secp256k1_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+                                     *(secp256k1_pubkey **)pk1,\n+                                     *(secp256k1_pubkey **)pk2);\n+}\n+\n+int secp256k1_pubkey_sort(const secp256k1_context* ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys) {\n+    secp256k1_pubkey_sort_cmp_data cmp_data;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkeys != NULL);\n+\n+    cmp_data.ctx = ctx;\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "26dde295d0ad12a011fc4062ad642852f7ff68fa",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/pull/1479/commits/26dde295d0ad12a011fc4062ad642852f7ff68fa (\"extrakeys: add secp256k1_pubkey_sort\"):\r\n\r\nDoes it make sense to move this block into the `secp256k1_sort` function? I ended up copying these lines while writing a `secp256k1_silentpayments_recipient_sort` function, which made me realize anyone else would also need to copy these lines when writing a sort function for heapsort.",
      "created_at": "2024-04-08T14:41:15Z",
      "updated_at": "2024-04-08T14:43:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1555961371",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1555961371"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 305,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567811652",
      "pull_request_review_id": 2004387164,
      "id": 1567811652,
      "node_id": "PRRC_kwDOAP4Jqs5dcuhE",
      "diff_hunk": "@@ -282,4 +283,38 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     return ret;\n }\n \n+/* This struct wraps a const context pointer to satisfy the secp256k1_hsort api\n+ * which expects a non-const cmp_data pointer. */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+} secp256k1_pubkey_sort_cmp_data;\n+\n+static int secp256k1_pubkey_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(((secp256k1_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+                                     *(secp256k1_pubkey **)pk1,\n+                                     *(secp256k1_pubkey **)pk2);\n+}\n+\n+int secp256k1_pubkey_sort(const secp256k1_context* ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys) {\n+    secp256k1_pubkey_sort_cmp_data cmp_data;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkeys != NULL);\n+\n+    cmp_data.ctx = ctx;\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "26dde295d0ad12a011fc4062ad642852f7ff68fa",
      "in_reply_to_id": 1555961371,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You mean into `secp256k1_hsort`? I'd guess the wrong warning is emitted when `secp256k1_hsort` is called and therefore it would be to late when the warning was disabled in `secp256k1_hsort`.",
      "created_at": "2024-04-16T18:52:20Z",
      "updated_at": "2024-04-16T18:52:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567811652",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567811652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 305,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567814921",
      "pull_request_review_id": 2004392491,
      "id": 1567814921,
      "node_id": "PRRC_kwDOAP4Jqs5dcvUJ",
      "diff_hunk": "@@ -317,12 +318,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_twea\n  *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n  *  special care to not reuse a nonce. This can be ensured by following these rules:\n  *\n- *  1. Each call to this function must have a UNIQUE session_id32 that must NOT BE\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must NOT BE\n  *     REUSED in subsequent calls to this function.\n- *     If you do not provide a seckey, session_id32 _must_ be UNIFORMLY RANDOM\n- *     AND KEPT SECRET (even from other signers). If you do provide a seckey,\n- *     session_id32 can instead be a counter (that must never repeat!). However,\n- *     it is recommended to always choose session_id32 uniformly at random.\n+ *     If you do not provide a seckey, session_secrand32 _must_ be UNIFORMLY RANDOM\n+ *     AND KEPT SECRET (even from other signers).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524409269,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added both suggestions.",
      "created_at": "2024-04-16T18:55:20Z",
      "updated_at": "2024-04-16T18:55:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567814921",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567814921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815429",
      "pull_request_review_id": 2004393323,
      "id": 1567815429,
      "node_id": "PRRC_kwDOAP4Jqs5dcvcF",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 68,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524421899,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "dropped mention of seckey",
      "created_at": "2024-04-16T18:55:51Z",
      "updated_at": "2024-04-16T18:55:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567815429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815998",
      "pull_request_review_id": 2004394236,
      "id": 1567815998,
      "node_id": "PRRC_kwDOAP4Jqs5dcvk-",
      "diff_hunk": "@@ -358,14 +357,72 @@ SECP256K1_API int secp256k1_musig_nonce_gen(\n     const secp256k1_context *ctx,\n     secp256k1_musig_secnonce *secnonce,\n     secp256k1_musig_pubnonce *pubnonce,\n-    const unsigned char *session_id32,\n+    const unsigned char *session_secrand32,\n     const unsigned char *seckey,\n     const secp256k1_pubkey *pubkey,\n     const unsigned char *msg32,\n     const secp256k1_musig_keyagg_cache *keyagg_cache,\n     const unsigned char *extra_input32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n \n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never\n+ *     repeats, i.e., you must never call `secp256k1_musig_nonce_gen_counter`\n+ *     twice with the same seckey and nonrepeating_cnt value.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 65,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "461970682f56a8e15fc71ecab18d4537e50441fc",
      "in_reply_to_id": 1524437469,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-04-16T18:56:24Z",
      "updated_at": "2024-04-16T18:56:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1567815998",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1567815998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 381,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648385148",
      "pull_request_review_id": 1981965588,
      "id": 1648385148,
      "node_id": "PRRC_kwDOAP4Jqs5iQFx8",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 31,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: why does `second_pk_x` need to be normalized?",
      "created_at": "2024-06-21T04:01:55Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648385148",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648385148"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648470153",
      "pull_request_review_id": 1981965588,
      "id": 1648470153,
      "node_id": "PRRC_kwDOAP4Jqs5iQaiJ",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 148,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: micro nit: s/`x`/`pk_x`",
      "created_at": "2024-06-21T06:21:17Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648470153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648470153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648649839",
      "pull_request_review_id": 1981965588,
      "id": 1648649839,
      "node_id": "PRRC_kwDOAP4Jqs5iRGZv",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 217,
      "original_position": 219,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: slightly confused here and in [L277](https://github.com/bitcoin-core/secp256k1/blob/c9362664e672efeee8a0c1ee8779071432b78394/src/modules/musig/keyagg_impl.h#L277). is a `VERIFY_CHECK` instead of `return 0` sufficient for these failures? ",
      "created_at": "2024-06-21T08:59:25Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1648649839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1648649839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 217,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650591872",
      "pull_request_review_id": 1981965588,
      "id": 1650591872,
      "node_id": "PRRC_kwDOAP4Jqs5iYgiA",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 481,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: nit: remove double (()).",
      "created_at": "2024-06-24T08:40:52Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650591872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650591872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650935751",
      "pull_request_review_id": 2135640276,
      "id": 1650935751,
      "node_id": "PRRC_kwDOAP4Jqs5iZ0fH",
      "diff_hunk": "@@ -7,6 +7,13 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [Unreleased]\n \n+#### Added\n+ - New module `musig` implements the MuSig2 multisignature scheme according to the [BIP 327 specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki). See:\n+   - Header file `include/secp256k1_musig.h` which defines the new API.\n+   - Document `doc/musig.md` for further notes on API usage.\n+   - Usage example `examples/musig.c`.\n+ - Added `secp256k1_ec_pubkey_sort` which sorts an array of public keys (see `include/secp256k1.h`).",
      "path": "CHANGELOG.md",
      "position": null,
      "original_position": 9,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This line can be removed, as the function was already added in the last release 0.5.0\r\n```suggestion\r\n```",
      "created_at": "2024-06-24T12:17:56Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650935751",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650935751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650937773",
      "pull_request_review_id": 2135640276,
      "id": 1650937773,
      "node_id": "PRRC_kwDOAP4Jqs5iZ0-t",
      "diff_hunk": "@@ -432,6 +444,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ECDH=1\"\n fi\n \n+if test x\"$enable_module_ellswift\" = x\"yes\"; then\n+  SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\n+fi\n+",
      "path": "configure.ac",
      "position": null,
      "original_position": 33,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This code block already exists about 30 lines above (was it intended to be moved from top to bottom?).",
      "created_at": "2024-06-24T12:19:36Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1650937773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1650937773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 447,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651017476",
      "pull_request_review_id": 2135640276,
      "id": 1651017476,
      "node_id": "PRRC_kwDOAP4Jqs5iaIcE",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3",
      "path": "examples/musig.c",
      "position": 37,
      "original_position": 37,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Verified that the example also succeeds with larger values of `N_SIGNERS`, like e.g. 15000. At some point if the limit is increased further (e.g. 20000), segmentation faults occur on my machine, I guess this happens due to some stack limits being exceeded.",
      "created_at": "2024-06-24T13:14:20Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651017476",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651017476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 36,
      "original_start_line": 36,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651022302",
      "pull_request_review_id": 2135640276,
      "id": 1651022302,
      "node_id": "PRRC_kwDOAP4Jqs5iaJne",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            return 0;\r\n```",
      "created_at": "2024-06-24T13:17:48Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651022302",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651022302"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651029879",
      "pull_request_review_id": 2135640276,
      "id": 1651029879,
      "node_id": "PRRC_kwDOAP4Jqs5iaLd3",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 69,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n    /* Note that we did not provide an output_pk argument, because the\r\n```",
      "created_at": "2024-06-24T13:23:13Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651029879",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651029879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651039249",
      "pull_request_review_id": 2135640276,
      "id": 1651039249,
      "node_id": "PRRC_kwDOAP4Jqs5iaNwR",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Tweaking................\");\n+    /* Optionally tweak the aggregate key */\n+    if (!tweak(ctx, &agg_pk, &cache)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Signing message.........\");",
      "path": "examples/musig.c",
      "position": 230,
      "original_position": 200,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: if an operation takes longer, it would be nice to see this message already before the function call following returns\r\n```suggestion\r\n    printf(\"Signing message.........\"); fflush(stdout);\r\n```\r\n(noticed this for larger values of N_SIGNERS, for the value of 3 chosen here it shouldn't matter though even on slow hardware)",
      "created_at": "2024-06-24T13:28:39Z",
      "updated_at": "2024-06-24T13:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651039249",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651039249"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 230,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651407455",
      "pull_request_review_id": 2136423614,
      "id": 1651407455,
      "node_id": "PRRC_kwDOAP4Jqs5ibnpf",
      "diff_hunk": "@@ -432,6 +444,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ECDH=1\"\n fi\n \n+if test x\"$enable_module_ellswift\" = x\"yes\"; then\n+  SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\n+fi\n+",
      "path": "configure.ac",
      "position": null,
      "original_position": 33,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1650937773,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the duplication was just introduced as a mistake when rebasing after https://github.com/bitcoin-core/secp256k1/pull/1482 ",
      "created_at": "2024-06-24T17:47:10Z",
      "updated_at": "2024-06-24T17:47:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1651407455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1651407455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 447,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652109381",
      "pull_request_review_id": 1981965588,
      "id": 1652109381,
      "node_id": "PRRC_kwDOAP4Jqs5ieTBF",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    secp256k1_fe_normalize_var(&pk.x);\n+    /* TODO Cache mu */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pk);\n+    secp256k1_scalar_mul(&sk, &sk, &mu);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_scalar_negate(&k[0], &k[0]);\n+        secp256k1_scalar_negate(&k[1], &k[1]);\n+    }\n+\n+    /* Sign */\n+    secp256k1_scalar_mul(&s, &session_i.challenge, &sk);\n+    secp256k1_scalar_mul(&k[1], &session_i.noncecoef, &k[1]);\n+    secp256k1_scalar_add(&k[0], &k[0], &k[1]);\n+    secp256k1_scalar_add(&s, &s, &k[0]);\n+    secp256k1_musig_partial_sig_save(partial_sig, &s);\n+    secp256k1_musig_partial_sign_clear(&sk, k);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_verify(const secp256k1_context* ctx, const secp256k1_musig_partial_sig *partial_sig, const secp256k1_musig_pubnonce *pubnonce, const secp256k1_pubkey *pubkey, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    secp256k1_scalar mu, e, s;\n+    secp256k1_gej pkj;\n+    secp256k1_ge nonce_pt[2];\n+    secp256k1_gej rj;\n+    secp256k1_gej tmp;\n+    secp256k1_ge pkp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(pubnonce != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+\n+    /* Compute \"effective\" nonce rj = aggnonce[0] + b*aggnonce[1] */\n+    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + aggnonce[0] + b*aggnonce[1] */\n+    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&rj, &nonce_pt[1]);\n+    secp256k1_ecmult(&rj, &rj, &session_i.noncecoef, NULL);\n+    secp256k1_gej_add_ge_var(&rj, &rj, &nonce_pt[0], NULL);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pubkey)) {\n+        return 0;\n+    }\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    /* Multiplying the challenge by the KeyAgg coefficient is equivalent\n+     * to multiplying the signer's public key by the coefficient, except\n+     * much easier to do. */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pkp);\n+    secp256k1_scalar_mul(&e, &session_i.challenge, &mu);\n+\n+    /* Negate e if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let g' = g⋅gacc mod n\" and the multiplication \"g'⋅e\"\n+     * in the specification. */\n+    if (secp256k1_fe_is_odd(&cache_i.pk.y)\n+            != cache_i.parity_acc) {\n+        secp256k1_scalar_negate(&e, &e);\n+    }\n+\n+    if (!secp256k1_musig_partial_sig_load(ctx, &s, partial_sig)) {\n+        return 0;\n+    }\n+    /* Compute -s*G + e*pkj + rj (e already includes the keyagg coefficient mu) */\n+    secp256k1_scalar_negate(&s, &s);\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+    secp256k1_ecmult(&tmp, &pkj, &e, &s);\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_gej_neg(&rj, &rj);\n+    }\n+    secp256k1_gej_add_var(&tmp, &tmp, &rj, NULL);\n+\n+    return secp256k1_gej_is_infinity(&tmp);\n+}\n+\n+int secp256k1_musig_partial_sig_agg(const secp256k1_context* ctx, unsigned char *sig64, const secp256k1_musig_session *session, const secp256k1_musig_partial_sig * const* partial_sigs, size_t n_sigs) {\n+    size_t i;\n+    secp256k1_musig_session_internal session_i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(partial_sigs != NULL);\n+    ARG_CHECK(n_sigs > 0);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+    for (i = 0; i < n_sigs; i++) {\n+        secp256k1_scalar term;\n+        if (!secp256k1_musig_partial_sig_load(ctx, &term, partial_sigs[i])) {\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &term);",
      "path": "src/modules/musig/session_impl.h",
      "position": 808,
      "original_position": 796,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: don't we need to do the `e⋅g⋅tacc` part of this equation `s = s1 + ... + su + e⋅g⋅tacc mod n`?",
      "created_at": "2024-06-25T07:06:12Z",
      "updated_at": "2024-06-25T13:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1652109381",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652109381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 808,
      "original_line": 808,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652542038",
      "pull_request_review_id": 2138282721,
      "id": 1652542038,
      "node_id": "PRRC_kwDOAP4Jqs5if8pW",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 12,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  include/secp256k1_musig.h and doc/musig.md.\r\n```",
      "created_at": "2024-06-25T10:57:22Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1652542038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1652542038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655153854",
      "pull_request_review_id": 2138282721,
      "id": 1655153854,
      "node_id": "PRRC_kwDOAP4Jqs5ip6S-",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 278,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shouldn't this function call `_musig_partial_sig_load`, in order to check the 4 bytes magic and verify that the scalar doesn't overflow? (similar to the `_musig_{pub,agg}nonce_serialize` functions which also call `_musig_{pub,agg}nonce_load` first)",
      "created_at": "2024-06-26T16:09:51Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655153854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655153854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 272,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655213103",
      "pull_request_review_id": 2138282721,
      "id": 1655213103,
      "node_id": "PRRC_kwDOAP4Jqs5iqIwv",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": 238,
      "original_position": 240,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: IIUC, `agg_pk` can be directly retrieved in the `_musig_pubkey_agg` call:\r\n```suggestion\r\n *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\r\n```\r\n(that's how it's also done in the API description for the x-only tweaking function below)",
      "created_at": "2024-06-26T16:43:59Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655213103",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655213103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 237,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": 238,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655222415",
      "pull_request_review_id": 2138282721,
      "id": 1655222415,
      "node_id": "PRRC_kwDOAP4Jqs5iqLCP",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 244,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: not sure how strict we want to be here to match the exact API, but with all parameters considered, it would look like e.g.\r\n\r\n```suggestion\r\n *  secp256k1_ec_pubkey_serialize(..., buf2, &outlen, agg_pk, ...)\r\n```",
      "created_at": "2024-06-26T16:49:37Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655222415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655222415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655226973",
      "pull_request_review_id": 2138282721,
      "id": 1655226973,
      "node_id": "PRRC_kwDOAP4Jqs5iqMJd",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 282,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\r\n```",
      "created_at": "2024-06-26T16:52:27Z",
      "updated_at": "2024-06-26T16:56:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655226973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1655226973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656647479",
      "pull_request_review_id": 2144558746,
      "id": 1656647479,
      "node_id": "PRRC_kwDOAP4Jqs5ivm83",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 185,
      "original_position": 187,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: what is the difference between doing `ARG_CHECK`s like this here vs [`SECP256K1_ARG_NONNULL(4)` checks in the function declaration](https://github.com/bitcoin-core/secp256k1/blob/77489bf422e3714b5a5f6427b97ea4ef91bd34dc/include/secp256k1_musig.h#L211) for the same function parameter.",
      "created_at": "2024-06-27T07:55:17Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1656647479",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656647479"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 185,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656757258",
      "pull_request_review_id": 2144558746,
      "id": 1656757258,
      "node_id": "PRRC_kwDOAP4Jqs5iwBwK",
      "diff_hunk": "@@ -0,0 +1,1104 @@\n+/***********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    secp256k1_testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            secp256k1_testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = secp256k1_testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        secp256k1_testrand256(session_secrand[i]);\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 233,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: isn't this a repetition of L230?",
      "created_at": "2024-06-27T09:07:09Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1656757258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656757258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656982350",
      "pull_request_review_id": 2144558746,
      "id": 1656982350,
      "node_id": "PRRC_kwDOAP4Jqs5iw4tO",
      "diff_hunk": "@@ -0,0 +1,1104 @@\n+/***********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    secp256k1_testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            secp256k1_testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = secp256k1_testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        secp256k1_testrand256(session_secrand[i]);\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand, sk and pubkey can be NULL */",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 297,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: s/`session_secrand`/`nonrepeating_cnt`",
      "created_at": "2024-06-27T11:42:19Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1656982350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656982350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656985079",
      "pull_request_review_id": 2144558746,
      "id": 1656985079,
      "node_id": "PRRC_kwDOAP4Jqs5iw5X3",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 430,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c936266: `SECP256K1_ARG_NONNULL(4)` too?",
      "created_at": "2024-06-27T11:44:52Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1656985079",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1656985079"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657472337",
      "pull_request_review_id": 2145962171,
      "id": 1657472337,
      "node_id": "PRRC_kwDOAP4Jqs5iywVR",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 300,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, could also check the lower bound of `prefix_size`:\r\n```suggestion\r\n    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\r\n```",
      "created_at": "2024-06-27T16:51:42Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657472337",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657472337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657475037",
      "pull_request_review_id": 2145962171,
      "id": 1657475037,
      "node_id": "PRRC_kwDOAP4Jqs5iyw_d",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 485,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could use the _write_be64 helper here:\r\n```suggestion\r\n    secp256k1_write_be64(buf, nonrepeating_cnt);\r\n```",
      "created_at": "2024-06-27T16:54:00Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657475037",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657475037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 483,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657483220",
      "pull_request_review_id": 2145962171,
      "id": 1657483220,
      "node_id": "PRRC_kwDOAP4Jqs5iyy_U",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 361,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this comment a leftover? I couldn't figure out to what `sizeof` it refers to and where a subtraction happens.",
      "created_at": "2024-06-27T17:01:10Z",
      "updated_at": "2024-06-27T17:04:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1657483220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1657483220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659076501",
      "pull_request_review_id": 2148574147,
      "id": 1659076501,
      "node_id": "PRRC_kwDOAP4Jqs5i43-V",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 613,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've noticed that the aggregated nonce points are converted from affine to jacobi coordinates here, and then again from jacobi to affine inside `secp256k1_musig_nonce_process_internal`. Could pass as affine coordinates to the internal function instead in order to do only one conversion there. With the following patch, the tests still pass:\r\n\r\n<details>\r\n<summary>Patch</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/musig/session_impl.h b/src/modules/musig/session_impl.h\r\nindex b0ea45d..b073ec0 100644\r\n--- a/src/modules/musig/session_impl.h\r\n+++ b/src/modules/musig/session_impl.h\r\n@@ -557,14 +557,14 @@ static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1\r\n     return 1;\r\n }\r\n \r\n-static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\r\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\r\n     unsigned char noncehash[32];\r\n     secp256k1_ge fin_nonce_pt;\r\n     secp256k1_gej fin_nonce_ptj;\r\n-    secp256k1_ge aggnonce[2];\r\n+    secp256k1_gej aggnoncej[2];\r\n \r\n-    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\r\n-    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\r\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\r\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\r\n     if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\r\n         return 0;\r\n     }\r\n@@ -588,7 +588,6 @@ static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigne\r\n int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\r\n     secp256k1_keyagg_cache_internal cache_i;\r\n     secp256k1_ge aggnonce_pt[2];\r\n-    secp256k1_gej aggnonce_ptj[2];\r\n     unsigned char fin_nonce[32];\r\n     secp256k1_musig_session_internal session_i;\r\n     unsigned char agg_pk32[32];\r\n@@ -607,10 +606,8 @@ int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_\r\n     if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\r\n         return 0;\r\n     }\r\n-    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\r\n-    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\r\n \r\n-    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\r\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pt, agg_pk32, msg32)) {\r\n         return 0;\r\n     }\r\n```\r\n</details>",
      "created_at": "2024-06-28T17:16:39Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659076501",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659076501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 610,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659078837",
      "pull_request_review_id": 2148574147,
      "id": 1659078837,
      "node_id": "PRRC_kwDOAP4Jqs5i44i1",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 627,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: could assign the result directly rather than adding (session_i.s_part is zero at this point):\r\n```suggestion\r\n        session_i.s_part = e_tmp;\r\n```",
      "created_at": "2024-06-28T17:19:16Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659078837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659078837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 627,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659104375",
      "pull_request_review_id": 2148574147,
      "id": 1659104375,
      "node_id": "PRRC_kwDOAP4Jqs5i4-x3",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 677,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: though it doesn't hurt, normalizing doesn't seem to be necessary, considering that `pk` is created via deserialization (`_musig_secnonce_load` -> `_ge_from_bytes` -> `_ge_from_storage` -> `_fe_from_storage`), where the group element's coordinates x and y are always normalized initially. Same for `pk.x` below.",
      "created_at": "2024-06-28T17:39:59Z",
      "updated_at": "2024-06-28T17:45:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1659104375",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1659104375"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660173809",
      "pull_request_review_id": 2150045420,
      "id": 1660173809,
      "node_id": "PRRC_kwDOAP4Jqs5i9D3x",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": 367,
      "original_position": 359,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering that `rand` contains secret data, should it be cleared at the end of the function? (same for `buf` and `sha_tmp` in the loop below I guess)",
      "created_at": "2024-06-30T12:46:20Z",
      "updated_at": "2024-06-30T12:50:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1660173809",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660173809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 365,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": 367,
      "original_line": 367,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660450764",
      "pull_request_review_id": 2144558746,
      "id": 1660450764,
      "node_id": "PRRC_kwDOAP4Jqs5i-HfM",
      "diff_hunk": "@@ -0,0 +1,1104 @@\n+/***********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    secp256k1_testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            secp256k1_testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = secp256k1_testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        secp256k1_testrand256(session_secrand[i]);\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session) == 1);\n+    /* The secnonce is set to 0 and subsequent signing attempts fail */\n+    CHECK(secp256k1_memcmp_var(&secnonce_tmp, zeros132, sizeof(secnonce_tmp)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, NULL, &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], NULL, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &invalid_secnonce, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, NULL, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &invalid_keypair, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    {\n+        unsigned char sk_tmp[32];\n+        secp256k1_keypair keypair_tmp;\n+        secp256k1_testrand256(sk_tmp);\n+        CHECK(secp256k1_keypair_create(CTX, &keypair_tmp, sk_tmp));\n+        CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair_tmp, &keyagg_cache, &session));\n+        memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], NULL, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &invalid_keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, NULL));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &invalid_session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], &keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, NULL, &partial_sig[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, NULL));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], buf) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, NULL, buf));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], max64) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], NULL));\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, buf) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &partial_sig[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Partial signature verification */\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, NULL, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &invalid_partial_sig, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], NULL, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &invalid_pubnonce, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], NULL, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &invalid_pk, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], NULL, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &invalid_keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &invalid_session));\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], &keyagg_cache, &session) == 1);\n+\n+    /** Signature aggregation and verification */\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, NULL, &session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, NULL, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &invalid_session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, invalid_partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 0));\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 1) == 1);\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+}\n+\n+static void musig_nonce_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    secp256k1_scalar k1[2], k2[2];\n+\n+    secp256k1_nonce_function_musig(k1, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_testrand_flip(args[n_flip], n_bytes);\n+    secp256k1_nonce_function_musig(k2, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    CHECK(secp256k1_scalar_eq(&k1[0], &k2[0]) == 0);\n+    CHECK(secp256k1_scalar_eq(&k1[1], &k2[1]) == 0);\n+}\n+\n+static void musig_nonce_test(void) {\n+    unsigned char *args[6];\n+    unsigned char session_secrand[32];\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    unsigned char msg[32];\n+    unsigned char agg_pk[32];\n+    unsigned char extra_input[32];\n+    int i, j;\n+    secp256k1_scalar k[6][2];\n+\n+    secp256k1_testrand_bytes_test(session_secrand, sizeof(session_secrand));\n+    secp256k1_testrand_bytes_test(sk, sizeof(sk));\n+    secp256k1_testrand_bytes_test(pk, sizeof(pk));\n+    secp256k1_testrand_bytes_test(msg, sizeof(msg));\n+    secp256k1_testrand_bytes_test(agg_pk, sizeof(agg_pk));\n+    secp256k1_testrand_bytes_test(extra_input, sizeof(extra_input));\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = session_secrand;\n+    args[1] = msg;\n+    args[2] = sk;\n+    args[3] = pk;\n+    args[4] = agg_pk;\n+    args[5] = extra_input;\n+    for (i = 0; i < COUNT; i++) {\n+        musig_nonce_bitflip(args, 0, sizeof(session_secrand));\n+        musig_nonce_bitflip(args, 1, sizeof(msg));\n+        musig_nonce_bitflip(args, 2, sizeof(sk));\n+        musig_nonce_bitflip(args, 3, sizeof(pk));\n+        musig_nonce_bitflip(args, 4, sizeof(agg_pk));\n+        musig_nonce_bitflip(args, 5, sizeof(extra_input));\n+    }\n+    /* Check that if any argument is NULL, a different nonce is produced than if\n+     * any other argument is NULL. */\n+    memcpy(msg, session_secrand, sizeof(msg));\n+    memcpy(sk, session_secrand, sizeof(sk));\n+    memcpy(pk, session_secrand, sizeof(session_secrand));\n+    memcpy(agg_pk, session_secrand, sizeof(agg_pk));\n+    memcpy(extra_input, session_secrand, sizeof(extra_input));\n+    secp256k1_nonce_function_musig(k[0], args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[1], args[0], NULL, args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[2], args[0], args[1], NULL, args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[3], args[0], args[1], args[2], NULL, args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[4], args[0], args[1], args[2], args[3], NULL, args[5]);\n+    secp256k1_nonce_function_musig(k[5], args[0], args[1], args[2], args[3], args[4], NULL);\n+    for (i = 0; i < 6; i++) {\n+        CHECK(!secp256k1_scalar_eq(&k[i][0], &k[i][1]));\n+        for (j = i+1; j < 6; j++) {\n+            CHECK(!secp256k1_scalar_eq(&k[i][0], &k[j][0]));\n+            CHECK(!secp256k1_scalar_eq(&k[i][1], &k[j][1]));\n+        }\n+    }\n+}\n+\n+static void sha256_tag_test_internal(secp256k1_sha256 *sha_tagged, unsigned char *tag, size_t taglen) {\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    test_sha256_eq(&sha, sha_tagged);\n+}\n+\n+/* Checks that the initialized tagged hashes initialized have the expected\n+ * state. */\n+static void sha256_tag_test(void) {\n+    secp256k1_sha256 sha;\n+    {\n+        char tag[11] = \"KeyAgg list\";\n+        secp256k1_musig_keyagglist_sha256(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));\n+    }\n+    {\n+        char tag[18] = \"KeyAgg coefficient\";\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));\n+    }\n+    {\n+        unsigned char tag[9] = \"MuSig/aux\";\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));\n+    }\n+    {\n+        unsigned char tag[11] = \"MuSig/nonce\";\n+        secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));\n+    }\n+    {\n+        unsigned char tag[15] = \"MuSig/noncecoef\";\n+        secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));\n+    }\n+}\n+\n+/* Attempts to create a signature for the aggregate public key using given secret\n+ * keys and keyagg_cache. */\n+static void musig_tweak_test_helper(const secp256k1_xonly_pubkey* agg_pk, const unsigned char *sk0, const unsigned char *sk1, secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_pubkey pk[2];\n+    unsigned char session_secrand[2][32];\n+    unsigned char msg[32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_session session;\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    int i;\n+\n+    for (i = 0; i < 2; i++) {\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        secp256k1_testrand256(session_secrand[i]);\n+    }\n+    CHECK(create_keypair_and_pk(&keypair[0], &pk[0], sk0) == 1);\n+    CHECK(create_keypair_and_pk(&keypair[1], &pk[1], sk1) == 1);\n+    secp256k1_testrand256(msg);\n+\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk0, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk1, &pk[1], NULL, NULL, NULL) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), agg_pk) == 1);\n+}\n+\n+/* Create aggregate public key P[0], tweak multiple times (using xonly and\n+ * plain tweaking) and test signing. */\n+static void musig_tweak_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    enum { N_TWEAKS = 8 };\n+    secp256k1_pubkey P[N_TWEAKS + 1];\n+    secp256k1_xonly_pubkey P_xonly[N_TWEAKS + 1];\n+    int i;\n+\n+    /* Key Setup */\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(NULL, &pk[i], sk[i]) == 1);\n+    }\n+    /* Compute P0 = keyagg(pk0, pk1) and test signing for it */\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &P_xonly[0], &keyagg_cache, pk_ptr, 2) == 1);\n+    musig_tweak_test_helper(&P_xonly[0], sk[0], sk[1], &keyagg_cache);\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &P[0], &keyagg_cache));\n+\n+    /* Compute Pi = f(Pj) + tweaki*G where where j = i-1 and try signing for\n+     * that key. If xonly is set to true, the function f is normalizes the input",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 624,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c9362664e: micro grammar nit: s/is normalizes/normalizes",
      "created_at": "2024-07-01T04:50:47Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1660450764",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660450764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660520958",
      "pull_request_review_id": 2144558746,
      "id": 1660520958,
      "node_id": "PRRC_kwDOAP4Jqs5i-Yn-",
      "diff_hunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Automatically generated by tools/test_vectors_musig2_generate.py.\n+ *\n+ * The test vectors for the KeySort function are included in this file. They can\n+ * be found in src/modules/extrakeys/tests_impl.h. */\n+\n+enum MUSIG_ERROR {\n+    MUSIG_PUBKEY,\n+    MUSIG_TWEAK,\n+    MUSIG_PUBNONCE,\n+    MUSIG_AGGNONCE,\n+    MUSIG_SECNONCE,\n+    MUSIG_SIG,\n+    MUSIG_SIG_VERIFY,\n+    MUSIG_OTHER\n+};\n+\n+struct musig_key_agg_valid_test_case {\n+    size_t key_indices_len;\n+    size_t key_indices[4];\n+    unsigned char expected[32];\n+};\n+\n+struct musig_key_agg_error_test_case {\n+    size_t key_indices_len;\n+    size_t key_indices[4];\n+    size_t tweak_indices_len;\n+    size_t tweak_indices[1];\n+    int is_xonly[1];\n+    enum MUSIG_ERROR error;\n+};\n+\n+struct musig_key_agg_vector {\n+    unsigned char pubkeys[7][33];\n+    unsigned char tweaks[2][32];\n+    struct musig_key_agg_valid_test_case valid_case[4];\n+    struct musig_key_agg_error_test_case error_case[5];\n+};\n+\n+static const struct musig_key_agg_vector musig_key_agg_vector = {\n+    {\n+        { 0x02, 0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10, 0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29, 0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0, 0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9 },\n+        { 0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59 },\n+        { 0x02, 0x35, 0x90, 0xA9, 0x4E, 0x76, 0x8F, 0x8E, 0x18, 0x15, 0xC2, 0xF2, 0x4B, 0x4D, 0x80, 0xA8, 0xE3, 0x14, 0x93, 0x16, 0xC3, 0x51, 0x8C, 0xE7, 0xB7, 0xAD, 0x33, 0x83, 0x68, 0xD0, 0x38, 0xCA, 0x66 },\n+        { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05 },\n+        { 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30 },\n+        { 0x04, 0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10, 0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29, 0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0, 0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9 },\n+        { 0x03, 0x93, 0x5F, 0x97, 0x2D, 0xA0, 0x13, 0xF8, 0x0A, 0xE0, 0x11, 0x89, 0x0F, 0xA8, 0x9B, 0x67, 0xA2, 0x7B, 0x7B, 0xE6, 0xCC, 0xB2, 0x4D, 0x32, 0x74, 0xD1, 0x8B, 0x2D, 0x40, 0x67, 0xF2, 0x61, 0xA9 }\n+    },\n+    {\n+        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41 },\n+        { 0x25, 0x2E, 0x4B, 0xD6, 0x74, 0x10, 0xA7, 0x6C, 0xDF, 0x93, 0x3D, 0x30, 0xEA, 0xA1, 0x60, 0x82, 0x14, 0x03, 0x7F, 0x1B, 0x10, 0x5A, 0x01, 0x3E, 0xCC, 0xD3, 0xC5, 0xC1, 0x84, 0xA6, 0x11, 0x0B }\n+    },\n+    {\n+        {  3, { 0, 1, 2 }, { 0x90, 0x53, 0x9E, 0xED, 0xE5, 0x65, 0xF5, 0xD0, 0x54, 0xF3, 0x2C, 0xC0, 0xC2, 0x20, 0x12, 0x68, 0x89, 0xED, 0x1E, 0x5D, 0x19, 0x3B, 0xAF, 0x15, 0xAE, 0xF3, 0x44, 0xFE, 0x59, 0xD4, 0x61, 0x0C }},\n+        {  3, { 2, 1, 0 }, { 0x62, 0x04, 0xDE, 0x8B, 0x08, 0x34, 0x26, 0xDC, 0x6E, 0xAF, 0x95, 0x02, 0xD2, 0x70, 0x24, 0xD5, 0x3F, 0xC8, 0x26, 0xBF, 0x7D, 0x20, 0x12, 0x14, 0x8A, 0x05, 0x75, 0x43, 0x5D, 0xF5, 0x4B, 0x2B }},\n+        {  3, { 0, 0, 0 }, { 0xB4, 0x36, 0xE3, 0xBA, 0xD6, 0x2B, 0x8C, 0xD4, 0x09, 0x96, 0x9A, 0x22, 0x47, 0x31, 0xC1, 0x93, 0xD0, 0x51, 0x16, 0x2D, 0x8C, 0x5A, 0xE8, 0xB1, 0x09, 0x30, 0x61, 0x27, 0xDA, 0x3A, 0xA9, 0x35 }},\n+        {  4, { 0, 0, 1, 1 }, { 0x69, 0xBC, 0x22, 0xBF, 0xA5, 0xD1, 0x06, 0x30, 0x6E, 0x48, 0xA2, 0x06, 0x79, 0xDE, 0x1D, 0x73, 0x89, 0x38, 0x61, 0x24, 0xD0, 0x75, 0x71, 0xD0, 0xD8, 0x72, 0x68, 0x60, 0x28, 0xC2, 0x6A, 0x3E }},\n+    },\n+    {\n+        {  2, { 0, 3 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 0, 4 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 5, 0 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 0, 1 },  1, { 0 }, { 1 }, MUSIG_TWEAK },\n+        {  1, { 6 },  1, { 1 }, { 0 }, MUSIG_TWEAK },\n+    },\n+};\n+\n+struct musig_nonce_gen_test_case {\n+    unsigned char rand_[32];\n+    int has_sk;\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    int has_aggpk;\n+    unsigned char aggpk[32];\n+    int has_msg;\n+    unsigned char msg[32];\n+    int has_extra_in;\n+    unsigned char extra_in[32];\n+    unsigned char expected_secnonce[97];",
      "path": "src/modules/musig/vectors.h",
      "position": 80,
      "original_position": 80,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c9362664e: micro nit: we could remove the last 33 bytes and make it `expected_secnonce[64]`.",
      "created_at": "2024-07-01T06:16:11Z",
      "updated_at": "2024-07-01T09:58:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1660520958",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1660520958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 80,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304091",
      "pull_request_review_id": 2169157464,
      "id": 1672304091,
      "node_id": "PRRC_kwDOAP4Jqs5jrVXb",
      "diff_hunk": "@@ -7,6 +7,13 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [Unreleased]\n \n+#### Added\n+ - New module `musig` implements the MuSig2 multisignature scheme according to the [BIP 327 specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki). See:\n+   - Header file `include/secp256k1_musig.h` which defines the new API.\n+   - Document `doc/musig.md` for further notes on API usage.\n+   - Usage example `examples/musig.c`.\n+ - Added `secp256k1_ec_pubkey_sort` which sorts an array of public keys (see `include/secp256k1.h`).",
      "path": "CHANGELOG.md",
      "position": null,
      "original_position": 9,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1650935751,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-10T13:48:40Z",
      "updated_at": "2024-07-10T13:48:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672304091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304294",
      "pull_request_review_id": 2169157775,
      "id": 1672304294,
      "node_id": "PRRC_kwDOAP4Jqs5jrVam",
      "diff_hunk": "@@ -432,6 +444,10 @@ if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ECDH=1\"\n fi\n \n+if test x\"$enable_module_ellswift\" = x\"yes\"; then\n+  SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\n+fi\n+",
      "path": "configure.ac",
      "position": null,
      "original_position": 33,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1650937773,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, fixed",
      "created_at": "2024-07-10T13:48:47Z",
      "updated_at": "2024-07-10T13:48:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672304294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 447,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304863",
      "pull_request_review_id": 2169158675,
      "id": 1672304863,
      "node_id": "PRRC_kwDOAP4Jqs5jrVjf",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651022302,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oops, fixed",
      "created_at": "2024-07-10T13:49:06Z",
      "updated_at": "2024-07-10T13:49:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672304863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672304863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672305252",
      "pull_request_review_id": 2169159285,
      "id": 1672305252,
      "node_id": "PRRC_kwDOAP4Jqs5jrVpk",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 69,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651029879,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-10T13:49:17Z",
      "updated_at": "2024-07-10T13:49:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672305252",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672305252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672306206",
      "pull_request_review_id": 2169160850,
      "id": 1672306206,
      "node_id": "PRRC_kwDOAP4Jqs5jrV4e",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Tweaking................\");\n+    /* Optionally tweak the aggregate key */\n+    if (!tweak(ctx, &agg_pk, &cache)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Signing message.........\");",
      "path": "examples/musig.c",
      "position": 230,
      "original_position": 200,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651039249,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Makes sense. Added fflush after every printf without a newline.",
      "created_at": "2024-07-10T13:49:50Z",
      "updated_at": "2024-07-10T13:49:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672306206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672306206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 230,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672306865",
      "pull_request_review_id": 2169161977,
      "id": 1672306865,
      "node_id": "PRRC_kwDOAP4Jqs5jrWCx",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 31,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1648385148,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it doesn't anymore, fixed",
      "created_at": "2024-07-10T13:50:16Z",
      "updated_at": "2024-07-10T13:50:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672306865",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672306865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307190",
      "pull_request_review_id": 2169162555,
      "id": 1672307190,
      "node_id": "PRRC_kwDOAP4Jqs5jrWH2",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 148,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1648470153,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This was a bogus comment anyway. Fixed.",
      "created_at": "2024-07-10T13:50:29Z",
      "updated_at": "2024-07-10T13:50:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672307190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307448",
      "pull_request_review_id": 2169162975,
      "id": 1672307448,
      "node_id": "PRRC_kwDOAP4Jqs5jrWL4",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 217,
      "original_position": 219,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1648649839,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe so. These conditions are effectively unreachable. If they do become reachable, then we have a serious bug that the tests hopefully notice. Moreover, we cannot exercise the VERIFY_CHECKed conditions with a test, so if we would add a branch we couldn't cover it.",
      "created_at": "2024-07-10T13:50:39Z",
      "updated_at": "2024-07-10T13:50:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672307448",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307448"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 217,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307609",
      "pull_request_review_id": 2169163253,
      "id": 1672307609,
      "node_id": "PRRC_kwDOAP4Jqs5jrWOZ",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 481,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1650591872,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-10T13:50:46Z",
      "updated_at": "2024-07-10T13:50:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672307609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307861",
      "pull_request_review_id": 2169163676,
      "id": 1672307861,
      "node_id": "PRRC_kwDOAP4Jqs5jrWSV",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    secp256k1_fe_normalize_var(&pk.x);\n+    /* TODO Cache mu */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pk);\n+    secp256k1_scalar_mul(&sk, &sk, &mu);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_scalar_negate(&k[0], &k[0]);\n+        secp256k1_scalar_negate(&k[1], &k[1]);\n+    }\n+\n+    /* Sign */\n+    secp256k1_scalar_mul(&s, &session_i.challenge, &sk);\n+    secp256k1_scalar_mul(&k[1], &session_i.noncecoef, &k[1]);\n+    secp256k1_scalar_add(&k[0], &k[0], &k[1]);\n+    secp256k1_scalar_add(&s, &s, &k[0]);\n+    secp256k1_musig_partial_sig_save(partial_sig, &s);\n+    secp256k1_musig_partial_sign_clear(&sk, k);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_verify(const secp256k1_context* ctx, const secp256k1_musig_partial_sig *partial_sig, const secp256k1_musig_pubnonce *pubnonce, const secp256k1_pubkey *pubkey, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    secp256k1_scalar mu, e, s;\n+    secp256k1_gej pkj;\n+    secp256k1_ge nonce_pt[2];\n+    secp256k1_gej rj;\n+    secp256k1_gej tmp;\n+    secp256k1_ge pkp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(pubnonce != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+\n+    /* Compute \"effective\" nonce rj = aggnonce[0] + b*aggnonce[1] */\n+    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + aggnonce[0] + b*aggnonce[1] */\n+    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&rj, &nonce_pt[1]);\n+    secp256k1_ecmult(&rj, &rj, &session_i.noncecoef, NULL);\n+    secp256k1_gej_add_ge_var(&rj, &rj, &nonce_pt[0], NULL);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pubkey)) {\n+        return 0;\n+    }\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    /* Multiplying the challenge by the KeyAgg coefficient is equivalent\n+     * to multiplying the signer's public key by the coefficient, except\n+     * much easier to do. */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pkp);\n+    secp256k1_scalar_mul(&e, &session_i.challenge, &mu);\n+\n+    /* Negate e if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let g' = g⋅gacc mod n\" and the multiplication \"g'⋅e\"\n+     * in the specification. */\n+    if (secp256k1_fe_is_odd(&cache_i.pk.y)\n+            != cache_i.parity_acc) {\n+        secp256k1_scalar_negate(&e, &e);\n+    }\n+\n+    if (!secp256k1_musig_partial_sig_load(ctx, &s, partial_sig)) {\n+        return 0;\n+    }\n+    /* Compute -s*G + e*pkj + rj (e already includes the keyagg coefficient mu) */\n+    secp256k1_scalar_negate(&s, &s);\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+    secp256k1_ecmult(&tmp, &pkj, &e, &s);\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_gej_neg(&rj, &rj);\n+    }\n+    secp256k1_gej_add_var(&tmp, &tmp, &rj, NULL);\n+\n+    return secp256k1_gej_is_infinity(&tmp);\n+}\n+\n+int secp256k1_musig_partial_sig_agg(const secp256k1_context* ctx, unsigned char *sig64, const secp256k1_musig_session *session, const secp256k1_musig_partial_sig * const* partial_sigs, size_t n_sigs) {\n+    size_t i;\n+    secp256k1_musig_session_internal session_i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(partial_sigs != NULL);\n+    ARG_CHECK(n_sigs > 0);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+    for (i = 0; i < n_sigs; i++) {\n+        secp256k1_scalar term;\n+        if (!secp256k1_musig_partial_sig_load(ctx, &term, partial_sigs[i])) {\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &term);",
      "path": "src/modules/musig/session_impl.h",
      "position": 808,
      "original_position": 796,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1652109381,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We've already done the `g*tacc` computation in tweak_add and `e*g*tacc` in nonce_process.",
      "created_at": "2024-07-10T13:50:55Z",
      "updated_at": "2024-07-10T14:06:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672307861",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672307861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 808,
      "original_line": 808,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672308169",
      "pull_request_review_id": 2169164172,
      "id": 1672308169,
      "node_id": "PRRC_kwDOAP4Jqs5jrWXJ",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 12,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1652542038,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-10T13:51:06Z",
      "updated_at": "2024-07-10T13:51:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672308169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672308169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672308791",
      "pull_request_review_id": 2169165094,
      "id": 1672308791,
      "node_id": "PRRC_kwDOAP4Jqs5jrWg3",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 278,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1655153854,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a memcmp. I don't think parsing the scalar is necessary because if properly initialized (which we ensure by checking the magic), the scalar cannot overflow. `_musig_{pub,agg}nonce_serialize` call load because they are required to do more work.",
      "created_at": "2024-07-10T13:51:27Z",
      "updated_at": "2024-07-10T13:51:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672308791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672308791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 272,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309046",
      "pull_request_review_id": 2169165538,
      "id": 1672309046,
      "node_id": "PRRC_kwDOAP4Jqs5jrWk2",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": 238,
      "original_position": 240,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1655213103,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep, fixed",
      "created_at": "2024-07-10T13:51:35Z",
      "updated_at": "2024-07-10T13:51:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672309046",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309046"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 237,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": 238,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309205",
      "pull_request_review_id": 2169165847,
      "id": 1672309205,
      "node_id": "PRRC_kwDOAP4Jqs5jrWnV",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 244,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1655222415,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-10T13:51:42Z",
      "updated_at": "2024-07-10T13:51:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672309205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309356",
      "pull_request_review_id": 2169166169,
      "id": 1672309356,
      "node_id": "PRRC_kwDOAP4Jqs5jrWps",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 282,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1655226973,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-10T13:51:48Z",
      "updated_at": "2024-07-10T13:51:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672309356",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309548",
      "pull_request_review_id": 2169166549,
      "id": 1672309548,
      "node_id": "PRRC_kwDOAP4Jqs5jrWss",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 300,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1657472337,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2024-07-10T13:51:54Z",
      "updated_at": "2024-07-10T13:51:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672309548",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309765",
      "pull_request_review_id": 2169166913,
      "id": 1672309765,
      "node_id": "PRRC_kwDOAP4Jqs5jrWwF",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 485,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1657475037,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nice, done",
      "created_at": "2024-07-10T13:52:02Z",
      "updated_at": "2024-07-10T13:52:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672309765",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672309765"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 483,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310019",
      "pull_request_review_id": 2169167360,
      "id": 1672310019,
      "node_id": "PRRC_kwDOAP4Jqs5jrW0D",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 361,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1657483220,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, removed the comment",
      "created_at": "2024-07-10T13:52:10Z",
      "updated_at": "2024-07-10T13:52:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672310019",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310768",
      "pull_request_review_id": 2169168765,
      "id": 1672310768,
      "node_id": "PRRC_kwDOAP4Jqs5jrW_w",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 613,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1659076501,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Cool, implemented your suggestion.",
      "created_at": "2024-07-10T13:52:38Z",
      "updated_at": "2024-07-10T13:52:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672310768",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 610,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310933",
      "pull_request_review_id": 2169169098,
      "id": 1672310933,
      "node_id": "PRRC_kwDOAP4Jqs5jrXCV",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 627,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1659078837,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, done",
      "created_at": "2024-07-10T13:52:44Z",
      "updated_at": "2024-07-10T13:52:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672310933",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672310933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 627,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672311794",
      "pull_request_review_id": 2169170784,
      "id": 1672311794,
      "node_id": "PRRC_kwDOAP4Jqs5jrXPy",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    /* Subtract one from `sizeof` to avoid hashing the implicit null byte */\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+    }\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK((seckey != NULL));\n+\n+    for (i = 0; i < 8; ++i) {\n+        buf[7 - i] = (nonrepeating_cnt >> (i * 8)) & 0xFF;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_gej *aggnoncej, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_ge aggnonce[2];\n+\n+    secp256k1_ge_set_gej(&aggnonce[0], &aggnoncej[0]);\n+    secp256k1_ge_set_gej(&aggnonce[1], &aggnoncej[1]);\n+    if (!secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg)) {\n+        return 0;\n+    }\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    secp256k1_gej aggnonce_ptj[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&aggnonce_ptj[0], &aggnonce_pt[0]);\n+    secp256k1_gej_set_ge(&aggnonce_ptj[1], &aggnonce_pt[1]);\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_ptj, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        secp256k1_scalar_add(&session_i.s_part, &session_i.s_part, &e_tmp);\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.y);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 677,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1659104375,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed both calls to fe_normalize",
      "created_at": "2024-07-10T13:53:12Z",
      "updated_at": "2024-07-10T13:53:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672311794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672311794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672312152",
      "pull_request_review_id": 2169171431,
      "id": 1672312152,
      "node_id": "PRRC_kwDOAP4Jqs5jrXVY",
      "diff_hunk": "@@ -0,0 +1,803 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": 367,
      "original_position": 359,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1660173809,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2024-07-10T13:53:20Z",
      "updated_at": "2024-07-10T13:53:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672312152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672312152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 365,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": 367,
      "original_line": 367,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672312789",
      "pull_request_review_id": 2169172656,
      "id": 1672312789,
      "node_id": "PRRC_kwDOAP4Jqs5jrXfV",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity and cache_i->second_pk_x to be normalized. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes both field elements x and second_pk_x are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 185,
      "original_position": 187,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1656647479,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The SECP256K1_ARG_NONNULL attribute relies on a GNU extension that can give a warning at compile time. A failing ARG_CHECK will call the illegal_callback at runtime. They complement each other.",
      "created_at": "2024-07-10T13:53:35Z",
      "updated_at": "2024-07-10T13:53:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672312789",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672312789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 185,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313116",
      "pull_request_review_id": 2169173237,
      "id": 1672313116,
      "node_id": "PRRC_kwDOAP4Jqs5jrXkc",
      "diff_hunk": "@@ -0,0 +1,1104 @@\n+/***********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    secp256k1_testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            secp256k1_testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = secp256k1_testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        secp256k1_testrand256(session_secrand[i]);\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 233,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1656757258,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, removed",
      "created_at": "2024-07-10T13:53:43Z",
      "updated_at": "2024-07-10T13:53:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672313116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313623",
      "pull_request_review_id": 2169174151,
      "id": 1672313623,
      "node_id": "PRRC_kwDOAP4Jqs5jrXsX",
      "diff_hunk": "@@ -0,0 +1,1104 @@\n+/***********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    secp256k1_testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            secp256k1_testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = secp256k1_testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        secp256k1_testrand256(session_secrand[i]);\n+        secp256k1_testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand, sk and pubkey can be NULL */",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 297,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1656982350,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-10T13:53:55Z",
      "updated_at": "2024-07-10T13:53:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672313623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313875",
      "pull_request_review_id": 2169174568,
      "id": 1672313875,
      "node_id": "PRRC_kwDOAP4Jqs5jrXwT",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, agg_pk)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 430,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1656985079,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nonrepeating_cnt isn't a pointer, so it cannot be NULL.",
      "created_at": "2024-07-10T13:54:00Z",
      "updated_at": "2024-07-10T13:54:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672313875",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672313875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672316065",
      "pull_request_review_id": 2169178249,
      "id": 1672316065,
      "node_id": "PRRC_kwDOAP4Jqs5jrYSh",
      "diff_hunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Automatically generated by tools/test_vectors_musig2_generate.py.\n+ *\n+ * The test vectors for the KeySort function are included in this file. They can\n+ * be found in src/modules/extrakeys/tests_impl.h. */\n+\n+enum MUSIG_ERROR {\n+    MUSIG_PUBKEY,\n+    MUSIG_TWEAK,\n+    MUSIG_PUBNONCE,\n+    MUSIG_AGGNONCE,\n+    MUSIG_SECNONCE,\n+    MUSIG_SIG,\n+    MUSIG_SIG_VERIFY,\n+    MUSIG_OTHER\n+};\n+\n+struct musig_key_agg_valid_test_case {\n+    size_t key_indices_len;\n+    size_t key_indices[4];\n+    unsigned char expected[32];\n+};\n+\n+struct musig_key_agg_error_test_case {\n+    size_t key_indices_len;\n+    size_t key_indices[4];\n+    size_t tweak_indices_len;\n+    size_t tweak_indices[1];\n+    int is_xonly[1];\n+    enum MUSIG_ERROR error;\n+};\n+\n+struct musig_key_agg_vector {\n+    unsigned char pubkeys[7][33];\n+    unsigned char tweaks[2][32];\n+    struct musig_key_agg_valid_test_case valid_case[4];\n+    struct musig_key_agg_error_test_case error_case[5];\n+};\n+\n+static const struct musig_key_agg_vector musig_key_agg_vector = {\n+    {\n+        { 0x02, 0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10, 0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29, 0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0, 0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9 },\n+        { 0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C, 0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41, 0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE, 0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6, 0x59 },\n+        { 0x02, 0x35, 0x90, 0xA9, 0x4E, 0x76, 0x8F, 0x8E, 0x18, 0x15, 0xC2, 0xF2, 0x4B, 0x4D, 0x80, 0xA8, 0xE3, 0x14, 0x93, 0x16, 0xC3, 0x51, 0x8C, 0xE7, 0xB7, 0xAD, 0x33, 0x83, 0x68, 0xD0, 0x38, 0xCA, 0x66 },\n+        { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05 },\n+        { 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30 },\n+        { 0x04, 0xF9, 0x30, 0x8A, 0x01, 0x92, 0x58, 0xC3, 0x10, 0x49, 0x34, 0x4F, 0x85, 0xF8, 0x9D, 0x52, 0x29, 0xB5, 0x31, 0xC8, 0x45, 0x83, 0x6F, 0x99, 0xB0, 0x86, 0x01, 0xF1, 0x13, 0xBC, 0xE0, 0x36, 0xF9 },\n+        { 0x03, 0x93, 0x5F, 0x97, 0x2D, 0xA0, 0x13, 0xF8, 0x0A, 0xE0, 0x11, 0x89, 0x0F, 0xA8, 0x9B, 0x67, 0xA2, 0x7B, 0x7B, 0xE6, 0xCC, 0xB2, 0x4D, 0x32, 0x74, 0xD1, 0x8B, 0x2D, 0x40, 0x67, 0xF2, 0x61, 0xA9 }\n+    },\n+    {\n+        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41 },\n+        { 0x25, 0x2E, 0x4B, 0xD6, 0x74, 0x10, 0xA7, 0x6C, 0xDF, 0x93, 0x3D, 0x30, 0xEA, 0xA1, 0x60, 0x82, 0x14, 0x03, 0x7F, 0x1B, 0x10, 0x5A, 0x01, 0x3E, 0xCC, 0xD3, 0xC5, 0xC1, 0x84, 0xA6, 0x11, 0x0B }\n+    },\n+    {\n+        {  3, { 0, 1, 2 }, { 0x90, 0x53, 0x9E, 0xED, 0xE5, 0x65, 0xF5, 0xD0, 0x54, 0xF3, 0x2C, 0xC0, 0xC2, 0x20, 0x12, 0x68, 0x89, 0xED, 0x1E, 0x5D, 0x19, 0x3B, 0xAF, 0x15, 0xAE, 0xF3, 0x44, 0xFE, 0x59, 0xD4, 0x61, 0x0C }},\n+        {  3, { 2, 1, 0 }, { 0x62, 0x04, 0xDE, 0x8B, 0x08, 0x34, 0x26, 0xDC, 0x6E, 0xAF, 0x95, 0x02, 0xD2, 0x70, 0x24, 0xD5, 0x3F, 0xC8, 0x26, 0xBF, 0x7D, 0x20, 0x12, 0x14, 0x8A, 0x05, 0x75, 0x43, 0x5D, 0xF5, 0x4B, 0x2B }},\n+        {  3, { 0, 0, 0 }, { 0xB4, 0x36, 0xE3, 0xBA, 0xD6, 0x2B, 0x8C, 0xD4, 0x09, 0x96, 0x9A, 0x22, 0x47, 0x31, 0xC1, 0x93, 0xD0, 0x51, 0x16, 0x2D, 0x8C, 0x5A, 0xE8, 0xB1, 0x09, 0x30, 0x61, 0x27, 0xDA, 0x3A, 0xA9, 0x35 }},\n+        {  4, { 0, 0, 1, 1 }, { 0x69, 0xBC, 0x22, 0xBF, 0xA5, 0xD1, 0x06, 0x30, 0x6E, 0x48, 0xA2, 0x06, 0x79, 0xDE, 0x1D, 0x73, 0x89, 0x38, 0x61, 0x24, 0xD0, 0x75, 0x71, 0xD0, 0xD8, 0x72, 0x68, 0x60, 0x28, 0xC2, 0x6A, 0x3E }},\n+    },\n+    {\n+        {  2, { 0, 3 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 0, 4 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 5, 0 },  0, { 0 }, { 0 }, MUSIG_PUBKEY },\n+        {  2, { 0, 1 },  1, { 0 }, { 1 }, MUSIG_TWEAK },\n+        {  1, { 6 },  1, { 1 }, { 0 }, MUSIG_TWEAK },\n+    },\n+};\n+\n+struct musig_nonce_gen_test_case {\n+    unsigned char rand_[32];\n+    int has_sk;\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    int has_aggpk;\n+    unsigned char aggpk[32];\n+    int has_msg;\n+    unsigned char msg[32];\n+    int has_extra_in;\n+    unsigned char extra_in[32];\n+    unsigned char expected_secnonce[97];",
      "path": "src/modules/musig/vectors.h",
      "position": 80,
      "original_position": 80,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1660520958,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm the test vector is 97 bytes though. I changed the test to check that last 33 bytes of expected_secnonce as well, to make sure it's really the public key as expected.",
      "created_at": "2024-07-10T13:54:52Z",
      "updated_at": "2024-07-10T13:54:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1672316065",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1672316065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 80,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673595483",
      "pull_request_review_id": 2171216906,
      "id": 1673595483,
      "node_id": "PRRC_kwDOAP4Jqs5jwQpb",
      "diff_hunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Automatically generated by ./contrib/musig2-vectors.py.",
      "path": "src/modules/musig/vectors.h",
      "position": null,
      "original_position": 2,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this was lost in some rebase. \r\n\r\n```suggestion\r\n * Automatically generated by tools/test_vectors_musig2_generate_.py.\r\n```\r\n\r\nAnd just remove `contrib/musig2-vectors.py`, the PR currently adds the (identical) script to both paths.  ",
      "created_at": "2024-07-11T08:11:12Z",
      "updated_at": "2024-07-11T08:25:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673595483",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673595483"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673600526",
      "pull_request_review_id": 2171216906,
      "id": 1673600526,
      "node_id": "PRRC_kwDOAP4Jqs5jwR4O",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+# API misuse",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n\r\n```suggestion\r\n## API misuse\r\n```\r\n\r\n(also for all other headings below)\r\n\r\n`#` is the same level as the heading for the entire document, see the rendered file.\r\n",
      "created_at": "2024-07-11T08:15:09Z",
      "updated_at": "2024-07-11T08:25:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673600526",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673600526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673612214",
      "pull_request_review_id": 2171216906,
      "id": 1673612214,
      "node_id": "PRRC_kwDOAP4Jqs5jwUu2",
      "diff_hunk": "@@ -0,0 +1,218 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 2,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": " (Okay, I'm all in favor of not doing updating years and stuff, but this is just too wrong. :D) \r\n```suggestion\r\n * Written by Jonas Nick                                                 *\r\n```\r\n",
      "created_at": "2024-07-11T08:23:35Z",
      "updated_at": "2024-07-11T08:25:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673612214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673612214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673661752",
      "pull_request_review_id": 2171321839,
      "id": 1673661752,
      "node_id": "PRRC_kwDOAP4Jqs5jwg04",
      "diff_hunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Automatically generated by ./contrib/musig2-vectors.py.",
      "path": "src/modules/musig/vectors.h",
      "position": null,
      "original_position": 2,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": 1673595483,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not a rebase issue, just confusion: I had thought that I had forgotten to add the python script because it's called differently in -zkp.",
      "created_at": "2024-07-11T08:58:35Z",
      "updated_at": "2024-07-11T08:58:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673661752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673661752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673703347",
      "pull_request_review_id": 2171387482,
      "id": 1673703347,
      "node_id": "PRRC_kwDOAP4Jqs5jwq-z",
      "diff_hunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Automatically generated by ./contrib/musig2-vectors.py.",
      "path": "src/modules/musig/vectors.h",
      "position": null,
      "original_position": 2,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": 1673595483,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-11T09:25:25Z",
      "updated_at": "2024-07-11T09:25:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673703347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673703347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673703887",
      "pull_request_review_id": 2171388100,
      "id": 1673703887,
      "node_id": "PRRC_kwDOAP4Jqs5jwrHP",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+# API misuse",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": 1673600526,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-11T09:25:37Z",
      "updated_at": "2024-07-11T09:25:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673703887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673703887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673704799",
      "pull_request_review_id": 2171389228,
      "id": 1673704799,
      "node_id": "PRRC_kwDOAP4Jqs5jwrVf",
      "diff_hunk": "@@ -0,0 +1,218 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 2,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "0dd333a919144b6563fd23ce80c5826aa8df7b8c",
      "in_reply_to_id": 1673612214,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed name and year from all headers",
      "created_at": "2024-07-11T09:26:00Z",
      "updated_at": "2024-07-11T09:26:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1673704799",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673704799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1682692703",
      "pull_request_review_id": 2185574313,
      "id": 1682692703,
      "node_id": "PRRC_kwDOAP4Jqs5kS9pf",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 70,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit\r\n```suggestion\r\n    /* Note that we did not provide an output_pk argument, because the\r\n     * resulting pk is also saved in the cache and so if one is just interested\r\n     * in signing, the output_pk argument is unnecessary. On the other hand, if\r\n```\r\n (for avoiding this to be read as \"signing the output_pk argument\")",
      "created_at": "2024-07-18T11:39:14Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1682692703",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1682692703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1682986299",
      "pull_request_review_id": 2185574313,
      "id": 1682986299,
      "node_id": "PRRC_kwDOAP4Jqs5kUFU7",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 243,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The aggregated `agg_pk` resulting from the `_musig_pubkey_agg` is an x-only public key, so it can't be used for the `_ec_pubkey_...` functions below. Seems like the earlier version, getting `agg_pk` from the `keyagg_cache` via `_musig_pubkey_get(...)`, was correct (sorry, it was me who proposed this \"simplification\" in https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1655213103 🤦‍♂️ ).\r\n```suggestion\r\n *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\r\n *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\r\n *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\r\n *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\r\n *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\r\n *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\r\n```",
      "created_at": "2024-07-18T14:47:24Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1682986299",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1682986299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683048888",
      "pull_request_review_id": 2185574313,
      "id": 1683048888,
      "node_id": "PRRC_kwDOAP4Jqs5kUUm4",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    fflush(stdout);\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 188,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: the resulting `agg_pk` is not used here, as it's overwritten in the `tweak` call below (maybe it's also fine to keep passing it for demonstration purposes, I just thought it could cause confusion, in the sense that readers think this result is needed for the tweaking below, in addition to the `cache`)",
      "created_at": "2024-07-18T15:24:55Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1683048888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683048888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683051058",
      "pull_request_review_id": 2185574313,
      "id": 1683051058,
      "node_id": "PRRC_kwDOAP4Jqs5kUVIy",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    fflush(stdout);\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Tweaking................\");\n+    fflush(stdout);\n+    /* Optionally tweak the aggregate key */\n+    if (!tweak(ctx, &agg_pk, &cache)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Signing message.........\");\n+    fflush(stdout);\n+    if (!sign(ctx, signer_secrets, signers, &cache, msg, sig)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Verifying signature.....\");\n+    fflush(stdout);\n+    if (!secp256k1_schnorrsig_verify(ctx, sig, msg, 32, &agg_pk)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 217,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should the secrets be cleared out (here and in `sign`), like also done in other examples?",
      "created_at": "2024-07-18T15:26:21Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1683051058",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683051058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 214,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683110517",
      "pull_request_review_id": 2185574313,
      "id": 1683110517,
      "node_id": "PRRC_kwDOAP4Jqs5kUjp1",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 21,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, feel free to ignore:\r\n```suggestion\r\n    unsigned char pks_hash[32];\r\n```\r\nmaybe, to express that this is the hash of multiple pubkeys, not a single one?",
      "created_at": "2024-07-18T16:01:59Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1683110517",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683110517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683114230",
      "pull_request_review_id": 2185574313,
      "id": 1683114230,
      "node_id": "PRRC_kwDOAP4Jqs5kUkj2",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 114,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * otherwise tagged_hash(pk_hash, pk) where pk_hash is the hash of public keys.\r\n```",
      "created_at": "2024-07-18T16:03:36Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1683114230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683114230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683127333",
      "pull_request_review_id": 2185574313,
      "id": 1683127333,
      "node_id": "PRRC_kwDOAP4Jqs5kUnwl",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 231,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit\r\n```suggestion\r\n    if (agg_pk != NULL) {\r\n        secp256k1_extrakeys_ge_even_y(&pkp);\r\n        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\r\n    }\r\n```",
      "created_at": "2024-07-18T16:10:29Z",
      "updated_at": "2024-07-18T16:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1683127333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1683127333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 228,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686643591",
      "pull_request_review_id": 2191726645,
      "id": 1686643591,
      "node_id": "PRRC_kwDOAP4Jqs5kiCOH",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/pull/1479/commits/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nnit: spacing\r\n\r\n```suggestion\r\n/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\r\n  * Multi-Signatures\"\r\n  * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\r\n  * v1.0.0. You can find an example demonstrating the musig module in\r\n  * examples/musig.c.\r\n  *\r\n  * The module also supports BIP-341 (\"Taproot\") public key tweaking.\r\n  *\r\n  * It is recommended to read the documentation in this include file carefully.\r\n  * Further notes on API usage can be found in doc/musig.md\r\n  *\r\n  * Since the first version of MuSig is essentially replaced by MuSig2, we use\r\n  * MuSig, musig and MuSig2 synonymously unless noted otherwise.\r\n```\r\n",
      "created_at": "2024-07-22T14:23:57Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686643591",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686643591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686649285",
      "pull_request_review_id": 2191726645,
      "id": 1686649285,
      "node_id": "PRRC_kwDOAP4Jqs5kiDnF",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 53,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nSeems brittle to point to a blog for an important warning about the risks of using a struct in this library. What about copying the relevant parts from the blog into `doc/musig.md` and updating this link to point to the docs?",
      "created_at": "2024-07-22T14:27:19Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686649285",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686649285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686655906",
      "pull_request_review_id": 2191726645,
      "id": 1686655906,
      "node_id": "PRRC_kwDOAP4Jqs5kiFOi",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 161,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nmicro-nit: for all of the other function pairs, the order in the header is `parse, serialize`. This one switches the order, which is a bit ocd' triggering :sweat_smile: ",
      "created_at": "2024-07-22T14:31:32Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686655906",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686655906"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686672681",
      "pull_request_review_id": 2191726645,
      "id": 1686672681,
      "node_id": "PRRC_kwDOAP4Jqs5kiJUp",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 248,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nnit: this reads a bit like a suggestions, perhaps:\r\n\r\n```\r\n *  This function is required if you want to _sign_ for a tweaked aggregate key.\r\n *  If you are only computing a public key but not intending to create a signature \r\n *  for it, use `secp256k1_ec_pubkey_tweak_add` instead.\r\n```\r\n",
      "created_at": "2024-07-22T14:40:14Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686672681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686672681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686676981",
      "pull_request_review_id": 2191726645,
      "id": 1686676981,
      "node_id": "PRRC_kwDOAP4Jqs5kiKX1",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 288,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nnit: same as above:\r\n\r\n```suggestion\r\n *  This function is required if you want to _sign_ for a tweaked aggregate key.\r\n *  If you are only computing a public key but not intending to create a signature \r\n *  for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\r\n```\r\n",
      "created_at": "2024-07-22T14:42:50Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686676981",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686676981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 288,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686736246",
      "pull_request_review_id": 2191726645,
      "id": 1686736246,
      "node_id": "PRRC_kwDOAP4Jqs5kiY12",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 31,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nAny reason `*cache_i` isn't const? You'd need to also make the in params for both `_ge_to_bytes` and `_ge_to_bytes_ext` to be const, but seems like they should be unless I'm missing something.",
      "created_at": "2024-07-22T15:23:06Z",
      "updated_at": "2024-07-22T16:12:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686736246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686736246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686739620",
      "pull_request_review_id": 2191726645,
      "id": 1686739620,
      "node_id": "PRRC_kwDOAP4Jqs5kiZqk",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 41,
      "original_position": 41,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nNote to self/other reviewers: this initially tripped me up a bit as I expected something like `memcpy(ptr, &cache_i->parity_acc, 1);` but after some googling, apparently this is the more idiomatic/performant way of doing this!",
      "created_at": "2024-07-22T15:25:29Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686739620",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686739620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 41,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686743975",
      "pull_request_review_id": 2191726645,
      "id": 1686743975,
      "node_id": "PRRC_kwDOAP4Jqs5kiaun",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nnit: slightly more readable if `pk` is plural:\r\n\r\n```suggestion\r\nstatic int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pks, size_t n_pks) {\r\n```\r\n\r\n",
      "created_at": "2024-07-22T15:28:30Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686743975",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686743975"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686752958",
      "pull_request_review_id": 2191726645,
      "id": 1686752958,
      "node_id": "PRRC_kwDOAP4Jqs5kic6-",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 86,
      "original_position": 86,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nCould move this outside the loop to make this slightly more performant and, imo, more readable. Not sure the performance matters but could make a difference if computing `pk_hash` for a large number of keys?",
      "created_at": "2024-07-22T15:35:06Z",
      "updated_at": "2024-07-22T15:43:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686752958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686752958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 85,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686757959",
      "pull_request_review_id": 2191726645,
      "id": 1686757959,
      "node_id": "PRRC_kwDOAP4Jqs5kieJH",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 125,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nNot sure how important this check is , but I noticed this branch is not covered while checking `gcov` results. IIUC, the test case to add would be for pk and second_pk to have the same x value  but even and odd y values.",
      "created_at": "2024-07-22T15:38:51Z",
      "updated_at": "2024-07-22T16:13:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686757959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686757959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686765744",
      "pull_request_review_id": 2191933682,
      "id": 1686765744,
      "node_id": "PRRC_kwDOAP4Jqs5kigCw",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 31,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686736246,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FWIW, I changed these functions to `const` and was able to compile and run the tests.",
      "created_at": "2024-07-22T15:44:21Z",
      "updated_at": "2024-07-22T15:44:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1686765744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1686765744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687795506",
      "pull_request_review_id": 2193548751,
      "id": 1687795506,
      "node_id": "PRRC_kwDOAP4Jqs5kmbcy",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 46,
      "original_position": 46,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nNote to self/reviewers: wasn't obvious to me how ctx was being used at first but it's being used in the `ARG_CHECK` macro.",
      "created_at": "2024-07-23T10:07:27Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687795506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687795506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 46,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687810664",
      "pull_request_review_id": 2193548751,
      "id": 1687810664,
      "node_id": "PRRC_kwDOAP4Jqs5kmfJo",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;",
      "path": "src/modules/musig/session_impl.h",
      "position": 47,
      "original_position": 47,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nFeels like I'm missing some context here. Generally, I'd expect setting the group element to the point at infinity to be a failure (i.e., expect the function to `return 0;`). But here it seems to be perfectly acceptable? My guess is that this failure mode is handled later on in a different function? It might be worth add some context in the comment for why this function is returning true, despite returning the point at infinity in the output param ",
      "created_at": "2024-07-23T10:19:23Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687810664",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687810664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 40,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687814210",
      "pull_request_review_id": 2193548751,
      "id": 1687814210,
      "node_id": "PRRC_kwDOAP4Jqs5kmgBC",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 54,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\n```suggestion\r\nstatic void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\r\n```",
      "created_at": "2024-07-23T10:22:17Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687814210",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687814210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687816959",
      "pull_request_review_id": 2193548751,
      "id": 1687816959,
      "node_id": "PRRC_kwDOAP4Jqs5kmgr_",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 61,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\n```suggestion\r\nstatic int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\r\n```",
      "created_at": "2024-07-23T10:24:38Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687816959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687816959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687822590",
      "pull_request_review_id": 2193548751,
      "id": 1687822590,
      "node_id": "PRRC_kwDOAP4Jqs5kmiD-",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 46,
      "original_position": 46,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687795506,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "On second thought, seems a bit strange to be using `ARG_CHECK` inside an internal function (i.e., not exposed in the musig module API). Why not do an assert or a return here, which would let you simplify the function by removing `ctx` from the function signature?",
      "created_at": "2024-07-23T10:29:22Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687822590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687822590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 46,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687825340",
      "pull_request_review_id": 2193548751,
      "id": 1687825340,
      "node_id": "PRRC_kwDOAP4Jqs5kmiu8",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(agg_pk, &cache_i.pk);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_pubkey_tweak_add_internal(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32, int xonly) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    int overflow = 0;\n+    secp256k1_scalar tweak;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (output_pubkey != NULL) {\n+        memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    }\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(tweak32 != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 257,
      "original_position": 259,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nGenerally speaking, seems like the `ARG_CHECKS` should be happening in the public facing functions, not internal functions? i.e., doing a runtime check inside a function an external caller doesn't have access to seems a bit strange to me.",
      "created_at": "2024-07-23T10:31:37Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687825340",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687825340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 256,
      "original_start_line": 258,
      "start_side": "RIGHT",
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687826683",
      "pull_request_review_id": 2193548751,
      "id": 1687826683,
      "node_id": "PRRC_kwDOAP4Jqs5kmjD7",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(agg_pk, &cache_i.pk);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_pubkey_tweak_add_internal(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32, int xonly) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    int overflow = 0;\n+    secp256k1_scalar tweak;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (output_pubkey != NULL) {\n+        memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    }\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&tweak, tweak32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    if (xonly && secp256k1_extrakeys_ge_even_y(&cache_i.pk)) {\n+        cache_i.parity_acc ^= 1;\n+        secp256k1_scalar_negate(&cache_i.tweak, &cache_i.tweak);\n+    }\n+    secp256k1_scalar_add(&cache_i.tweak, &cache_i.tweak, &tweak);\n+    if (!secp256k1_eckey_pubkey_tweak_add(&cache_i.pk, &tweak)) {\n+        return 0;\n+    }\n+    /* eckey_pubkey_tweak_add fails if cache_i.pk is infinity */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&cache_i.pk));\n+    secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    if (output_pubkey != NULL) {\n+        secp256k1_pubkey_save(output_pubkey, &cache_i.pk);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_ec_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32) {\n+    return secp256k1_musig_pubkey_tweak_add_internal(ctx, output_pubkey, keyagg_cache, tweak32, 0);\n+}\n+\n+int secp256k1_musig_pubkey_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 287,
      "original_position": 289,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nper my comment above, this is where I'd expect the `ARG_CHECKS` to happen, vs inside the internal function",
      "created_at": "2024-07-23T10:32:42Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687826683",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687826683"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 287,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687831314",
      "pull_request_review_id": 2193548751,
      "id": 1687831314,
      "node_id": "PRRC_kwDOAP4Jqs5kmkMS",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);",
      "path": "src/modules/musig/session_impl.h",
      "position": 66,
      "original_position": 63,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/commit/f8f4f3c7a10345295ed72cdae0faecff37a919e5:\r\n\r\nThis function could be simplified to return `void` if the `ARG_CHECK` were moved outside the function (seems like we could safely check these conditions before calling `_load`?)",
      "created_at": "2024-07-23T10:36:35Z",
      "updated_at": "2024-07-23T10:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1687831314",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1687831314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689493845",
      "pull_request_review_id": 2196193665,
      "id": 1689493845,
      "node_id": "PRRC_kwDOAP4Jqs5ks6FV",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 70,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1682692703,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-24T09:59:30Z",
      "updated_at": "2024-07-24T09:59:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689493845",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689493845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689494255",
      "pull_request_review_id": 2196194245,
      "id": 1689494255,
      "node_id": "PRRC_kwDOAP4Jqs5ks6Lv",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 243,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1682986299,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oops I missed that too, fixed.",
      "created_at": "2024-07-24T09:59:46Z",
      "updated_at": "2024-07-24T09:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689494255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689494255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689494887",
      "pull_request_review_id": 2196195254,
      "id": 1689494887,
      "node_id": "PRRC_kwDOAP4Jqs5ks6Vn",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    fflush(stdout);\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 188,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1683048888,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Set agg_pk argument to NULL and improved comment.",
      "created_at": "2024-07-24T10:00:13Z",
      "updated_at": "2024-07-24T10:00:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689494887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689494887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495300",
      "pull_request_review_id": 2196195903,
      "id": 1689495300,
      "node_id": "PRRC_kwDOAP4Jqs5ks6cE",
      "diff_hunk": "@@ -0,0 +1,217 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");\n+    fflush(stdout);\n+    /* If you just want to aggregate and not sign the cache can be NULL */\n+    if (!secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pubkeys_ptr, N_SIGNERS)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Tweaking................\");\n+    fflush(stdout);\n+    /* Optionally tweak the aggregate key */\n+    if (!tweak(ctx, &agg_pk, &cache)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Signing message.........\");\n+    fflush(stdout);\n+    if (!sign(ctx, signer_secrets, signers, &cache, msg, sig)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Verifying signature.....\");\n+    fflush(stdout);\n+    if (!secp256k1_schnorrsig_verify(ctx, sig, msg, 32, &agg_pk)) {\n+        printf(\"FAILED\\n\");\n+        return 1;\n+    }\n+    printf(\"ok\\n\");\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 217,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1683051058,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, secrets should be cleared everywhere now.",
      "created_at": "2024-07-24T10:00:31Z",
      "updated_at": "2024-07-24T10:00:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689495300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 214,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495505",
      "pull_request_review_id": 2196196216,
      "id": 1689495505,
      "node_id": "PRRC_kwDOAP4Jqs5ks6fR",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pk_hash[32];",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 21,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1683110517,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-24T10:00:39Z",
      "updated_at": "2024-07-24T10:00:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689495505",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495649",
      "pull_request_review_id": 2196196450,
      "id": 1689495649,
      "node_id": "PRRC_kwDOAP4Jqs5ks6hh",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 114,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1683114230,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-24T10:00:47Z",
      "updated_at": "2024-07-24T10:00:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689495649",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495649"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495943",
      "pull_request_review_id": 2196196876,
      "id": 1689495943,
      "node_id": "PRRC_kwDOAP4Jqs5ks6mH",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 231,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1683127333,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-24T10:00:58Z",
      "updated_at": "2024-07-24T10:00:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689495943",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689495943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 228,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689496614",
      "pull_request_review_id": 2196197887,
      "id": 1689496614,
      "node_id": "PRRC_kwDOAP4Jqs5ks6wm",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686643591,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I improved this doc comment in a way that's consistent with the existing doc.",
      "created_at": "2024-07-24T10:01:25Z",
      "updated_at": "2024-07-24T10:01:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689496614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689496614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497094",
      "pull_request_review_id": 2196198792,
      "id": 1689497094,
      "node_id": "PRRC_kwDOAP4Jqs5ks64G",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 53,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686649285,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I re-read the post and I'm not sure what exactly we wanted to convey here. The link predates the BIP. I think just saying that copying the nonce can leak the secret key is clear enough. I removed the link.",
      "created_at": "2024-07-24T10:01:46Z",
      "updated_at": "2024-07-24T10:01:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689497094",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497094"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497278",
      "pull_request_review_id": 2196199201,
      "id": 1689497278,
      "node_id": "PRRC_kwDOAP4Jqs5ks66-",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 161,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686655906,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Let's minimize the triggers where reasonable ;P Changed.",
      "created_at": "2024-07-24T10:01:55Z",
      "updated_at": "2024-07-24T10:01:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689497278",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497444",
      "pull_request_review_id": 2196199493,
      "id": 1689497444,
      "node_id": "PRRC_kwDOAP4Jqs5ks69k",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 248,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686672681,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-24T10:02:02Z",
      "updated_at": "2024-07-24T10:02:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689497444",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497633",
      "pull_request_review_id": 2196199868,
      "id": 1689497633,
      "node_id": "PRRC_kwDOAP4Jqs5ks7Ah",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ * Multi-Signatures\"\n+ * (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ * v1.0.0. You can find an example demonstrating the musig module in\n+ * examples/musig.c.\n+ *\n+ * The module also supports BIP-341 (\"Taproot\") public key tweaking.\n+ *\n+ * It is recommended to read the documentation in this include file carefully.\n+ * Further notes on API usage can be found in doc/musig.md\n+ *\n+ * Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ * MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow. See\n+ *  https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/ for\n+ *  more details about the risks associated with serializing or deserializing\n+ *  this structure.\n+ *\n+ *  We repeat, copying this data structure can result in nonce reuse which will\n+ *  leak the secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+*\n+*  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+*  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+*/\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by\n+ *  adding the generator multiplied with `tweak32` to it. This is useful for\n+ *  deriving child keys from an aggregate public key via BIP32.\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_ec_pubkey_tweak_add`.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs.\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  On the other hand, if you are only computing a public key, but not intending\n+ *  to create a signature for it, you can just use\n+ *  `secp256k1_xonly_pubkey_tweak_add`.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 288,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686676981,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-24T10:02:11Z",
      "updated_at": "2024-07-24T10:02:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689497633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689497633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 288,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498081",
      "pull_request_review_id": 2196200749,
      "id": 1689498081,
      "node_id": "PRRC_kwDOAP4Jqs5ks7Hh",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 31,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686736246,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, fixed.",
      "created_at": "2024-07-24T10:02:31Z",
      "updated_at": "2024-07-24T10:02:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689498081",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498318",
      "pull_request_review_id": 2196201182,
      "id": 1689498318,
      "node_id": "PRRC_kwDOAP4Jqs5ks7LO",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686743975,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-07-24T10:02:40Z",
      "updated_at": "2024-07-24T10:02:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689498318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498777",
      "pull_request_review_id": 2196201908,
      "id": 1689498777,
      "node_id": "PRRC_kwDOAP4Jqs5ks7SZ",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 86,
      "original_position": 86,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686752958,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think that would be less readable than declaring the variables only in the block where they are needed. The compiler will almost certainly optimize the current version to not cause any overhead.",
      "created_at": "2024-07-24T10:02:53Z",
      "updated_at": "2024-07-24T10:02:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689498777",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689498777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 85,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689499909",
      "pull_request_review_id": 2196203085,
      "id": 1689499909,
      "node_id": "PRRC_kwDOAP4Jqs5ks7kF",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 125,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "f8f4f3c7a10345295ed72cdae0faecff37a919e5",
      "in_reply_to_id": 1686757959,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch! We want everything covered by gcov. I replaced this with `ge_equals_ge_var` which was added after I wrote this code.",
      "created_at": "2024-07-24T10:03:09Z",
      "updated_at": "2024-07-24T10:03:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689499909",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689499909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689500985",
      "pull_request_review_id": 2196204487,
      "id": 1689500985,
      "node_id": "PRRC_kwDOAP4Jqs5ks705",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;",
      "path": "src/modules/musig/session_impl.h",
      "position": 47,
      "original_position": 47,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687810664,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The point of the `serialize_ext` and `parse_ext` functions is to be able to serialize and parse the point at infinity. So this is not a failure case. This is noted in the doc of the function:\r\n\r\n```\r\n/* Outputs the point at infinity if the given byte array is all zero, otherwise\r\n * attempts to parse compressed point serialization. */\r\n```",
      "created_at": "2024-07-24T10:03:34Z",
      "updated_at": "2024-07-24T10:03:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689500985",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689500985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 40,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689501633",
      "pull_request_review_id": 2196205405,
      "id": 1689501633,
      "node_id": "PRRC_kwDOAP4Jqs5ks7_B",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 54,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687814210,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed (also in a few other places in session_impl.h)",
      "created_at": "2024-07-24T10:04:00Z",
      "updated_at": "2024-07-24T10:04:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689501633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689501633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689501809",
      "pull_request_review_id": 2196205724,
      "id": 1689501809,
      "node_id": "PRRC_kwDOAP4Jqs5ks8Bx",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, secp256k1_musig_secnonce *secnonce) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 61,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687816959,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-24T10:04:08Z",
      "updated_at": "2024-07-24T10:04:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689501809",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689501809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689502047",
      "pull_request_review_id": 2196206142,
      "id": 1689502047,
      "node_id": "PRRC_kwDOAP4Jqs5ks8Ff",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(agg_pk, &cache_i.pk);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_pubkey_tweak_add_internal(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32, int xonly) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    int overflow = 0;\n+    secp256k1_scalar tweak;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (output_pubkey != NULL) {\n+        memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    }\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(tweak32 != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 257,
      "original_position": 259,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687825340,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "At the cost of code duplication?",
      "created_at": "2024-07-24T10:04:20Z",
      "updated_at": "2024-07-24T10:04:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1689502047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1689502047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 256,
      "original_start_line": 258,
      "start_side": "RIGHT",
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1690914267",
      "pull_request_review_id": 2198463271,
      "id": 1690914267,
      "node_id": "PRRC_kwDOAP4Jqs5kyU3b",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(agg_pk, &cache_i.pk);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_pubkey_tweak_add_internal(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32, int xonly) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    int overflow = 0;\n+    secp256k1_scalar tweak;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (output_pubkey != NULL) {\n+        memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    }\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(tweak32 != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 257,
      "original_position": 259,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687825340,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In this case, I think it helps with the clarity to have the arg checking happen in the public function _before_ calling the internal function (even at the cost of code duplication). \r\n\r\nThat being said, this is really just a style nit so feel free to resolve this discussion if you prefer the (current) more concise version.",
      "created_at": "2024-07-25T06:58:10Z",
      "updated_at": "2024-07-25T06:58:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1690914267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1690914267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 256,
      "original_start_line": 258,
      "start_side": "RIGHT",
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1690985929",
      "pull_request_review_id": 2198554629,
      "id": 1690985929,
      "node_id": "PRRC_kwDOAP4Jqs5kymXJ",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }",
      "path": "examples/musig.c",
      "position": 45,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `while` is unnecessary here (see https://github.com/bitcoin-core/secp256k1/issues/1570)",
      "created_at": "2024-07-25T07:38:10Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1690985929",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1690985929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 41,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691021595",
      "pull_request_review_id": 2198554629,
      "id": 1691021595,
      "node_id": "PRRC_kwDOAP4Jqs5kyvEb",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 62,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It might be worth including a warning in the example (or even the API docs) that the tweak functions take generic tweaks and it is the caller's responsibility to make sure these tweaks are safely and correctly computed, e.g., according to the BIP341 spec in the case of a taproot commitment.\r\n\r\nWhen reviewing the `musig_pubkey_tweak_add_internal` function, I was a bit surprised when I _didn't_ see taptweak logic in the function because I had seen \"taproot commitment\", \"tap tweak\" mentioned a few times in the API docs/examples. Obviously, it makes sense that this would be a generic tweak32 and we wouldn't want the musig2 module to be implementing logic from other protocols, but I could also see a naive caller passing `h` to `_xonly_tweak_add`, assuming it will be computing `H_TapTweak(P || h)`under the hood.",
      "created_at": "2024-07-25T08:05:33Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691021595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691021595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691029326",
      "pull_request_review_id": 2198554629,
      "id": 1691029326,
      "node_id": "PRRC_kwDOAP4Jqs5kyw9O",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing, the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+\n+        secure_erase(seckey, sizeof(seckey));\n+        secure_erase(session_secrand, sizeof(session_secrand));\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }",
      "path": "examples/musig.c",
      "position": 151,
      "original_position": 144,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: perhaps worth having an assert that `secnonce` is 0 to drive the point home?",
      "created_at": "2024-07-25T08:11:18Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691029326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691029326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 145,
      "original_start_line": 138,
      "start_side": "RIGHT",
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691033453",
      "pull_request_review_id": 2198554629,
      "id": 1691033453,
      "node_id": "PRRC_kwDOAP4Jqs5kyx9t",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 212,
      "original_position": 186,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1477961061,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think it would be nice to including sorting in the example for the following reasons:\r\n\r\n* It provides a practical example on how to use the sorting API\r\n* It's a good hook for adding a comment explaining what @real-or-random just explained above. Feels a bit nicer to have that comment in the example, vs the API docs ",
      "created_at": "2024-07-25T08:14:28Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691033453",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691033453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691069451",
      "pull_request_review_id": 2198554629,
      "id": 1691069451,
      "node_id": "PRRC_kwDOAP4Jqs5ky6wL",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing, the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+\n+        secure_erase(seckey, sizeof(seckey));\n+        secure_erase(session_secrand, sizeof(session_secrand));\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 168,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: spacing\r\n\r\n```suggestion\r\nint main(void) {\r\n```",
      "created_at": "2024-07-25T08:40:34Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691069451",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691069451"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691071921",
      "pull_request_review_id": 2198554629,
      "id": 1691071921,
      "node_id": "PRRC_kwDOAP4Jqs5ky7Wx",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 20,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: ordering, add `secp256k1_extrakeys.h`since keypair is used\r\n\r\n```suggestion\r\n#include <secp256k1.h>\r\n#include <secp256k1_extrakeys.h\r\n#include <secp256k1_musig.h>\r\n#include <secp256k1_schnorrsig.h>\r\n```",
      "created_at": "2024-07-25T08:42:14Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691071921",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691071921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 18,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691151560",
      "pull_request_review_id": 2198554629,
      "id": 1691151560,
      "node_id": "PRRC_kwDOAP4Jqs5kzOzI",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3",
      "path": "examples/musig.c",
      "position": 37,
      "original_position": 37,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651017476,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I replaced the stack allocations with heap allocations here: https://github.com/josibake/secp256k1/commit/35ac3b194aefc064e8cee94e93498be224cc0d69\r\n\r\nand ran the example with 100,000 signers. Everything up until signing was very fast, whereas signing took 45 mins (ran on a relatively powerful machine). Worth mentioning the time is a somewhat useless number here and the goal was more to stress test. The sign function in the example does both rounds of communication in the same function and the partial signing is done sequentially, whereas in reality the partial signing would be done in parallel",
      "created_at": "2024-07-25T09:38:40Z",
      "updated_at": "2024-07-25T09:40:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691151560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691151560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 36,
      "original_start_line": 36,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691997614",
      "pull_request_review_id": 2200159925,
      "id": 1691997614,
      "node_id": "PRRC_kwDOAP4Jqs5k2dWu",
      "diff_hunk": "@@ -0,0 +1,293 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pk_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pk_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pk_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pk_hash(const secp256k1_context *ctx, unsigned char *pk_hash, const secp256k1_pubkey * const* pk, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pk_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pk_hash, x) where pk_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pk_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_fe_equal(&pk->x, &second_pk->x)\n+          && secp256k1_fe_is_odd(&pk->y) == secp256k1_fe_is_odd(&second_pk->y)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pk_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pk_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pk_hash is the hash of the public keys */\n+    unsigned char pk_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pk_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pk_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pk_hash(ctx, ecmult_data.pk_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pk_hash, ecmult_data.pk_hash, sizeof(cache_i.pk_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    secp256k1_extrakeys_ge_even_y(&pkp);\n+    if (agg_pk != NULL) {\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(agg_pk, &cache_i.pk);\n+    return 1;\n+}\n+\n+static int secp256k1_musig_pubkey_tweak_add_internal(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32, int xonly) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    int overflow = 0;\n+    secp256k1_scalar tweak;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (output_pubkey != NULL) {\n+        memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    }\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(tweak32 != NULL);",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 257,
      "original_position": 259,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "8703fe48070eb01cf7123b733ecf628da81b3fbb",
      "in_reply_to_id": 1687825340,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I tried this suggestion and I prefer the more concise version.",
      "created_at": "2024-07-25T19:07:42Z",
      "updated_at": "2024-07-25T19:07:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1691997614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1691997614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 256,
      "original_start_line": 258,
      "start_side": "RIGHT",
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692034272",
      "pull_request_review_id": 2200269951,
      "id": 1692034272,
      "node_id": "PRRC_kwDOAP4Jqs5k2mTg",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }",
      "path": "examples/musig.c",
      "position": 45,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": 1690985929,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Let's keep it consistent for now with the other examples.",
      "created_at": "2024-07-25T19:45:52Z",
      "updated_at": "2024-07-25T19:45:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692034272",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692034272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 41,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692034683",
      "pull_request_review_id": 2200271413,
      "id": 1692034683,
      "node_id": "PRRC_kwDOAP4Jqs5k2mZ7",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing, the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+\n+        secure_erase(seckey, sizeof(seckey));\n+        secure_erase(session_secrand, sizeof(session_secrand));\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_secrand to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }",
      "path": "examples/musig.c",
      "position": 151,
      "original_position": 144,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": 1691029326,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, then people will copy the assert into their code...",
      "created_at": "2024-07-25T19:46:19Z",
      "updated_at": "2024-07-25T19:46:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692034683",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692034683"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 145,
      "original_start_line": 138,
      "start_side": "RIGHT",
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692038968",
      "pull_request_review_id": 2200285762,
      "id": 1692038968,
      "node_id": "PRRC_kwDOAP4Jqs5k2nc4",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3",
      "path": "examples/musig.c",
      "position": 37,
      "original_position": 37,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651017476,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was a quite confused at first that signing took 45 minutes on your machine, until I realized that all signers in the example effectively do the coordinator's job of aggregating nonces. I changed that to only aggregate nonces once. Entire example with 100,000 signers takes 12 seconds on my laptop now.",
      "created_at": "2024-07-25T19:50:37Z",
      "updated_at": "2024-07-25T19:50:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692038968",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692038968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 36,
      "original_start_line": 36,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692751551",
      "pull_request_review_id": 2201316767,
      "id": 1692751551,
      "node_id": "PRRC_kwDOAP4Jqs5k5Va_",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 1;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provided an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_id[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_id, sizeof(session_id))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_id, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+    }\n+    /* Communication round 1: A production system would exchange public nonces\n+     * here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        secp256k1_musig_aggnonce agg_pubnonce;\n+\n+        /* Create aggregate nonce and initialize the session */\n+        if (!secp256k1_musig_nonce_agg(ctx, &agg_pubnonce, pubnonces, N_SIGNERS)) {\n+            return 0;\n+        }\n+        if (!secp256k1_musig_nonce_process(ctx, &session, &agg_pubnonce, msg32, cache)) {\n+            return 0;\n+        }\n+        /* partial_sign will clear the secnonce by setting it to 0. That's because\n+         * you must _never_ reuse the secnonce (or use the same session_id to\n+         * create a secnonce). If you do, you effectively reuse the nonce and\n+         * leak the secret key. */\n+        if (!secp256k1_musig_partial_sign(ctx, &signer[i].partial_sig, &signer_secrets[i].secnonce, &signer_secrets[i].keypair, cache, &session)) {\n+            return 0;\n+        }\n+        partial_sigs[i] = &signer[i].partial_sig;\n+    }\n+    /* Communication round 2: A production system would exchange\n+     * partial signatures here before moving on. */\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        /* To check whether signing was successful, it suffices to either verify\n+         * the aggregate signature with the aggregate public key using\n+         * secp256k1_schnorrsig_verify, or verify all partial signatures of all\n+         * signers individually. Verifying the aggregate signature is cheaper but\n+         * verifying the individual partial signatures has the advantage that it\n+         * can be used to determine which of the partial signatures are invalid\n+         * (if any), i.e., which of the partial signatures cause the aggregate\n+         * signature to be invalid and thus the protocol run to fail. It's also\n+         * fine to first verify the aggregate sig, and only verify the individual\n+         * sigs if it does not work.\n+         */\n+        if (!secp256k1_musig_partial_sig_verify(ctx, &signer[i].partial_sig, &signer[i].pubnonce, &signer[i].pubkey, cache, &session)) {\n+            return 0;\n+        }\n+    }\n+    return secp256k1_musig_partial_sig_agg(ctx, sig64, &session, partial_sigs, N_SIGNERS);\n+}\n+\n+ int main(void) {\n+    secp256k1_context* ctx;\n+    int i;\n+    struct signer_secrets signer_secrets[N_SIGNERS];\n+    struct signer signers[N_SIGNERS];\n+    const secp256k1_pubkey *pubkeys_ptr[N_SIGNERS];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache cache;\n+    unsigned char msg[32] = \"this_could_be_the_hash_of_a_msg!\";\n+    unsigned char sig[64];\n+\n+    /* Create a secp256k1 context */\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    printf(\"Creating key pairs......\");\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        if (!create_keypair(ctx, &signer_secrets[i], &signers[i])) {\n+            printf(\"FAILED\\n\");\n+            return 1;\n+        }\n+        pubkeys_ptr[i] = &signers[i].pubkey;\n+    }\n+    printf(\"ok\\n\");\n+    printf(\"Combining public keys...\");",
      "path": "examples/musig.c",
      "position": 212,
      "original_position": 186,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "dd4932b67b573b2366e729e869918b17964f5f83",
      "in_reply_to_id": 1477961061,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added sorting and a comment.",
      "created_at": "2024-07-26T09:10:51Z",
      "updated_at": "2024-07-26T09:10:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692751551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692751551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692752131",
      "pull_request_review_id": 2201317942,
      "id": 1692752131,
      "node_id": "PRRC_kwDOAP4Jqs5k5VkD",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    unsigned char xonly_tweak[32] = \"this could be a taproot tweak..\";",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 62,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "75ff36d5db6976270a1a20e72d44d1e90fd7e751",
      "in_reply_to_id": 1691021595,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point. I updated the include file, example & musig.md to clarify that tweak32 is supposed to be a hash. Also added two sentences to the include file that say that the user is responsible for providing a tweak32 that is compatible with MuSig2 (although it is not known whether a fully attacker-controlled `tweak32` breaks unforgeability).",
      "created_at": "2024-07-26T09:11:14Z",
      "updated_at": "2024-07-26T09:11:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692752131",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692752131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692968743",
      "pull_request_review_id": 2201673640,
      "id": 1692968743,
      "node_id": "PRRC_kwDOAP4Jqs5k6Kcn",
      "diff_hunk": "@@ -0,0 +1,214 @@\n+/*************************************************************************\n+ * Written in 2018 by Jonas Nick                                         *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and src/modules/musig/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_schnorrsig.h>\n+#include <secp256k1_musig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3",
      "path": "examples/musig.c",
      "position": 37,
      "original_position": 37,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "c9362664e672efeee8a0c1ee8779071432b78394",
      "in_reply_to_id": 1651017476,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, nice!",
      "created_at": "2024-07-26T12:07:59Z",
      "updated_at": "2024-07-26T12:07:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1692968743",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1692968743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 36,
      "original_start_line": 36,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694981907",
      "pull_request_review_id": 2204550917,
      "id": 1694981907,
      "node_id": "PRRC_kwDOAP4Jqs5lB18T",
      "diff_hunk": "@@ -0,0 +1,584 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 160,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the API description for `_musig_partial_sig_parse`: the statement \"sig will always be initialized\" is currently not true, as the function returns if the scalar encoded in `in32` overflows, without setting `sig`: https://github.com/jonasnick/secp256k1/blob/cf20ad88cd15bd21fcae9e3e7080d310434a21ce/src/modules/musig/session_impl.h#L281-L294",
      "created_at": "2024-07-29T10:28:25Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1694981907",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694981907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 158,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694986984",
      "pull_request_review_id": 2204550917,
      "id": 1694986984,
      "node_id": "PRRC_kwDOAP4Jqs5lB3Lo",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pks[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pks_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pks_hash, pk) where pks_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pks_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(pk));\n+\n+    if (!secp256k1_ge_is_infinity(second_pk)\n+          && secp256k1_ge_eq_var(pk, second_pk)) {\n+        secp256k1_scalar_set_int(r, 1);\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        int ret;\n+        secp256k1_musig_keyaggcoef_sha256(&sha);\n+        secp256k1_sha256_write(&sha, pks_hash, 32);\n+        ret = secp256k1_eckey_pubkey_serialize(pk, buf, &buflen, 1);\n+#ifdef VERIFY\n+        /* Serialization does not fail since the pk is not the point at infinity\n+         * (according to this function's precondition). */\n+        VERIFY_CHECK(ret && buflen == sizeof(buf));\n+#else\n+        (void) ret;\n+#endif\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+        secp256k1_sha256_finalize(&sha, buf);\n+        secp256k1_scalar_set_b32(r, buf, NULL);\n+    }\n+}\n+\n+/* Assumes that pk is not the point at infinity and that the Y-coordinates of pk\n+ * and cache_i->second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef(secp256k1_scalar *r, const secp256k1_keyagg_cache_internal *cache_i, secp256k1_ge *pk) {\n+    secp256k1_musig_keyaggcoef_internal(r, cache_i->pks_hash, pk, &cache_i->second_pk);\n+}\n+\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* pks_hash is the hash of the public keys */\n+    unsigned char pks_hash[32];\n+    const secp256k1_pubkey * const* pks;\n+    secp256k1_ge second_pk;\n+} secp256k1_musig_pubkey_agg_ecmult_data;\n+\n+/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n+static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n+    int ret;\n+    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n+#ifdef VERIFY\n+    /* pubkey_load can't fail because the same pks have already been loaded in\n+     * `musig_compute_pks_hash` (and we test this). */\n+    VERIFY_CHECK(ret);\n+#else\n+    (void) ret;\n+#endif\n+    secp256k1_musig_keyaggcoef_internal(sc, ctx->pks_hash, pt, &ctx->second_pk);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {\n+    secp256k1_musig_pubkey_agg_ecmult_data ecmult_data;\n+    secp256k1_gej pkj;\n+    secp256k1_ge pkp;\n+    size_t i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    if (agg_pk != NULL) {\n+        memset(agg_pk, 0, sizeof(*agg_pk));\n+    }\n+    ARG_CHECK(pubkeys != NULL);\n+    ARG_CHECK(n_pubkeys > 0);\n+\n+    ecmult_data.ctx = ctx;\n+    ecmult_data.pks = pubkeys;\n+\n+    secp256k1_ge_set_infinity(&ecmult_data.second_pk);\n+    for (i = 1; i < n_pubkeys; i++) {\n+        if (secp256k1_memcmp_var(pubkeys[0], pubkeys[i], sizeof(*pubkeys[0])) != 0) {\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, pubkeys[i])) {\n+                return 0;\n+            }\n+            ecmult_data.second_pk = pk;\n+            break;\n+        }\n+    }\n+\n+    if (!secp256k1_musig_compute_pks_hash(ctx, ecmult_data.pks_hash, pubkeys, n_pubkeys)) {\n+        return 0;\n+    }\n+    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n+     * scratch space */\n+    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n+        /* In order to reach this line with the current implementation of\n+         * ecmult_multi_var one would need to provide a callback that can\n+         * fail. */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&pkp, &pkj);\n+    secp256k1_fe_normalize_var(&pkp.y);\n+    /* The resulting public key is infinity with negligible probability */\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(&pkp));\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i = { 0 };\n+        cache_i.pk = pkp;\n+        cache_i.second_pk = ecmult_data.second_pk;\n+        memcpy(cache_i.pks_hash, ecmult_data.pks_hash, sizeof(cache_i.pks_hash));\n+        secp256k1_keyagg_cache_save(keyagg_cache, &cache_i);\n+    }\n+\n+    if (agg_pk != NULL) {\n+        secp256k1_extrakeys_ge_even_y(&pkp);\n+        secp256k1_xonly_pubkey_save(agg_pk, &pkp);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubkey_get(const secp256k1_context* ctx, secp256k1_pubkey *agg_pk, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(agg_pk != NULL);\n+    memset(agg_pk, 0, sizeof(*agg_pk));\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if(!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 241,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "whitespace nit\r\n```suggestion\r\n    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\r\n```",
      "created_at": "2024-07-29T10:32:31Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1694986984",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694986984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694992872",
      "pull_request_review_id": 2204550917,
      "id": 1694992872,
      "node_id": "PRRC_kwDOAP4Jqs5lB4no",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, SECP256K1_EC_COMPRESSED);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 426,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in `_musig_nonce_gen_internal`: for the internal pubkey serialization function `_eckey_pubkey_serialize`, the last parameter is a bool, rather than a collection of flags:\r\n```suggestion\r\n    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\r\n```\r\n(out of scope for this PR, but maybe we should assert `compressed == 0 || compressed == 1` in this function, to avoid issues like this that can happen very easily?)",
      "created_at": "2024-07-29T10:37:42Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1694992872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694992872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 426,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694996688",
      "pull_request_review_id": 2204550917,
      "id": 1694996688,
      "node_id": "PRRC_kwDOAP4Jqs5lB5jQ",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 389,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in `_musig_nonce_gen_internal`: nit, could limit the scope of `cache_i` to where it's needed, i.e inside the `if (keyagg_cache != NULL)` body",
      "created_at": "2024-07-29T10:41:00Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1694996688",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1694996688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695003227",
      "pull_request_review_id": 2204550917,
      "id": 1695003227,
      "node_id": "PRRC_kwDOAP4Jqs5lB7Jb",
      "diff_hunk": "@@ -0,0 +1,584 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce  *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the public nonces of all signers and computes a session that is\n+ *  required for signing and verification of partial signatures.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 459,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in API description for `_musig_nonce_process`: should the \"Takes the public nonces of\" part be replaced by something like \"Takes the public _aggregated_ nonce of...\"?",
      "created_at": "2024-07-29T10:46:36Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695003227",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695003227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 458,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695005205",
      "pull_request_review_id": 2204550917,
      "id": 1695005205,
      "node_id": "PRRC_kwDOAP4Jqs5lB7oV",
      "diff_hunk": "@@ -0,0 +1,584 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce  *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the public nonces of all signers and computes a session that is\n+ *  required for signing and verification of partial signatures.\n+ *\n+ *  Returns: 0 if the arguments are invalid or if some signer sent invalid\n+ *           pubnonces, 1 otherwise\n+ *  Args:          ctx: pointer to a context object\n+ *  Out:       session: pointer to a struct to store the session\n+ *  In:       aggnonce: pointer to an aggregate public nonce object that is the\n+ *                      output of musig_nonce_agg\n+ *              msg32:  the 32-byte message to sign\n+ *       keyagg_cache:  pointer to the keyagg_cache that was used to create the\n+ *                      aggregate (and potentially tweaked) pubkey\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_nonce_process(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_session *session,\n+    const secp256k1_musig_aggnonce  *aggnonce,",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 474,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "whitespace nit\r\n```suggestion\r\n    const secp256k1_musig_aggnonce *aggnonce,\r\n```",
      "created_at": "2024-07-29T10:48:20Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695005205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695005205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 474,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695012099",
      "pull_request_review_id": 2204550917,
      "id": 1695012099,
      "node_id": "PRRC_kwDOAP4Jqs5lB9UD",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {",
      "path": "src/modules/musig/session_impl.h",
      "position": 214,
      "original_position": 190,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "pedantic mini-nit: the public _parse/_serialize functions appear in a different order in the API description than in the implementation file here (parse, serialize vs serialize, parse)",
      "created_at": "2024-07-29T10:54:29Z",
      "updated_at": "2024-07-29T10:56:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695012099",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695012099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695392689",
      "pull_request_review_id": 2205229808,
      "id": 1695392689,
      "node_id": "PRRC_kwDOAP4Jqs5lDaOx",
      "diff_hunk": "@@ -0,0 +1,584 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 160,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": 1694981907,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I removed that paragraph.\r\n\r\n  What we can provide to the user is the guarantee that even if the return value of partial_sig_parse isn't checked, then partial_sig_verify will for sure fail. Even though that was already the case due to the magic, I added an extra memset to make this extra clear.\r\nI don't see a reason to mention this to the user (they should just check return values...).\r\n",
      "created_at": "2024-07-29T15:00:04Z",
      "updated_at": "2024-07-29T15:00:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695392689",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695392689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 158,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695393239",
      "pull_request_review_id": 2205230525,
      "id": 1695393239,
      "node_id": "PRRC_kwDOAP4Jqs5lDaXX",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_keyagg_cache_internal cache_i;",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 389,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": 1694996688,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-29T15:00:18Z",
      "updated_at": "2024-07-29T15:00:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695393239",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695393239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695393703",
      "pull_request_review_id": 2205231305,
      "id": 1695393703,
      "node_id": "PRRC_kwDOAP4Jqs5lDaen",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {",
      "path": "src/modules/musig/session_impl.h",
      "position": 214,
      "original_position": 190,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": 1695012099,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-07-29T15:00:33Z",
      "updated_at": "2024-07-29T15:00:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695393703",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695393703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695394620",
      "pull_request_review_id": 2205232668,
      "id": 1695394620,
      "node_id": "PRRC_kwDOAP4Jqs5lDas8",
      "diff_hunk": "@@ -0,0 +1,584 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ *\n+ *  After the call, sig will always be initialized. If parsing failed or the\n+ *  encoded numbers are out of range, signature verification with it is\n+ *  guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce  *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the public nonces of all signers and computes a session that is\n+ *  required for signing and verification of partial signatures.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 459,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "aee84562578416d9dfc8c87c6e28f239af7f4e93",
      "in_reply_to_id": 1695003227,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wow this sentence was older than nonce aggregation. Fixed.",
      "created_at": "2024-07-29T15:01:01Z",
      "updated_at": "2024-07-29T15:01:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1695394620",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1695394620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 458,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1701658318",
      "pull_request_review_id": 2215272669,
      "id": 1701658318,
      "node_id": "PRRC_kwDOAP4Jqs5lbT7O",
      "diff_hunk": "@@ -0,0 +1,805 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 473,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, since this is just a single byte:\r\n```suggestion\r\n    acc = 0;\r\n```\r\n(or is this then more likely to be optimized out by the compiler?)",
      "created_at": "2024-08-02T10:25:12Z",
      "updated_at": "2024-08-02T13:58:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1701658318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1701658318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 474,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1701660459",
      "pull_request_review_id": 2215272669,
      "id": 1701660459,
      "node_id": "PRRC_kwDOAP4Jqs5lbUcr",
      "diff_hunk": "@@ -0,0 +1,805 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 550,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this function always succeeds, so it could be declared `void` instead, and the return value check in `_musig_nonce_process_internal` below can then be removed as well.",
      "created_at": "2024-08-02T10:27:12Z",
      "updated_at": "2024-08-02T13:58:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1701660459",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1701660459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 550,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703177801",
      "pull_request_review_id": 2217743071,
      "id": 1703177801,
      "node_id": "PRRC_kwDOAP4Jqs5lhG5J",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 371,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: duplicate call",
      "created_at": "2024-08-04T12:39:03Z",
      "updated_at": "2024-08-04T13:04:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703177801",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703177801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 369,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703179633",
      "pull_request_review_id": 2217743071,
      "id": 1703179633,
      "node_id": "PRRC_kwDOAP4Jqs5lhHVx",
      "diff_hunk": "@@ -180,6 +185,58 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     CHECK(ret == 1);\n #endif\n \n+#ifdef ENABLE_MODULE_MUSIG\n+    {\n+        secp256k1_pubkey pk;\n+        const secp256k1_pubkey *pk_ptr[1];\n+        secp256k1_xonly_pubkey agg_pk;\n+        unsigned char session_secrand[32];\n+        uint64_t nonrepeating_cnt = 0;\n+        secp256k1_musig_secnonce secnonce;\n+        secp256k1_musig_pubnonce pubnonce;\n+        const secp256k1_musig_pubnonce *pubnonce_ptr[1];\n+        secp256k1_musig_aggnonce aggnonce;\n+        secp256k1_musig_keyagg_cache cache;\n+        secp256k1_musig_session session;\n+        secp256k1_musig_partial_sig partial_sig;\n+        unsigned char extra_input[32];\n+\n+        pk_ptr[0] = &pk;\n+        pubnonce_ptr[0] = &pubnonce;\n+        SECP256K1_CHECKMEM_DEFINE(key, 32);\n+        memcpy(session_secrand, key, sizeof(session_secrand));\n+        session_secrand[0] = session_secrand[0] + 1;\n+        memcpy(extra_input, key, sizeof(extra_input));\n+        extra_input[0] = extra_input[0] + 2;\n+\n+        CHECK(secp256k1_keypair_create(ctx, &keypair, key));\n+        CHECK(secp256k1_keypair_pub(ctx, &pk, &keypair));\n+        CHECK(secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pk_ptr, 1));\n+\n+        SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+        SECP256K1_CHECKMEM_UNDEFINE(session_secrand, sizeof(session_secrand));\n+        SECP256K1_CHECKMEM_UNDEFINE(extra_input, sizeof(extra_input));\n+        ret = secp256k1_musig_nonce_gen(ctx, &secnonce, &pubnonce, session_secrand, key, &pk, msg, &cache, extra_input);\n+        SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+        CHECK(ret == 1);\n+        ret = secp256k1_musig_nonce_gen_counter(ctx, &secnonce, &pubnonce, nonrepeating_cnt, key, &pk, msg, &cache, extra_input);\n+        SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+        CHECK(ret == 1);\n+\n+        CHECK(secp256k1_musig_nonce_agg(ctx, &aggnonce, pubnonce_ptr, 1));\n+        /* Make sure that previous tests don't undefine msg. It's not used as a secret here. */\n+        SECP256K1_CHECKMEM_DEFINE(msg, sizeof(msg));\n+        CHECK(secp256k1_musig_nonce_process(ctx, &session, &aggnonce, msg, &cache) == 1);",
      "path": "src/ctime_tests.c",
      "position": 64,
      "original_position": 64,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "any reason why storing the result into `ret` and calling the _CHECKMEM_DEFINE macro isn't needed/done here?",
      "created_at": "2024-08-04T12:43:05Z",
      "updated_at": "2024-08-04T13:04:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703179633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703179633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703184149",
      "pull_request_review_id": 2217743071,
      "id": 1703184149,
      "node_id": "PRRC_kwDOAP4Jqs5lhIcV",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session) == 1);\n+    /* The secnonce is set to 0 and subsequent signing attempts fail */\n+    CHECK(secp256k1_memcmp_var(&secnonce_tmp, zeros132, sizeof(secnonce_tmp)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, NULL, &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], NULL, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &invalid_secnonce, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, NULL, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &invalid_keypair, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    {\n+        unsigned char sk_tmp[32];\n+        secp256k1_keypair keypair_tmp;\n+        testrand256(sk_tmp);\n+        CHECK(secp256k1_keypair_create(CTX, &keypair_tmp, sk_tmp));\n+        CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair_tmp, &keyagg_cache, &session));\n+        memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], NULL, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &invalid_keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, NULL));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &invalid_session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], &keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, NULL, &partial_sig[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, &invalid_partial_sig));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], buf) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, NULL, buf));\n+    {\n+        /* Check that parsing failure results in an invalid sig */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, max64) == 0);\n+        CHECK(secp256k1_memcmp_var(&tmp, zeros132, sizeof(partial_sig[0])) == 0);\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], NULL));\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, buf) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &partial_sig[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Partial signature verification */\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, NULL, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &invalid_partial_sig, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], NULL, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &invalid_pubnonce, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], NULL, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &invalid_pk, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], NULL, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &invalid_keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &invalid_session));\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], &keyagg_cache, &session) == 1);\n+\n+    /** Signature aggregation and verification */\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, NULL, &session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, NULL, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &invalid_session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, invalid_partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 0));\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 1) == 1);\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+}\n+\n+static void musig_nonce_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    secp256k1_scalar k1[2], k2[2];\n+\n+    secp256k1_nonce_function_musig(k1, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    testrand_flip(args[n_flip], n_bytes);\n+    secp256k1_nonce_function_musig(k2, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    CHECK(secp256k1_scalar_eq(&k1[0], &k2[0]) == 0);\n+    CHECK(secp256k1_scalar_eq(&k1[1], &k2[1]) == 0);\n+}\n+\n+static void musig_nonce_test(void) {\n+    unsigned char *args[6];\n+    unsigned char session_secrand[32];\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    unsigned char msg[32];\n+    unsigned char agg_pk[32];\n+    unsigned char extra_input[32];\n+    int i, j;\n+    secp256k1_scalar k[6][2];\n+\n+    testrand_bytes_test(session_secrand, sizeof(session_secrand));\n+    testrand_bytes_test(sk, sizeof(sk));\n+    testrand_bytes_test(pk, sizeof(pk));\n+    testrand_bytes_test(msg, sizeof(msg));\n+    testrand_bytes_test(agg_pk, sizeof(agg_pk));\n+    testrand_bytes_test(extra_input, sizeof(extra_input));\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = session_secrand;\n+    args[1] = msg;\n+    args[2] = sk;\n+    args[3] = pk;\n+    args[4] = agg_pk;\n+    args[5] = extra_input;\n+    for (i = 0; i < COUNT; i++) {\n+        musig_nonce_bitflip(args, 0, sizeof(session_secrand));\n+        musig_nonce_bitflip(args, 1, sizeof(msg));\n+        musig_nonce_bitflip(args, 2, sizeof(sk));\n+        musig_nonce_bitflip(args, 3, sizeof(pk));\n+        musig_nonce_bitflip(args, 4, sizeof(agg_pk));\n+        musig_nonce_bitflip(args, 5, sizeof(extra_input));\n+    }\n+    /* Check that if any argument is NULL, a different nonce is produced than if\n+     * any other argument is NULL. */\n+    memcpy(msg, session_secrand, sizeof(msg));\n+    memcpy(sk, session_secrand, sizeof(sk));\n+    memcpy(pk, session_secrand, sizeof(session_secrand));\n+    memcpy(agg_pk, session_secrand, sizeof(agg_pk));\n+    memcpy(extra_input, session_secrand, sizeof(extra_input));\n+    secp256k1_nonce_function_musig(k[0], args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[1], args[0], NULL, args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[2], args[0], args[1], NULL, args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[3], args[0], args[1], args[2], NULL, args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[4], args[0], args[1], args[2], args[3], NULL, args[5]);\n+    secp256k1_nonce_function_musig(k[5], args[0], args[1], args[2], args[3], args[4], NULL);\n+    for (i = 0; i < 6; i++) {\n+        CHECK(!secp256k1_scalar_eq(&k[i][0], &k[i][1]));\n+        for (j = i+1; j < 6; j++) {\n+            CHECK(!secp256k1_scalar_eq(&k[i][0], &k[j][0]));\n+            CHECK(!secp256k1_scalar_eq(&k[i][1], &k[j][1]));\n+        }\n+    }\n+}\n+\n+static void sha256_tag_test_internal(secp256k1_sha256 *sha_tagged, unsigned char *tag, size_t taglen) {\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    test_sha256_eq(&sha, sha_tagged);\n+}\n+\n+/* Checks that the initialized tagged hashes initialized have the expected",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 529,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: one `initialized` too much i guess\r\n```suggestion\r\n/* Checks that the initialized tagged hashes have the expected\r\n```",
      "created_at": "2024-08-04T12:53:12Z",
      "updated_at": "2024-08-04T13:04:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703184149",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703184149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703186121",
      "pull_request_review_id": 2217743071,
      "id": 1703186121,
      "node_id": "PRRC_kwDOAP4Jqs5lhI7J",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session) == 1);\n+    /* The secnonce is set to 0 and subsequent signing attempts fail */\n+    CHECK(secp256k1_memcmp_var(&secnonce_tmp, zeros132, sizeof(secnonce_tmp)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, NULL, &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], NULL, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &invalid_secnonce, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, NULL, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &invalid_keypair, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    {\n+        unsigned char sk_tmp[32];\n+        secp256k1_keypair keypair_tmp;\n+        testrand256(sk_tmp);\n+        CHECK(secp256k1_keypair_create(CTX, &keypair_tmp, sk_tmp));\n+        CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair_tmp, &keyagg_cache, &session));\n+        memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], NULL, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &invalid_keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, NULL));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &invalid_session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], &keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, NULL, &partial_sig[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, &invalid_partial_sig));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], buf) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, NULL, buf));\n+    {\n+        /* Check that parsing failure results in an invalid sig */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, max64) == 0);\n+        CHECK(secp256k1_memcmp_var(&tmp, zeros132, sizeof(partial_sig[0])) == 0);\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], NULL));\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, buf) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &partial_sig[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Partial signature verification */\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, NULL, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &invalid_partial_sig, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], NULL, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &invalid_pubnonce, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], NULL, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &invalid_pk, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], NULL, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &invalid_keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &invalid_session));\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], &keyagg_cache, &session) == 1);\n+\n+    /** Signature aggregation and verification */\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, NULL, &session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, NULL, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &invalid_session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, invalid_partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 0));\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 1) == 1);\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+}\n+\n+static void musig_nonce_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    secp256k1_scalar k1[2], k2[2];\n+\n+    secp256k1_nonce_function_musig(k1, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    testrand_flip(args[n_flip], n_bytes);\n+    secp256k1_nonce_function_musig(k2, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    CHECK(secp256k1_scalar_eq(&k1[0], &k2[0]) == 0);\n+    CHECK(secp256k1_scalar_eq(&k1[1], &k2[1]) == 0);\n+}\n+\n+static void musig_nonce_test(void) {\n+    unsigned char *args[6];\n+    unsigned char session_secrand[32];\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    unsigned char msg[32];\n+    unsigned char agg_pk[32];\n+    unsigned char extra_input[32];\n+    int i, j;\n+    secp256k1_scalar k[6][2];\n+\n+    testrand_bytes_test(session_secrand, sizeof(session_secrand));\n+    testrand_bytes_test(sk, sizeof(sk));\n+    testrand_bytes_test(pk, sizeof(pk));\n+    testrand_bytes_test(msg, sizeof(msg));\n+    testrand_bytes_test(agg_pk, sizeof(agg_pk));\n+    testrand_bytes_test(extra_input, sizeof(extra_input));\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = session_secrand;\n+    args[1] = msg;\n+    args[2] = sk;\n+    args[3] = pk;\n+    args[4] = agg_pk;\n+    args[5] = extra_input;\n+    for (i = 0; i < COUNT; i++) {\n+        musig_nonce_bitflip(args, 0, sizeof(session_secrand));\n+        musig_nonce_bitflip(args, 1, sizeof(msg));\n+        musig_nonce_bitflip(args, 2, sizeof(sk));\n+        musig_nonce_bitflip(args, 3, sizeof(pk));\n+        musig_nonce_bitflip(args, 4, sizeof(agg_pk));\n+        musig_nonce_bitflip(args, 5, sizeof(extra_input));\n+    }\n+    /* Check that if any argument is NULL, a different nonce is produced than if\n+     * any other argument is NULL. */\n+    memcpy(msg, session_secrand, sizeof(msg));\n+    memcpy(sk, session_secrand, sizeof(sk));\n+    memcpy(pk, session_secrand, sizeof(session_secrand));\n+    memcpy(agg_pk, session_secrand, sizeof(agg_pk));\n+    memcpy(extra_input, session_secrand, sizeof(extra_input));\n+    secp256k1_nonce_function_musig(k[0], args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[1], args[0], NULL, args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[2], args[0], args[1], NULL, args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[3], args[0], args[1], args[2], NULL, args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[4], args[0], args[1], args[2], args[3], NULL, args[5]);\n+    secp256k1_nonce_function_musig(k[5], args[0], args[1], args[2], args[3], args[4], NULL);\n+    for (i = 0; i < 6; i++) {\n+        CHECK(!secp256k1_scalar_eq(&k[i][0], &k[i][1]));\n+        for (j = i+1; j < 6; j++) {\n+            CHECK(!secp256k1_scalar_eq(&k[i][0], &k[j][0]));\n+            CHECK(!secp256k1_scalar_eq(&k[i][1], &k[j][1]));\n+        }\n+    }\n+}\n+\n+static void sha256_tag_test_internal(secp256k1_sha256 *sha_tagged, unsigned char *tag, size_t taglen) {\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    test_sha256_eq(&sha, sha_tagged);\n+}\n+\n+/* Checks that the initialized tagged hashes initialized have the expected\n+ * state. */\n+static void sha256_tag_test(void) {\n+    secp256k1_sha256 sha;\n+    {\n+        char tag[11] = \"KeyAgg list\";\n+        secp256k1_musig_keyagglist_sha256(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 536,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: not sure if it's worth to change it, but could either use `strlen` or `sizeof(tag)-1` to avoid specifying the exact size for the array\r\n```suggestion\r\n        char tag[] = \"KeyAgg list\";\r\n        secp256k1_musig_keyagglist_sha256(&sha);\r\n        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag)-1);\r\n```",
      "created_at": "2024-08-04T12:57:40Z",
      "updated_at": "2024-08-04T13:04:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703186121",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703186121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 534,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 536,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703410759",
      "pull_request_review_id": 2217828907,
      "id": 1703410759,
      "node_id": "PRRC_kwDOAP4Jqs5lh_xH",
      "diff_hunk": "@@ -0,0 +1,805 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 473,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1701658318,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess dead store elimination happens at a later compilation stage that does not care whether the store came from an assignment or a memset, so they're equally likely to be optimized out by the compiler.\r\n\r\nSo unfortunately both variants are without effect. The advantage of an explicit memset is that it stands out / is grepable, if something wants to pick up #636. (Feel free to give it a shot :P)",
      "created_at": "2024-08-04T22:54:36Z",
      "updated_at": "2024-08-04T22:54:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703410759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703410759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 474,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703989816",
      "pull_request_review_id": 2218780656,
      "id": 1703989816,
      "node_id": "PRRC_kwDOAP4Jqs5lkNI4",
      "diff_hunk": "@@ -0,0 +1,805 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static int secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 550,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1701660459,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-08-05T11:44:02Z",
      "updated_at": "2024-08-05T11:44:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703989816",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703989816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 550,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990070",
      "pull_request_review_id": 2218781085,
      "id": 1703990070,
      "node_id": "PRRC_kwDOAP4Jqs5lkNM2",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 371,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1703177801,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-08-05T11:44:18Z",
      "updated_at": "2024-08-05T11:44:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703990070",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 369,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990422",
      "pull_request_review_id": 2218781721,
      "id": 1703990422,
      "node_id": "PRRC_kwDOAP4Jqs5lkNSW",
      "diff_hunk": "@@ -180,6 +185,58 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     CHECK(ret == 1);\n #endif\n \n+#ifdef ENABLE_MODULE_MUSIG\n+    {\n+        secp256k1_pubkey pk;\n+        const secp256k1_pubkey *pk_ptr[1];\n+        secp256k1_xonly_pubkey agg_pk;\n+        unsigned char session_secrand[32];\n+        uint64_t nonrepeating_cnt = 0;\n+        secp256k1_musig_secnonce secnonce;\n+        secp256k1_musig_pubnonce pubnonce;\n+        const secp256k1_musig_pubnonce *pubnonce_ptr[1];\n+        secp256k1_musig_aggnonce aggnonce;\n+        secp256k1_musig_keyagg_cache cache;\n+        secp256k1_musig_session session;\n+        secp256k1_musig_partial_sig partial_sig;\n+        unsigned char extra_input[32];\n+\n+        pk_ptr[0] = &pk;\n+        pubnonce_ptr[0] = &pubnonce;\n+        SECP256K1_CHECKMEM_DEFINE(key, 32);\n+        memcpy(session_secrand, key, sizeof(session_secrand));\n+        session_secrand[0] = session_secrand[0] + 1;\n+        memcpy(extra_input, key, sizeof(extra_input));\n+        extra_input[0] = extra_input[0] + 2;\n+\n+        CHECK(secp256k1_keypair_create(ctx, &keypair, key));\n+        CHECK(secp256k1_keypair_pub(ctx, &pk, &keypair));\n+        CHECK(secp256k1_musig_pubkey_agg(ctx, &agg_pk, &cache, pk_ptr, 1));\n+\n+        SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+        SECP256K1_CHECKMEM_UNDEFINE(session_secrand, sizeof(session_secrand));\n+        SECP256K1_CHECKMEM_UNDEFINE(extra_input, sizeof(extra_input));\n+        ret = secp256k1_musig_nonce_gen(ctx, &secnonce, &pubnonce, session_secrand, key, &pk, msg, &cache, extra_input);\n+        SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+        CHECK(ret == 1);\n+        ret = secp256k1_musig_nonce_gen_counter(ctx, &secnonce, &pubnonce, nonrepeating_cnt, key, &pk, msg, &cache, extra_input);\n+        SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+        CHECK(ret == 1);\n+\n+        CHECK(secp256k1_musig_nonce_agg(ctx, &aggnonce, pubnonce_ptr, 1));\n+        /* Make sure that previous tests don't undefine msg. It's not used as a secret here. */\n+        SECP256K1_CHECKMEM_DEFINE(msg, sizeof(msg));\n+        CHECK(secp256k1_musig_nonce_process(ctx, &session, &aggnonce, msg, &cache) == 1);",
      "path": "src/ctime_tests.c",
      "position": 64,
      "original_position": 64,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1703179633,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The return value doesn't depend on secret data.",
      "created_at": "2024-08-05T11:44:40Z",
      "updated_at": "2024-08-05T11:44:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703990422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990538",
      "pull_request_review_id": 2218781920,
      "id": 1703990538,
      "node_id": "PRRC_kwDOAP4Jqs5lkNUK",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session) == 1);\n+    /* The secnonce is set to 0 and subsequent signing attempts fail */\n+    CHECK(secp256k1_memcmp_var(&secnonce_tmp, zeros132, sizeof(secnonce_tmp)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, NULL, &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], NULL, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &invalid_secnonce, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, NULL, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &invalid_keypair, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    {\n+        unsigned char sk_tmp[32];\n+        secp256k1_keypair keypair_tmp;\n+        testrand256(sk_tmp);\n+        CHECK(secp256k1_keypair_create(CTX, &keypair_tmp, sk_tmp));\n+        CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair_tmp, &keyagg_cache, &session));\n+        memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], NULL, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &invalid_keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, NULL));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &invalid_session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], &keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, NULL, &partial_sig[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, &invalid_partial_sig));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], buf) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, NULL, buf));\n+    {\n+        /* Check that parsing failure results in an invalid sig */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, max64) == 0);\n+        CHECK(secp256k1_memcmp_var(&tmp, zeros132, sizeof(partial_sig[0])) == 0);\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], NULL));\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, buf) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &partial_sig[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Partial signature verification */\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, NULL, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &invalid_partial_sig, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], NULL, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &invalid_pubnonce, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], NULL, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &invalid_pk, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], NULL, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &invalid_keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &invalid_session));\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], &keyagg_cache, &session) == 1);\n+\n+    /** Signature aggregation and verification */\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, NULL, &session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, NULL, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &invalid_session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, invalid_partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 0));\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 1) == 1);\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+}\n+\n+static void musig_nonce_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    secp256k1_scalar k1[2], k2[2];\n+\n+    secp256k1_nonce_function_musig(k1, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    testrand_flip(args[n_flip], n_bytes);\n+    secp256k1_nonce_function_musig(k2, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    CHECK(secp256k1_scalar_eq(&k1[0], &k2[0]) == 0);\n+    CHECK(secp256k1_scalar_eq(&k1[1], &k2[1]) == 0);\n+}\n+\n+static void musig_nonce_test(void) {\n+    unsigned char *args[6];\n+    unsigned char session_secrand[32];\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    unsigned char msg[32];\n+    unsigned char agg_pk[32];\n+    unsigned char extra_input[32];\n+    int i, j;\n+    secp256k1_scalar k[6][2];\n+\n+    testrand_bytes_test(session_secrand, sizeof(session_secrand));\n+    testrand_bytes_test(sk, sizeof(sk));\n+    testrand_bytes_test(pk, sizeof(pk));\n+    testrand_bytes_test(msg, sizeof(msg));\n+    testrand_bytes_test(agg_pk, sizeof(agg_pk));\n+    testrand_bytes_test(extra_input, sizeof(extra_input));\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = session_secrand;\n+    args[1] = msg;\n+    args[2] = sk;\n+    args[3] = pk;\n+    args[4] = agg_pk;\n+    args[5] = extra_input;\n+    for (i = 0; i < COUNT; i++) {\n+        musig_nonce_bitflip(args, 0, sizeof(session_secrand));\n+        musig_nonce_bitflip(args, 1, sizeof(msg));\n+        musig_nonce_bitflip(args, 2, sizeof(sk));\n+        musig_nonce_bitflip(args, 3, sizeof(pk));\n+        musig_nonce_bitflip(args, 4, sizeof(agg_pk));\n+        musig_nonce_bitflip(args, 5, sizeof(extra_input));\n+    }\n+    /* Check that if any argument is NULL, a different nonce is produced than if\n+     * any other argument is NULL. */\n+    memcpy(msg, session_secrand, sizeof(msg));\n+    memcpy(sk, session_secrand, sizeof(sk));\n+    memcpy(pk, session_secrand, sizeof(session_secrand));\n+    memcpy(agg_pk, session_secrand, sizeof(agg_pk));\n+    memcpy(extra_input, session_secrand, sizeof(extra_input));\n+    secp256k1_nonce_function_musig(k[0], args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[1], args[0], NULL, args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[2], args[0], args[1], NULL, args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[3], args[0], args[1], args[2], NULL, args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[4], args[0], args[1], args[2], args[3], NULL, args[5]);\n+    secp256k1_nonce_function_musig(k[5], args[0], args[1], args[2], args[3], args[4], NULL);\n+    for (i = 0; i < 6; i++) {\n+        CHECK(!secp256k1_scalar_eq(&k[i][0], &k[i][1]));\n+        for (j = i+1; j < 6; j++) {\n+            CHECK(!secp256k1_scalar_eq(&k[i][0], &k[j][0]));\n+            CHECK(!secp256k1_scalar_eq(&k[i][1], &k[j][1]));\n+        }\n+    }\n+}\n+\n+static void sha256_tag_test_internal(secp256k1_sha256 *sha_tagged, unsigned char *tag, size_t taglen) {\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    test_sha256_eq(&sha, sha_tagged);\n+}\n+\n+/* Checks that the initialized tagged hashes initialized have the expected",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 529,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1703184149,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-08-05T11:44:46Z",
      "updated_at": "2024-08-05T11:44:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703990538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990709",
      "pull_request_review_id": 2218782197,
      "id": 1703990709,
      "node_id": "PRRC_kwDOAP4Jqs5lkNW1",
      "diff_hunk": "@@ -0,0 +1,1110 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+    secp256k1_gej summed_nonces[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+\n+    ge[0] = secp256k1_ge_const_g;\n+    ge[1] = secp256k1_ge_const_g;\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_pubnonce_save(&pubnonce[i], ge);\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        secp256k1_ge_neg(&ge[0], &ge[0]);\n+        secp256k1_ge_neg(&ge[1], &ge[1]);\n+    }\n+\n+    secp256k1_musig_sum_nonces(CTX, summed_nonces, pubnonce_ptr, 2);\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[0]));\n+    CHECK(secp256k1_gej_is_infinity(&summed_nonces[1]));\n+}\n+\n+int memcmp_and_randomize(unsigned char *value, const unsigned char *expected, size_t len) {\n+    int ret;\n+    size_t i;\n+    ret = secp256k1_memcmp_var(value, expected, len);\n+    for (i = 0; i < len; i++) {\n+        value[i] = testrand_bits(8);\n+    }\n+    return ret;\n+}\n+\n+static void musig_api_tests(void) {\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    secp256k1_musig_partial_sig invalid_partial_sig;\n+    const secp256k1_musig_partial_sig *invalid_partial_sig_ptr[2];\n+    unsigned char pre_sig[64];\n+    unsigned char buf[32];\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_keypair invalid_keypair;\n+    unsigned char max64[64];\n+    unsigned char zeros132[132] = { 0 };\n+    unsigned char session_secrand[2][32];\n+    unsigned char nonrepeating_cnt = 0;\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_musig_secnonce secnonce_tmp;\n+    secp256k1_musig_secnonce invalid_secnonce;\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    unsigned char pubnonce_ser[66];\n+    secp256k1_musig_pubnonce inf_pubnonce[2];\n+    const secp256k1_musig_pubnonce *inf_pubnonce_ptr[2];\n+    secp256k1_musig_pubnonce invalid_pubnonce;\n+    const secp256k1_musig_pubnonce *invalid_pubnonce_ptr[1];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char aggnonce_ser[66];\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_pubkey full_agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    secp256k1_musig_keyagg_cache invalid_keyagg_cache;\n+    secp256k1_musig_session session;\n+    secp256k1_musig_session invalid_session;\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_pubkey invalid_pk;\n+    const secp256k1_pubkey *invalid_pk_ptr2[2];\n+    const secp256k1_pubkey *invalid_pk_ptr3[3];\n+    unsigned char tweak[32];\n+    int i;\n+\n+    /** setup **/\n+    memset(max64, 0xff, sizeof(max64));\n+    memset(&invalid_keypair, 0, sizeof(invalid_keypair));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_secnonce, 0, sizeof(invalid_secnonce));\n+    memset(&invalid_partial_sig, 0, sizeof(invalid_partial_sig));\n+    pubnonce_summing_to_inf(inf_pubnonce);\n+    /* Simulate structs being uninitialized by setting it to 0s. We don't want\n+     * to produce undefined behavior by actually providing uninitialized\n+     * structs. */\n+    memset(&invalid_keyagg_cache, 0, sizeof(invalid_keyagg_cache));\n+    memset(&invalid_pk, 0, sizeof(invalid_pk));\n+    memset(&invalid_pubnonce, 0, sizeof(invalid_pubnonce));\n+    memset(&invalid_session, 0, sizeof(invalid_session));\n+\n+    testrand256(msg);\n+    testrand256(tweak);\n+    for (i = 0; i < 2; i++) {\n+        pk_ptr[i] = &pk[i];\n+        invalid_pk_ptr2[i] = &invalid_pk;\n+        invalid_pk_ptr3[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        inf_pubnonce_ptr[i] = &inf_pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+        invalid_partial_sig_ptr[i] = &partial_sig[i];\n+        testrand256(session_secrand[i]);\n+        testrand256(sk[i]);\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+    }\n+    invalid_pubnonce_ptr[0] = &invalid_pubnonce;\n+    invalid_partial_sig_ptr[0] = &invalid_partial_sig;\n+    /* invalid_pk_ptr3 has two valid, one invalid pk, which is important to test\n+     * musig_pubkey_agg */\n+    invalid_pk_ptr3[2] = &invalid_pk;\n+\n+    /** main test body **/\n+\n+    /** Key aggregation **/\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, NULL, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, NULL, pk_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr2, 2));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, invalid_pk_ptr3, 3));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, NULL, 0));\n+    CHECK(memcmp_and_randomize(agg_pk.data, zeros132, sizeof(agg_pk.data)) == 0);\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+\n+    /* pubkey_get */\n+    CHECK(secp256k1_musig_pubkey_get(CTX, &full_agg_pk, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubkey_get(CTX, &full_agg_pk, NULL));\n+    CHECK(secp256k1_memcmp_var(&full_agg_pk, zeros132, sizeof(full_agg_pk)) == 0);\n+\n+    /** Tweaking **/\n+    {\n+        int (*tweak_func[2]) (const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *tweak32);\n+        tweak_func[0] = secp256k1_musig_pubkey_ec_tweak_add;\n+        tweak_func[1] = secp256k1_musig_pubkey_xonly_tweak_add;\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_pubkey tmp_output_pk;\n+            secp256k1_musig_keyagg_cache tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, tweak) == 1);\n+            /* Reset keyagg_cache */\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, NULL, &tmp_keyagg_cache, tweak) == 1);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, NULL, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, NULL));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            CHECK((*tweak_func[i])(CTX, &tmp_output_pk, &tmp_keyagg_cache, max64) == 0);\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+            tmp_keyagg_cache = keyagg_cache;\n+            /* Uninitialized keyagg_cache */\n+            CHECK_ILLEGAL(CTX, (*tweak_func[i])(CTX, &tmp_output_pk, &invalid_keyagg_cache, tweak));\n+            CHECK(memcmp_and_randomize(tmp_output_pk.data, zeros132, sizeof(tmp_output_pk.data)) == 0);\n+        }\n+    }\n+\n+    /** Session creation with nonce_gen **/\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen(STATIC_CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, NULL, &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], NULL, session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], NULL, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* session_secrand = 0 is disallowed because it indicates a faulty RNG */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], zeros132, sk[0], &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], msg, &keyagg_cache, max64) == 1);\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except session_secrand and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[0], &pubnonce[0], session_secrand[0], NULL, &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[1], &pubnonce[1], session_secrand[1], sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+    /** Session creation with nonce_gen_counter **/\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64) == 1);\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_musig_nonce_gen_counter(STATIC_CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, NULL, &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], NULL, nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    /* using nonce_gen_counter requires sk */\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, NULL, &pk[0], msg, &keyagg_cache, max64));\n+    /* invalid seckey */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, max64, &pk[0], msg, &keyagg_cache, max64) == 0);\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], NULL, msg, &keyagg_cache, max64));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &invalid_pk, msg, &keyagg_cache, max64));\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, &keyagg_cache, max64) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, NULL, max64) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &invalid_keyagg_cache, max64));\n+    CHECK(memcmp_and_randomize(secnonce[0].data, zeros132, sizeof(secnonce[0].data)) == 0);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], msg, &keyagg_cache, NULL) == 1);\n+\n+    /* Every in-argument except nonrepeating_cnt, sk and pubkey can be NULL */\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[0], &pubnonce[0], nonrepeating_cnt, sk[0], &pk[0], NULL, NULL, NULL) == 1);\n+    CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[1], &pubnonce[1], nonrepeating_cnt, sk[1], &pk[1], NULL, NULL, NULL) == 1);\n+\n+\n+    /** Serialize and parse public nonces **/\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, NULL, &pubnonce[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(pubnonce_ser, zeros132, sizeof(pubnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, NULL, pubnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], NULL));\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], zeros132) == 0);\n+    CHECK(secp256k1_musig_pubnonce_parse(CTX, &pubnonce[0], pubnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_pubnonce tmp;\n+        CHECK(secp256k1_musig_pubnonce_serialize(CTX, pubnonce_ser, &pubnonce[0]) == 1);\n+        CHECK(secp256k1_musig_pubnonce_parse(CTX, &tmp, pubnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &pubnonce[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Receive nonces and aggregate **/\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, NULL, pubnonce_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_agg(CTX, &aggnonce, invalid_pubnonce_ptr, 1));\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, inf_pubnonce_ptr, 2) == 1);\n+    {\n+        /* Check that the aggnonce encodes two points at infinity */\n+        secp256k1_ge aggnonce_pt[2];\n+        secp256k1_musig_aggnonce_load(CTX, aggnonce_pt, &aggnonce);\n+        for (i = 0; i < 2; i++) {\n+            secp256k1_ge_is_infinity(&aggnonce_pt[i]);\n+        }\n+    }\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+\n+    /** Serialize and parse aggregate nonces **/\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, NULL, &aggnonce));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, NULL));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, (secp256k1_musig_aggnonce*) &invalid_pubnonce));\n+    CHECK(memcmp_and_randomize(aggnonce_ser, zeros132, sizeof(aggnonce_ser)) == 0);\n+    CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, NULL, aggnonce_ser));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_aggnonce_parse(CTX, &aggnonce, NULL));\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, zeros132) == 1);\n+    CHECK(secp256k1_musig_aggnonce_parse(CTX, &aggnonce, aggnonce_ser) == 1);\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_aggnonce tmp;\n+        CHECK(secp256k1_musig_aggnonce_serialize(CTX, aggnonce_ser, &aggnonce) == 1);\n+        CHECK(secp256k1_musig_aggnonce_parse(CTX, &tmp, aggnonce_ser) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &aggnonce, sizeof(tmp)) == 0);\n+    }\n+\n+    /** Process nonces **/\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, NULL, &aggnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, NULL, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, (secp256k1_musig_aggnonce*) &invalid_pubnonce, msg, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, NULL, &keyagg_cache));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &invalid_keyagg_cache));\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session) == 1);\n+    /* The secnonce is set to 0 and subsequent signing attempts fail */\n+    CHECK(secp256k1_memcmp_var(&secnonce_tmp, zeros132, sizeof(secnonce_tmp)) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, NULL, &secnonce_tmp, &keypair[0], &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], NULL, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &invalid_secnonce, &keypair[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, NULL, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &invalid_keypair, &keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    {\n+        unsigned char sk_tmp[32];\n+        secp256k1_keypair keypair_tmp;\n+        testrand256(sk_tmp);\n+        CHECK(secp256k1_keypair_create(CTX, &keypair_tmp, sk_tmp));\n+        CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair_tmp, &keyagg_cache, &session));\n+        memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], NULL, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &invalid_keyagg_cache, &session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, NULL));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce_tmp, &keypair[0], &keyagg_cache, &invalid_session));\n+    memcpy(&secnonce_tmp, &secnonce[0], sizeof(secnonce_tmp));\n+\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[0], &secnonce[0], &keypair[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[1], &secnonce[1], &keypair[1], &keyagg_cache, &session) == 1);\n+\n+    CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, NULL, &partial_sig[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_serialize(CTX, buf, &invalid_partial_sig));\n+    CHECK(secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], buf) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, NULL, buf));\n+    {\n+        /* Check that parsing failure results in an invalid sig */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, max64) == 0);\n+        CHECK(secp256k1_memcmp_var(&tmp, zeros132, sizeof(partial_sig[0])) == 0);\n+    }\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_parse(CTX, &partial_sig[0], NULL));\n+\n+    {\n+        /* Check that serialize and parse results in the same value */\n+        secp256k1_musig_partial_sig tmp;\n+        CHECK(secp256k1_musig_partial_sig_serialize(CTX, buf, &partial_sig[0]) == 1);\n+        CHECK(secp256k1_musig_partial_sig_parse(CTX, &tmp, buf) == 1);\n+        CHECK(secp256k1_memcmp_var(&tmp, &partial_sig[0], sizeof(tmp)) == 0);\n+    }\n+\n+    /** Partial signature verification */\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 0);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, NULL, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &invalid_partial_sig, &pubnonce[0], &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], NULL, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &invalid_pubnonce, &pk[0], &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], NULL, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &invalid_pk, &keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], NULL, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &invalid_keyagg_cache, &session));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &invalid_session));\n+\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[0], &pubnonce[0], &pk[0], &keyagg_cache, &session) == 1);\n+    CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[1], &pubnonce[1], &pk[1], &keyagg_cache, &session) == 1);\n+\n+    /** Signature aggregation and verification */\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, NULL, &session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, NULL, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &invalid_session, partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, NULL, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, invalid_partial_sig_ptr, 2));\n+    CHECK_ILLEGAL(CTX, secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 0));\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 1) == 1);\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, pre_sig, &session, partial_sig_ptr, 2) == 1);\n+}\n+\n+static void musig_nonce_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    secp256k1_scalar k1[2], k2[2];\n+\n+    secp256k1_nonce_function_musig(k1, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    testrand_flip(args[n_flip], n_bytes);\n+    secp256k1_nonce_function_musig(k2, args[0], args[1], args[2], args[3], args[4], args[5]);\n+    CHECK(secp256k1_scalar_eq(&k1[0], &k2[0]) == 0);\n+    CHECK(secp256k1_scalar_eq(&k1[1], &k2[1]) == 0);\n+}\n+\n+static void musig_nonce_test(void) {\n+    unsigned char *args[6];\n+    unsigned char session_secrand[32];\n+    unsigned char sk[32];\n+    unsigned char pk[33];\n+    unsigned char msg[32];\n+    unsigned char agg_pk[32];\n+    unsigned char extra_input[32];\n+    int i, j;\n+    secp256k1_scalar k[6][2];\n+\n+    testrand_bytes_test(session_secrand, sizeof(session_secrand));\n+    testrand_bytes_test(sk, sizeof(sk));\n+    testrand_bytes_test(pk, sizeof(pk));\n+    testrand_bytes_test(msg, sizeof(msg));\n+    testrand_bytes_test(agg_pk, sizeof(agg_pk));\n+    testrand_bytes_test(extra_input, sizeof(extra_input));\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = session_secrand;\n+    args[1] = msg;\n+    args[2] = sk;\n+    args[3] = pk;\n+    args[4] = agg_pk;\n+    args[5] = extra_input;\n+    for (i = 0; i < COUNT; i++) {\n+        musig_nonce_bitflip(args, 0, sizeof(session_secrand));\n+        musig_nonce_bitflip(args, 1, sizeof(msg));\n+        musig_nonce_bitflip(args, 2, sizeof(sk));\n+        musig_nonce_bitflip(args, 3, sizeof(pk));\n+        musig_nonce_bitflip(args, 4, sizeof(agg_pk));\n+        musig_nonce_bitflip(args, 5, sizeof(extra_input));\n+    }\n+    /* Check that if any argument is NULL, a different nonce is produced than if\n+     * any other argument is NULL. */\n+    memcpy(msg, session_secrand, sizeof(msg));\n+    memcpy(sk, session_secrand, sizeof(sk));\n+    memcpy(pk, session_secrand, sizeof(session_secrand));\n+    memcpy(agg_pk, session_secrand, sizeof(agg_pk));\n+    memcpy(extra_input, session_secrand, sizeof(extra_input));\n+    secp256k1_nonce_function_musig(k[0], args[0], args[1], args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[1], args[0], NULL, args[2], args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[2], args[0], args[1], NULL, args[3], args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[3], args[0], args[1], args[2], NULL, args[4], args[5]);\n+    secp256k1_nonce_function_musig(k[4], args[0], args[1], args[2], args[3], NULL, args[5]);\n+    secp256k1_nonce_function_musig(k[5], args[0], args[1], args[2], args[3], args[4], NULL);\n+    for (i = 0; i < 6; i++) {\n+        CHECK(!secp256k1_scalar_eq(&k[i][0], &k[i][1]));\n+        for (j = i+1; j < 6; j++) {\n+            CHECK(!secp256k1_scalar_eq(&k[i][0], &k[j][0]));\n+            CHECK(!secp256k1_scalar_eq(&k[i][1], &k[j][1]));\n+        }\n+    }\n+}\n+\n+static void sha256_tag_test_internal(secp256k1_sha256 *sha_tagged, unsigned char *tag, size_t taglen) {\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    test_sha256_eq(&sha, sha_tagged);\n+}\n+\n+/* Checks that the initialized tagged hashes initialized have the expected\n+ * state. */\n+static void sha256_tag_test(void) {\n+    secp256k1_sha256 sha;\n+    {\n+        char tag[11] = \"KeyAgg list\";\n+        secp256k1_musig_keyagglist_sha256(&sha);\n+        sha256_tag_test_internal(&sha, (unsigned char*)tag, sizeof(tag));",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 536,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "7196ac9511a989967c975aba5758a7a407594bc7",
      "in_reply_to_id": 1703186121,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-05T11:44:55Z",
      "updated_at": "2024-08-05T11:44:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1703990709",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703990709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 534,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 536,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705098315",
      "pull_request_review_id": 2220582552,
      "id": 1705098315,
      "node_id": "PRRC_kwDOAP4Jqs5lobxL",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 90,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/pull/1479/commits/2288e8808883556dc27cea6a61f409c08f70b30d:\r\n\r\nnit: took me a second to mentally parse this function since the variable name is singular (ge), but it really is two group elements. Not a big deal since this is an internal function, but I think it would be more clear if the variable name were something like `ges` or `two_ges`. There are several other places where an array of `secp256k1_ge` objects is referred to as just `ge`, would be nice to make them all plural if you end up taking this suggestion.",
      "created_at": "2024-08-06T08:07:52Z",
      "updated_at": "2024-08-06T08:37:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1705098315",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705098315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705109194",
      "pull_request_review_id": 2220582552,
      "id": 1705109194,
      "node_id": "PRRC_kwDOAP4Jqs5loebK",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {",
      "path": "src/modules/musig/session_impl.h",
      "position": 567,
      "original_position": 550,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in https://github.com/bitcoin-core/secp256k1/pull/1479/commits/2288e8808883556dc27cea6a61f409c08f70b30d:\r\n\r\nnit: same feedback regarding singular vs plural:\r\n\r\n```suggestion\r\nstatic void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonces, const unsigned char *agg_pk32, const unsigned char *msg) {\r\n```",
      "created_at": "2024-08-06T08:16:07Z",
      "updated_at": "2024-08-06T08:37:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1705109194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705109194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 567,
      "original_line": 567,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731032550",
      "pull_request_review_id": 2260334844,
      "id": 1731032550,
      "node_id": "PRRC_kwDOAP4Jqs5nLXXm",
      "diff_hunk": "@@ -11,6 +11,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n #### Added\n  - Added usage example for an ElligatorSwift key exchange.\n+ - New module `musig` implements the MuSig2 multisignature scheme according to the [BIP 327 specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki). See:\n+   - Header file `include/secp256k1_musig.h` which defines the new API.\n+   - Document `doc/musig.md` for further notes on API usage.\n+   - Usage example `examples/musig.c`.",
      "path": "CHANGELOG.md",
      "position": 8,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this should be moved up to the \"Unreleased\" section now",
      "created_at": "2024-08-26T10:17:08Z",
      "updated_at": "2024-08-26T15:10:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1731032550",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731032550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 11,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731139707",
      "pull_request_review_id": 2260334844,
      "id": 1731139707,
      "node_id": "PRRC_kwDOAP4Jqs5nLxh7",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 12,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: no field element type is used in this header, so could remove this include\r\n```suggestion\r\n```",
      "created_at": "2024-08-26T12:02:06Z",
      "updated_at": "2024-08-26T15:10:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1731139707",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731139707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731398318",
      "pull_request_review_id": 2260334844,
      "id": 1731398318,
      "node_id": "PRRC_kwDOAP4Jqs5nMwqu",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_gej aggnoncej[2];\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg);\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pt, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pk);\n+    secp256k1_scalar_mul(&sk, &sk, &mu);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_scalar_negate(&k[0], &k[0]);\n+        secp256k1_scalar_negate(&k[1], &k[1]);\n+    }\n+\n+    /* Sign */\n+    secp256k1_scalar_mul(&s, &session_i.challenge, &sk);\n+    secp256k1_scalar_mul(&k[1], &session_i.noncecoef, &k[1]);\n+    secp256k1_scalar_add(&k[0], &k[0], &k[1]);\n+    secp256k1_scalar_add(&s, &s, &k[0]);\n+    secp256k1_musig_partial_sig_save(partial_sig, &s);\n+    secp256k1_musig_partial_sign_clear(&sk, k);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_verify(const secp256k1_context* ctx, const secp256k1_musig_partial_sig *partial_sig, const secp256k1_musig_pubnonce *pubnonce, const secp256k1_pubkey *pubkey, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    secp256k1_scalar mu, e, s;\n+    secp256k1_gej pkj;\n+    secp256k1_ge nonce_pt[2];\n+    secp256k1_gej rj;\n+    secp256k1_gej tmp;\n+    secp256k1_ge pkp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(pubnonce != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+\n+    /* Compute \"effective\" nonce rj = aggnonce[0] + b*aggnonce[1] */\n+    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + aggnonce[0] + b*aggnonce[1] */\n+    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\n+        return 0;\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 736,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "comment nit in function `secp256k1_musig_partial_sig_verify`: IIUC, the effective nonce here is computed from the individual signer's public nonce points, not the aggregated ones (the latter we could just fetch from the session instance), according to https://github.com/bitcoin/bips/blob/97012a82064c7247df502a170c03b053825cdd15/bip-0327.mediawiki?plain=1#L497-L499\r\n```suggestion\r\n    /* Compute \"effective\" nonce rj = pubnonce[0] + b*pubnonce[1] */\r\n    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + pubnonce[0] + b*pubnonce[1] */\r\n    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\r\n        return 0;\r\n    }\r\n```",
      "created_at": "2024-08-26T15:10:17Z",
      "updated_at": "2024-08-26T15:10:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1731398318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1731398318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 732,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1736066713",
      "pull_request_review_id": 2268502508,
      "id": 1736066713,
      "node_id": "PRRC_kwDOAP4Jqs5nekaZ",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the aggregate nonce and creates a session that is required for signing\n+ *  and verification of partial signatures.\n+ *\n+ *  Returns: 0 if the arguments are invalid or if some signer sent invalid\n+ *           pubnonces, 1 otherwise",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 458,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in the `secp256k1_musig_nonce_process` API description: should the \"some signer...\" part be removed, as suggested in secp256k1-zkp (https://github.com/BlockstreamResearch/secp256k1-zkp/pull/189)? seems like the \"sent invalid pubnonce\" case would have already been caught previously by the nonce aggregation function\r\n```suggestion\r\n *  Returns: 0 if the arguments are invalid, 1 otherwise\r\n```",
      "created_at": "2024-08-29T11:56:44Z",
      "updated_at": "2024-08-29T11:56:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1736066713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1736066713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 457,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 458,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1736202145",
      "pull_request_review_id": 2268737645,
      "id": 1736202145,
      "node_id": "PRRC_kwDOAP4Jqs5nfFeh",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_gej aggnoncej[2];\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg);\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 576,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: this line shouldn't be needed, as `fin_nonce_ptj` is overwritten in the next line anyways\r\n```suggestion\r\n```\r\nfwiw, out of curiosity I tried deduplicating the calculation of $R = R1 + b*R2$ (needed both for calculating the final nonce in `_musig_nonce_process` and for the \"effective\" nonce in the partial sig verification `_musig_partial_sig_verify`) on the following branch: https://github.com/theStack/secp256k1/commit/419c05cce03b2b719fcdc86f734f86a87953bdf1\r\nNot sure if its worth it to pick this up, but if yes, it probably needs a better name for the helper function 😅 ",
      "created_at": "2024-08-29T13:22:53Z",
      "updated_at": "2024-08-29T13:22:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1736202145",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1736202145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739901289",
      "pull_request_review_id": 2274122260,
      "id": 1739901289,
      "node_id": "PRRC_kwDOAP4Jqs5ntMlp",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;",
      "path": "include/secp256k1_musig.h",
      "position": 98,
      "original_position": 97,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "in_reply_to_id": null,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's unclear to me if these structs have any alignment needs. On the surface it looks like they don't but that might make the performance worse on some architectures? If it's not the case then it could be still nice to explicitly say they are unaligned in the doc. If it's the case maybe instead align them and say it in the doc?",
      "created_at": "2024-08-31T18:27:13Z",
      "updated_at": "2024-08-31T18:27:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1739901289",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739901289"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 98,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739942807",
      "pull_request_review_id": 2274163355,
      "id": 1739942807,
      "node_id": "PRRC_kwDOAP4Jqs5ntWuX",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;",
      "path": "include/secp256k1_musig.h",
      "position": 98,
      "original_position": 97,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "in_reply_to_id": 1739901289,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, I don't see how anyone could get the idea that any type in a public header would have stricter alignment than what C anyway requires (unless otherwise specified in the header, of course). And The implied alignment is 1 in this case.\r\n\r\nAs far as I remember, we \"read\" from these char arrays into our internal data structures (the performance penalty is probably negligible), and so alignment shouldn't matter for performance either. ",
      "created_at": "2024-09-01T00:52:32Z",
      "updated_at": "2024-09-01T00:52:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1739942807",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739942807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 98,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739991601",
      "pull_request_review_id": 2274225550,
      "id": 1739991601,
      "node_id": "PRRC_kwDOAP4Jqs5ntiox",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;",
      "path": "include/secp256k1_musig.h",
      "position": 98,
      "original_position": 97,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "5dccc7b4578fb583df60290fc363220cbacb7a03",
      "in_reply_to_id": 1739901289,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Someone coming from Rust and being paranoid about everything. :D Thanks for clarifying, though I think a documentation comment would still be nice.",
      "created_at": "2024-09-01T07:12:19Z",
      "updated_at": "2024-09-01T07:12:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1739991601",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1739991601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 98,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208066",
      "pull_request_review_id": 2276095523,
      "id": 1741208066,
      "node_id": "PRRC_kwDOAP4Jqs5nyLoC",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 90,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1705098315,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, I should have replaced all the singulars with plurals.",
      "created_at": "2024-09-02T19:09:26Z",
      "updated_at": "2024-09-02T19:09:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208205",
      "pull_request_review_id": 2276095757,
      "id": 1741208205,
      "node_id": "PRRC_kwDOAP4Jqs5nyLqN",
      "diff_hunk": "@@ -11,6 +11,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n #### Added\n  - Added usage example for an ElligatorSwift key exchange.\n+ - New module `musig` implements the MuSig2 multisignature scheme according to the [BIP 327 specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki). See:\n+   - Header file `include/secp256k1_musig.h` which defines the new API.\n+   - Document `doc/musig.md` for further notes on API usage.\n+   - Usage example `examples/musig.c`.",
      "path": "CHANGELOG.md",
      "position": 8,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1731032550,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, done!",
      "created_at": "2024-09-02T19:09:51Z",
      "updated_at": "2024-09-02T19:09:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 11,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208267",
      "pull_request_review_id": 2276095822,
      "id": 1741208267,
      "node_id": "PRRC_kwDOAP4Jqs5nyLrL",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../field.h\"",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 12,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1731139707,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-02T19:09:57Z",
      "updated_at": "2024-09-02T19:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208267",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208333",
      "pull_request_review_id": 2276095920,
      "id": 1741208333,
      "node_id": "PRRC_kwDOAP4Jqs5nyLsN",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_gej aggnoncej[2];\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg);\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);\n+    secp256k1_ecmult(&fin_nonce_ptj, &aggnoncej[1], b, NULL);\n+    secp256k1_gej_add_ge_var(&fin_nonce_ptj, &fin_nonce_ptj, &aggnonce[0], NULL);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pt[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pt, aggnonce)) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pt, agg_pk32, msg32)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */\n+    secp256k1_musig_keyaggcoef(&mu, &cache_i, &pk);\n+    secp256k1_scalar_mul(&sk, &sk, &mu);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    if (session_i.fin_nonce_parity) {\n+        secp256k1_scalar_negate(&k[0], &k[0]);\n+        secp256k1_scalar_negate(&k[1], &k[1]);\n+    }\n+\n+    /* Sign */\n+    secp256k1_scalar_mul(&s, &session_i.challenge, &sk);\n+    secp256k1_scalar_mul(&k[1], &session_i.noncecoef, &k[1]);\n+    secp256k1_scalar_add(&k[0], &k[0], &k[1]);\n+    secp256k1_scalar_add(&s, &s, &k[0]);\n+    secp256k1_musig_partial_sig_save(partial_sig, &s);\n+    secp256k1_musig_partial_sign_clear(&sk, k);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_verify(const secp256k1_context* ctx, const secp256k1_musig_partial_sig *partial_sig, const secp256k1_musig_pubnonce *pubnonce, const secp256k1_pubkey *pubkey, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    secp256k1_scalar mu, e, s;\n+    secp256k1_gej pkj;\n+    secp256k1_ge nonce_pt[2];\n+    secp256k1_gej rj;\n+    secp256k1_gej tmp;\n+    secp256k1_ge pkp;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(pubnonce != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_musig_session_load(ctx, &session_i, session)) {\n+        return 0;\n+    }\n+\n+    /* Compute \"effective\" nonce rj = aggnonce[0] + b*aggnonce[1] */\n+    /* TODO: use multiexp to compute -s*G + e*mu*pubkey + aggnonce[0] + b*aggnonce[1] */\n+    if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonce)) {\n+        return 0;\n+    }",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 736,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1731398318,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, done.",
      "created_at": "2024-09-02T19:10:07Z",
      "updated_at": "2024-09-02T19:10:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 732,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208566",
      "pull_request_review_id": 2276096230,
      "id": 1741208566,
      "node_id": "PRRC_kwDOAP4Jqs5nyLv2",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the aggregate nonce and creates a session that is required for signing\n+ *  and verification of partial signatures.\n+ *\n+ *  Returns: 0 if the arguments are invalid or if some signer sent invalid\n+ *           pubnonces, 1 otherwise",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 458,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1736066713,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, forgot about that. We can even make the type of nonce_process_internal  void.",
      "created_at": "2024-09-02T19:10:42Z",
      "updated_at": "2024-09-02T19:10:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208566",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 457,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 458,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208713",
      "pull_request_review_id": 2276096440,
      "id": 1741208713,
      "node_id": "PRRC_kwDOAP4Jqs5nyLyJ",
      "diff_hunk": "@@ -0,0 +1,801 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ge[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ge[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ge) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ge[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ge[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ge[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ge[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ge[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ge[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ge);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ge[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ge, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ge[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pt[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pt[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pt[i], sizeof(nonce_pt));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* nonce_pt won't be infinity because k != 0 with overwhelming probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pt);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_nonces[0]);\n+    secp256k1_gej_set_infinity(&summed_nonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pt[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pt, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_nonces[j], &summed_nonces[j], &nonce_pt[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptj[2];\n+    secp256k1_ge aggnonce_pt[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_nonces(ctx, aggnonce_ptj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pt[i], &aggnonce_ptj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pt);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+static int secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+    secp256k1_gej aggnoncej[2];\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce, agg_pk32, msg);\n+    secp256k1_gej_set_ge(&aggnoncej[0], &aggnonce[0]);\n+    secp256k1_gej_set_ge(&aggnoncej[1], &aggnonce[1]);\n+    /* fin_nonce = aggnonce[0] + b*aggnonce[1] */\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    secp256k1_gej_set_infinity(&fin_nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 576,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "2288e8808883556dc27cea6a61f409c08f70b30d",
      "in_reply_to_id": 1736202145,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, done. Also added your helper function.",
      "created_at": "2024-09-02T19:11:05Z",
      "updated_at": "2024-09-02T19:11:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741208713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741208713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741694956",
      "pull_request_review_id": 2276830666,
      "id": 1741694956,
      "node_id": "PRRC_kwDOAP4Jqs5n0Cfs",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wouldn't it be better to declare this as `const unsigned char (*in66)[66]`? Aside from clarity it could help static analysis tools or perhaps bindings generators to generate correct bindings.",
      "created_at": "2024-09-03T08:59:10Z",
      "updated_at": "2024-09-03T08:59:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1741694956",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1741694956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1742107578",
      "pull_request_review_id": 2277518593,
      "id": 1742107578,
      "node_id": "PRRC_kwDOAP4Jqs5n1nO6",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's an interesting point. Right now, we consistently use declarations of the form `const unsigned char *in66` consistently in the library. I prefer to have a standard across the whole API and would avoid just changing this in the musig module.",
      "created_at": "2024-09-03T13:53:40Z",
      "updated_at": "2024-09-03T13:53:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1742107578",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1742107578"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1742257815",
      "pull_request_review_id": 2277769019,
      "id": 1742257815,
      "node_id": "PRRC_kwDOAP4Jqs5n2L6X",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That makes sense. Might be nice to change all of them at some point unless there's a problem I'm missing.",
      "created_at": "2024-09-03T15:20:21Z",
      "updated_at": "2024-09-03T15:20:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1742257815",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1742257815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1744349109",
      "pull_request_review_id": 2281135436,
      "id": 1744349109,
      "node_id": "PRRC_kwDOAP4Jqs5n-Ke1",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You cannot pass arrays as arguments in C; they collapse into pointers. The syntax\r\n\r\n```\r\nint some_func(char c[32]) {\r\n    ...\r\n}\r\n```\r\n\r\nis for all intents and purposes equivalent to `int some_func(char *c) { ...}`, including the fact that `sizeof(c)` will be 4 or 8 bytes (same as `sizeof(char*)`). Because it is so confusing, it's generally considered misleading to use arrays as arguments in C code.\r\n\r\nEDIT: Oh, you're not suggesting this, but `int some_func(char (*c)[32])` instead. That does work, and equivalent after compilation, but it does mean an additional `&` at the caller, and an additional `*` inside the callee. Can you elaborate on the (potential) advantages for static analysis or binding generators?",
      "created_at": "2024-09-04T20:04:28Z",
      "updated_at": "2024-09-04T20:13:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1744349109",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1744349109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1745926896",
      "pull_request_review_id": 2283697585,
      "id": 1745926896,
      "node_id": "PRRC_kwDOAP4Jqs5oELrw",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For instance in Rust we have [`bindgen`](https://crates.io/crates/bindgen), a tool that generates bindings automatically. I've tried to pass it this header file:\r\n\r\n```c\r\nvoid foo(const unsigned char *arg);\r\nvoid bar(const unsigned char arg[32]);\r\nvoid baz(const unsigned char (*arg)[32]);\r\n```\r\n\r\nAnd it generated this code:\r\n\r\n```rust\r\nextern \"C\" {\r\n    pub fn foo(arg: *const ::std::os::raw::c_uchar);\r\n}\r\nextern \"C\" {\r\n    pub fn bar(arg: *const ::std::os::raw::c_uchar);\r\n}\r\nextern \"C\" {\r\n    pub fn baz(arg: *const [::std::os::raw::c_uchar; 32usize]);\r\n}\r\n```\r\n\r\nAs you can see, the last one has a different type. And while it's the same from ABI perspective, there's a real difference between them in Rust since you can directly pass in `&array` without any casts because the types match making the code more obviously correct.\r\n\r\nCurrently, we aren't using `bidgen` in rust-secp256k1 but we might in the future and I'd be surprised if similar tools don't exist in other languages.\r\n\r\nAlso I'm not familiar with the current state of static analysis in C but I think a reasonable static analyzer should be able to see that statements like `out[33] = 42` or `baz(&twentyone_item_array)` are obviously wrong. `gcc` already complains about the these when compiling with `-O2 -W -Wall -Warray-bounds`. ",
      "created_at": "2024-09-05T17:34:56Z",
      "updated_at": "2024-09-05T17:34:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1745926896",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1745926896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1746369787",
      "pull_request_review_id": 2284405408,
      "id": 1746369787,
      "node_id": "PRRC_kwDOAP4Jqs5oF3z7",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting!\r\n\r\nIt's unfortunate that it's an API break to introduce this (but indeed not an ABI break, I think).",
      "created_at": "2024-09-06T01:28:46Z",
      "updated_at": "2024-09-06T01:28:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1746369787",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1746369787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1746487077",
      "pull_request_review_id": 2284651600,
      "id": 1746487077,
      "node_id": "PRRC_kwDOAP4Jqs5oGUcl",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66",
      "path": "include/secp256k1_musig.h",
      "position": 110,
      "original_position": 109,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1741694956,
      "user": {
        "login": "Kixunil",
        "id": 1178779,
        "node_id": "MDQ6VXNlcjExNzg3Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kixunil",
        "html_url": "https://github.com/Kixunil",
        "followers_url": "https://api.github.com/users/Kixunil/followers",
        "following_url": "https://api.github.com/users/Kixunil/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kixunil/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kixunil/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions",
        "organizations_url": "https://api.github.com/users/Kixunil/orgs",
        "repos_url": "https://api.github.com/users/Kixunil/repos",
        "events_url": "https://api.github.com/users/Kixunil/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kixunil/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, I found that `bindgen` has an option to generate `*const [c_uchar; 32]` instead of `*const c_uchar` for arguments defined as `const unsigned char arg[32]`, so maybe even that is already valuable? (IIUC not API-breaking) I think it has documentation value too.\r\n\r\nIt looks like cppcheck is also able to detect mistakes when you use these (I haven't tested but I found a PR that supposedly does it.)",
      "created_at": "2024-09-06T04:13:27Z",
      "updated_at": "2024-09-06T04:20:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1746487077",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1746487077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 110,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747323488",
      "pull_request_review_id": 2286584017,
      "id": 1747323488,
      "node_id": "PRRC_kwDOAP4Jqs5oJgpg",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.\n+\n+## Signing\n+\n+This is covered by `examples/musig.c`.\n+Essentially, the protocol proceeds in the following steps:\n+\n+1. Generate a keypair with `secp256k1_keypair_create` and obtain the public key with `secp256k1_keypair_pub`.\n+2. Call `secp256k1_musig_pubkey_agg` with the pubkeys of all participants.\n+3. Optionally add a (Taproot) tweak with `secp256k1_musig_pubkey_xonly_tweak_add` and a plain tweak with `secp256k1_musig_pubkey_ec_tweak_add`.\n+4. Generate a pair of secret and public nonce with `secp256k1_musig_nonce_gen` and send the public nonce to the other signers.\n+5. Someone (not necessarily the signer) aggregates the public nonce with `secp256k1_musig_nonce_agg` and sends it to the signers.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 36,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: the public nonce**s**.",
      "created_at": "2024-09-06T15:34:22Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747323488",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747323488"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747333504",
      "pull_request_review_id": 2286584017,
      "id": 1747333504,
      "node_id": "PRRC_kwDOAP4Jqs5oJjGA",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.\n+\n+## Signing\n+\n+This is covered by `examples/musig.c`.\n+Essentially, the protocol proceeds in the following steps:\n+\n+1. Generate a keypair with `secp256k1_keypair_create` and obtain the public key with `secp256k1_keypair_pub`.\n+2. Call `secp256k1_musig_pubkey_agg` with the pubkeys of all participants.\n+3. Optionally add a (Taproot) tweak with `secp256k1_musig_pubkey_xonly_tweak_add` and a plain tweak with `secp256k1_musig_pubkey_ec_tweak_add`.\n+4. Generate a pair of secret and public nonce with `secp256k1_musig_nonce_gen` and send the public nonce to the other signers.\n+5. Someone (not necessarily the signer) aggregates the public nonce with `secp256k1_musig_nonce_agg` and sends it to the signers.\n+6. Process the aggregate nonce with `secp256k1_musig_nonce_process`.\n+7. Create a partial signature with `secp256k1_musig_partial_sign`.\n+8. Verify the partial signatures (optional in some scenarios) with `secp256k1_musig_partial_sig_verify`.\n+9. Someone (not necessarily the signer) obtains all partial signatures and aggregates them into the final Schnorr signature using `secp256k1_musig_partial_sig_agg`.\n+\n+The aggregate signature can be verified with `secp256k1_schnorrsig_verify`.\n+\n+Note that steps 1 to 5 can happen before the message to be signed is known to the signers.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it makes sense to stress that the normal (safer) mode is to construct the nonces after the message is known, rather than only pointing out the alternative here.\r\n\r\nSuggested language:\r\n\r\n> Steps 1 through 5 above can happen before or after the message to be signed is known to the signers. Wherever possible, it is recommended to only generate the nonces after the message is known, as it has more defense-in-depth measures, but requires two communication rounds at signing time. The alternative, generating the nonces in a pre-processing step before the message is known, removes those measures, but means signing can happen non-interatively.",
      "created_at": "2024-09-06T15:40:24Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747333504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747333504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747513031",
      "pull_request_review_id": 2286584017,
      "id": 1747513031,
      "node_id": "PRRC_kwDOAP4Jqs5oKO7H",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In case someone has no way around storing session data on disk somewhere, would the recommendation be:\r\n* To store/load the `secnonce` to/from disk (violating rule 3 here, plus risking platform dependence).\r\n* To store/load the `session_secrand32` to/from disk and re-run `secp256k1_musig_nonce_gen` to obtain the same `secnonce` (violating rule 1 here, and duplicating computation).\r\n\r\nI suspect some users will have not have the ability to leave the `secnonce` in volatile memory, so it may be useful to give advice on how to do that (plus reiterate the dangers of not wiping the stored data after signing).",
      "created_at": "2024-09-06T17:52:44Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747513031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747513031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747515236",
      "pull_request_review_id": 2286584017,
      "id": 1747515236,
      "node_id": "PRRC_kwDOAP4Jqs5oKPdk",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If provided, what happens if the `seckey` does not match the `pubkey` argument? (also applies to `secp256k1_musig_nonce_gen_counter`).",
      "created_at": "2024-09-06T17:54:42Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747515236",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747515236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747519096",
      "pull_request_review_id": 2286584017,
      "id": 1747519096,
      "node_id": "PRRC_kwDOAP4Jqs5oKQZ4",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.",
      "path": "include/secp256k1_musig.h",
      "position": 441,
      "original_position": 436,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Worth pointing out what happens when the aggregator misbehaves (presumably, either the partial signatures will be invalid, or the resulting aggregated signature will be invalid)?",
      "created_at": "2024-09-06T17:57:23Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747519096",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747519096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 441,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747527962",
      "pull_request_review_id": 2286584017,
      "id": 1747527962,
      "node_id": "PRRC_kwDOAP4Jqs5oKSka",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 424,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If both `seckey` and `pubkey` are mandatory here, would it make sense to instead take a `secp256k1_keypair` as argument?",
      "created_at": "2024-09-06T18:04:34Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747527962",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747527962"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 424,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747530499",
      "pull_request_review_id": 2286584017,
      "id": 1747530499,
      "node_id": "PRRC_kwDOAP4Jqs5oKTMD",
      "diff_hunk": "@@ -0,0 +1,32 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pks_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 23,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So one could say it actually corresponds to `(1-gacc[v])/2` in the spec?",
      "created_at": "2024-09-06T18:06:19Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747530499",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747530499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747534666",
      "pull_request_review_id": 2286584017,
      "id": 1747534666,
      "node_id": "PRRC_kwDOAP4Jqs5oKUNK",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 79,
      "original_position": 79,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe call the argument `pks_hash32` (following the style of putting the size of array pointers in the name).",
      "created_at": "2024-09-06T18:10:05Z",
      "updated_at": "2024-09-06T18:13:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1747534666",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1747534666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 79,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756988125",
      "pull_request_review_id": 2300501814,
      "id": 1756988125,
      "node_id": "PRRC_kwDOAP4Jqs5ouYLd",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.\n+\n+## Signing\n+\n+This is covered by `examples/musig.c`.\n+Essentially, the protocol proceeds in the following steps:\n+\n+1. Generate a keypair with `secp256k1_keypair_create` and obtain the public key with `secp256k1_keypair_pub`.\n+2. Call `secp256k1_musig_pubkey_agg` with the pubkeys of all participants.\n+3. Optionally add a (Taproot) tweak with `secp256k1_musig_pubkey_xonly_tweak_add` and a plain tweak with `secp256k1_musig_pubkey_ec_tweak_add`.\n+4. Generate a pair of secret and public nonce with `secp256k1_musig_nonce_gen` and send the public nonce to the other signers.\n+5. Someone (not necessarily the signer) aggregates the public nonce with `secp256k1_musig_nonce_agg` and sends it to the signers.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 36,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747323488,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-09-12T14:28:34Z",
      "updated_at": "2024-09-12T14:28:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756988125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756988125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756988385",
      "pull_request_review_id": 2300502245,
      "id": 1756988385,
      "node_id": "PRRC_kwDOAP4Jqs5ouYPh",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.\n+\n+## Signing\n+\n+This is covered by `examples/musig.c`.\n+Essentially, the protocol proceeds in the following steps:\n+\n+1. Generate a keypair with `secp256k1_keypair_create` and obtain the public key with `secp256k1_keypair_pub`.\n+2. Call `secp256k1_musig_pubkey_agg` with the pubkeys of all participants.\n+3. Optionally add a (Taproot) tweak with `secp256k1_musig_pubkey_xonly_tweak_add` and a plain tweak with `secp256k1_musig_pubkey_ec_tweak_add`.\n+4. Generate a pair of secret and public nonce with `secp256k1_musig_nonce_gen` and send the public nonce to the other signers.\n+5. Someone (not necessarily the signer) aggregates the public nonce with `secp256k1_musig_nonce_agg` and sends it to the signers.\n+6. Process the aggregate nonce with `secp256k1_musig_nonce_process`.\n+7. Create a partial signature with `secp256k1_musig_partial_sign`.\n+8. Verify the partial signatures (optional in some scenarios) with `secp256k1_musig_partial_sig_verify`.\n+9. Someone (not necessarily the signer) obtains all partial signatures and aggregates them into the final Schnorr signature using `secp256k1_musig_partial_sig_agg`.\n+\n+The aggregate signature can be verified with `secp256k1_schnorrsig_verify`.\n+\n+Note that steps 1 to 5 can happen before the message to be signed is known to the signers.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 44,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747333504,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, improved the wording.",
      "created_at": "2024-09-12T14:28:44Z",
      "updated_at": "2024-09-12T14:28:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756988385",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756988385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756989420",
      "pull_request_review_id": 2300503863,
      "id": 1756989420,
      "node_id": "PRRC_kwDOAP4Jqs5ouYfs",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We don't provide the ability to serialize the secnonce right now, which prevents users from storing/loading from disk. Maybe worth a separate PR?",
      "created_at": "2024-09-12T14:29:19Z",
      "updated_at": "2024-09-12T14:29:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756989420",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756989420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756989789",
      "pull_request_review_id": 2300504433,
      "id": 1756989789,
      "node_id": "PRRC_kwDOAP4Jqs5ouYld",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The musig_nonce_gen functions do not check if the seckey matches the given pubkey.",
      "created_at": "2024-09-12T14:29:33Z",
      "updated_at": "2024-09-12T14:29:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756989789",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756989789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990030",
      "pull_request_review_id": 2300504808,
      "id": 1756990030,
      "node_id": "PRRC_kwDOAP4Jqs5ouYpO",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.",
      "path": "include/secp256k1_musig.h",
      "position": 441,
      "original_position": 436,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747519096,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, done.",
      "created_at": "2024-09-12T14:29:41Z",
      "updated_at": "2024-09-12T14:29:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756990030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 441,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990272",
      "pull_request_review_id": 2300505163,
      "id": 1756990272,
      "node_id": "PRRC_kwDOAP4Jqs5ouYtA",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  the seckey argument to be mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same seckey and nonrepeating_cnt value. For example, this implies\n+ *     that if the same seckey is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *             seckey: the 32-byte secret key that will later be used for signing\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const unsigned char *seckey,",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 424,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747527962,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, makes sense. I implemented that",
      "created_at": "2024-09-12T14:29:49Z",
      "updated_at": "2024-09-12T14:29:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756990272",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 424,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990504",
      "pull_request_review_id": 2300505527,
      "id": 1756990504,
      "node_id": "PRRC_kwDOAP4Jqs5ouYwo",
      "diff_hunk": "@@ -0,0 +1,32 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"../../group.h\"\n+#include \"../../scalar.h\"\n+\n+typedef struct {\n+    secp256k1_ge pk;\n+    /* If there is no \"second\" public key, second_pk is set to the point at\n+     * infinity */\n+    secp256k1_ge second_pk;\n+    unsigned char pks_hash[32];\n+    /* tweak is identical to value tacc[v] in the specification. */\n+    secp256k1_scalar tweak;\n+    /* parity_acc corresponds to gacc[v] in the spec. If gacc[v] is -1,",
      "path": "src/modules/musig/keyagg.h",
      "position": null,
      "original_position": 23,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747530499,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, done.",
      "created_at": "2024-09-12T14:29:56Z",
      "updated_at": "2024-09-12T14:29:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756990504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756990504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756992058",
      "pull_request_review_id": 2300508061,
      "id": 1756992058,
      "node_id": "PRRC_kwDOAP4Jqs5ouZI6",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 79,
      "original_position": 79,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747534666,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we only followed that style for externally facing functions, also in the Schnorr signature and extrakeys module. But it'd be possible to adopt that style and start with the musig module.",
      "created_at": "2024-09-12T14:30:48Z",
      "updated_at": "2024-09-12T14:30:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1756992058",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1756992058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 79,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1757268665",
      "pull_request_review_id": 2300941648,
      "id": 1757268665,
      "node_id": "PRRC_kwDOAP4Jqs5ovcq5",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well they can just store the raw bytes on disk, which works, but risks platform-dependency issues.",
      "created_at": "2024-09-12T17:10:15Z",
      "updated_at": "2024-09-12T17:10:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1757268665",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1757268665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1757270409",
      "pull_request_review_id": 2300943897,
      "id": 1757270409,
      "node_id": "PRRC_kwDOAP4Jqs5ovdGJ",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "But will for example the resulting signature be invalid, or does doing this risk leaking private keys?",
      "created_at": "2024-09-12T17:11:30Z",
      "updated_at": "2024-09-12T17:11:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1757270409",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1757270409"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758509435",
      "pull_request_review_id": 2302597637,
      "id": 1758509435,
      "node_id": "PRRC_kwDOAP4Jqs5o0Ll7",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the wrong public key is provided, signing will fail. This works because the public key is appended to the secnonce output of the `nonce_gen` functions and `partial_sign` will compare this public key with the public key the signer is trying to sign for.\r\n\r\nProviding the optional `seckey` argument is a defense-in-depth measure to strengthen nonce generation against a low entropy `session_secrand` argument. If provided, the `seckey` is simply hashed into the nonce and does not have an effect on whether the resulting signature is valid.\r\n\r\nSo, the idea behind the defense-in-depth measure is that if the `seckey` does correspond to the `pubkey` argument and has high entropy, but the `session_secrand` argument has low entropy (but does not repeat), the generated nonce is secure. On the other hand, if the `seckey` does not match the `pubkey`, nonce generation is only insecure if both the provided `seckey` and `secrand` have low entropy. Providing a wrong `seckey` cannot negatively affect nonce generation as long as `secrand` has enough entropy.",
      "created_at": "2024-09-13T09:20:38Z",
      "updated_at": "2024-09-13T09:20:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1758509435",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758509435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758530160",
      "pull_request_review_id": 2302629278,
      "id": 1758530160,
      "node_id": "PRRC_kwDOAP4Jqs5o0Qpw",
      "diff_hunk": "@@ -7,10 +7,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [Unreleased]\n \n-## [0.5.1] - 2024-08-01\n-\n #### Added\n  - Added usage example for an ElligatorSwift key exchange.",
      "path": "CHANGELOG.md",
      "position": null,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "b6efaa53cc1838cff2995763575ac1bd1d3e87a9",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changelog nit: this line accidentally slipped into the \"Unreleased\" part now, though it was already in the 0.5.1 release",
      "created_at": "2024-09-13T09:32:39Z",
      "updated_at": "2024-09-13T09:32:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1758530160",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758530160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758537268",
      "pull_request_review_id": 2302639170,
      "id": 1758537268,
      "node_id": "PRRC_kwDOAP4Jqs5o0SY0",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we provide the on store/load the secnonce from disk, we should also provide de/serialization functions because our API docs instruct users to not read the raw bytes. I had considered this out of scope for this initial PR because it seems dangerous. Especially since so far no one requested this feature, just \"don't store to disk\" seems to be a sensible answer.\r\n\r\nActually one developer asked me about the missing de/serialization functions for the secnonce but further discussion on their motivation for requesting this revealed that they planned to build a very insecure protocol because they had entirely misunderstood what nonce reuse actually is. In the end they agreed that they should not store the secnonce to disk and changed their implementation accordingly.\r\n\r\nAlso I had hoped that someone would eventually come up with a more clever API that can protect from misuse better than simple de/serialization functions (at least in some cases). But maybe that just doesn't exist.",
      "created_at": "2024-09-13T09:37:25Z",
      "updated_at": "2024-09-13T09:37:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1758537268",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758537268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758554674",
      "pull_request_review_id": 2302670291,
      "id": 1758554674,
      "node_id": "PRRC_kwDOAP4Jqs5o0Woy",
      "diff_hunk": "@@ -7,10 +7,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [Unreleased]\n \n-## [0.5.1] - 2024-08-01\n-\n #### Added\n  - Added usage example for an ElligatorSwift key exchange.",
      "path": "CHANGELOG.md",
      "position": null,
      "original_position": 7,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "b6efaa53cc1838cff2995763575ac1bd1d3e87a9",
      "in_reply_to_id": 1758530160,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":vomiting_face:    ... thanks ... should be fixed for real now",
      "created_at": "2024-09-13T09:48:38Z",
      "updated_at": "2024-09-13T09:49:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1758554674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1758554674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1759333330",
      "pull_request_review_id": 2303852579,
      "id": 1759333330,
      "node_id": "PRRC_kwDOAP4Jqs5o3UvS",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's totally reasonable, but I don't think you have answered my question. If someone is somehow not able to keep everything in volatile memory, they have two (bad) options (store secnonce, or store session_secrand32), and **both** options violate a rule. Which of the two would you, as API and protocol designer, recommend people take?\r\n\r\n\r\n",
      "created_at": "2024-09-13T18:54:27Z",
      "updated_at": "2024-09-13T19:00:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1759333330",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1759333330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1761370580",
      "pull_request_review_id": 2306997436,
      "id": 1761370580,
      "node_id": "PRRC_kwDOAP4Jqs5o_GHU",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If someone really needs to do this right now, then I would probably recommend option 2. In contrast to option 1, if you reuse `session_secrand` but you're signing for a different message or aggregate public key, you're protected.\r\n\r\nOne downside of that method is that `session_secrand` has no \"in-memory protection\", in the sense that the `session_secrand` buffer is not cleared after nonce_generation. We do wipe the `secnonce` after signing. Maybe we should change nonce generation to overwrite the `session_secrand` buffer?",
      "created_at": "2024-09-16T15:23:50Z",
      "updated_at": "2024-09-16T15:23:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1761370580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1761370580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1766728801",
      "pull_request_review_id": 2315364170,
      "id": 1766728801,
      "node_id": "PRRC_kwDOAP4Jqs5pTiRh",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pks[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pks_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pks_hash, pk) where pks_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pks_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 119,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: could move the `sha` instance into the else-branch, as it's only needed there",
      "created_at": "2024-09-19T12:17:59Z",
      "updated_at": "2024-09-19T13:19:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1766728801",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1766728801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1766754586",
      "pull_request_review_id": 2315364170,
      "id": 1766754586,
      "node_id": "PRRC_kwDOAP4Jqs5pToka",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pks[i], SECP256K1_EC_COMPRESSED)) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 87,
      "original_position": 87,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "note for other reviewers: it's intentional to use the public API function for serializing a pubkey here (as opposed to the internal one called `_eckey_pubkey_serialize`, which is faster and used at all other places in the musig module) , as we want to check the validity of the input pubkeys of `secp256k1_musig_pubkey_agg`.",
      "created_at": "2024-09-19T12:36:35Z",
      "updated_at": "2024-09-19T13:19:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1766754586",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1766754586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773215574",
      "pull_request_review_id": 2325041173,
      "id": 1773215574,
      "node_id": "PRRC_kwDOAP4Jqs5psR9W",
      "diff_hunk": "@@ -21,6 +21,7 @@ Features:\n * Optional module for ECDH key exchange.\n * Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n * Optional module for ElligatorSwift key exchange according to [BIP-324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\n+* Optional module for the MuSig2 multi-signature scheme according to [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).",
      "path": "README.md",
      "position": null,
      "original_position": 4,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n* Optional module for the MuSig2 Schnorr multi-signatures according to [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).\r\n```\r\n\r\nbecause it mentions Schnorr then",
      "created_at": "2024-09-24T12:09:33Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773215574",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773215574"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773240310",
      "pull_request_review_id": 2325041173,
      "id": 1773240310,
      "node_id": "PRRC_kwDOAP4Jqs5psX_2",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 275,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  the security of MuSig (for example, by following Taproot BIP 341).\r\n```\r\nfor consistency",
      "created_at": "2024-09-24T12:22:53Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773240310",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773240310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773240728",
      "pull_request_review_id": 2325041173,
      "id": 1773240728,
      "node_id": "PRRC_kwDOAP4Jqs5psYGY",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 230,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  the security of MuSig (for example, by following BIP 32).\r\n```\r\nfor consistency",
      "created_at": "2024-09-24T12:23:12Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773240728",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773240728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773246394",
      "pull_request_review_id": 2325041173,
      "id": 1773246394,
      "node_id": "PRRC_kwDOAP4Jqs5psZe6",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.",
      "path": "include/secp256k1_musig.h",
      "position": 326,
      "original_position": 327,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  2. If the seckey, message or aggregate public key\r\n *     cache is already available at this stage, any of these can be optionally provided, in which case they will\r\n *     be used in the derivation of the nonce and increase\r\n *     misuse-resistance. The extra_input32 argument can be used to provide\r\n *     additional data that does not repeat in normal scenarios, such as the\r\n *     current time.\r\n```\r\nCoherence: \"you know\" vs passive voice. Must fix paragraph formatting.",
      "created_at": "2024-09-24T12:27:05Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773246394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773246394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 322,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": 326,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773250870",
      "pull_request_review_id": 2325041173,
      "id": 1773250870,
      "node_id": "PRRC_kwDOAP4Jqs5psak2",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree that option 2 is better for the reasons mentioned.\r\n\r\n> We do wipe the `secnonce` after signing. Maybe we should change nonce generation to overwrite the `session_secrand` buffer?\r\n\r\nThat sounds reasonable to me.",
      "created_at": "2024-09-24T12:30:19Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773250870",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773250870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773258167",
      "pull_request_review_id": 2325041173,
      "id": 1773258167,
      "node_id": "PRRC_kwDOAP4Jqs5pscW3",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If the wrong public key is provided, signing will fail. This works because the public key is appended to the secnonce output of the `nonce_gen` functions and `partial_sign` will compare this public key with the public key the signer is trying to sign for.\r\n\r\nLet me add that the reason for this (and for the need for a pubkey argument in the first place) is that it prevents a vulnerability that could occur when people sign with tweaked individual keys, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html  (you should remember the story). \r\n\r\n\r\n\r\n",
      "created_at": "2024-09-24T12:35:30Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773258167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773258167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773263034",
      "pull_request_review_id": 2325041173,
      "id": 1773263034,
      "node_id": "PRRC_kwDOAP4Jqs5psdi6",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The docs currently just say \"Returns: 0 if the arguments are invalid and 1 otherwise\" Perhaps we should note that a pubkey/seckey mismatch does not count as invalid, but that it will be caught later during signing.",
      "created_at": "2024-09-24T12:38:13Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773263034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773263034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773265504",
      "pull_request_review_id": 2325041173,
      "id": 1773265504,
      "node_id": "PRRC_kwDOAP4Jqs5pseJg",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set",
      "path": "include/secp256k1_musig.h",
      "position": 292,
      "original_position": 294,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Out:   aggpubkey: pointer to a public key to store the result. Will be set\r\n```\r\nOr `agg_pubkey`, but we also use `aggnonce`.\r\n(the same in the code example a few lines above. If you accept this, you may also want to change it in the example file and in keyagg_impl.h.)",
      "created_at": "2024-09-24T12:39:58Z",
      "updated_at": "2024-09-24T14:03:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773265504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773265504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773318337",
      "pull_request_review_id": 2325041173,
      "id": 1773318337,
      "node_id": "PRRC_kwDOAP4Jqs5psrDB",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in\n+ *  `secp256k1_musig_nonce_gen_counter`) is mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same keypair and nonrepeating_cnt value. For example, this implies\n+ *     that if the same keypair is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same keypair for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *            keypair: keypair of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other keypair.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const secp256k1_keypair *keypair,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  If the aggregator does not compute the aggregate nonce correctly, the final\n+ *  signature will be invalid.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the aggregate nonce and creates a session that is required for signing\n+ *  and verification of partial signatures.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:          ctx: pointer to a context object\n+ *  Out:       session: pointer to a struct to store the session\n+ *  In:       aggnonce: pointer to an aggregate public nonce object that is the\n+ *                      output of musig_nonce_agg\n+ *              msg32:  the 32-byte message to sign\n+ *       keyagg_cache:  pointer to the keyagg_cache that was used to create the\n+ *                      aggregate (and potentially tweaked) pubkey\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_nonce_process(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_session *session,\n+    const secp256k1_musig_aggnonce *aggnonce,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Produces a partial signature\n+ *\n+ *  This function overwrites the given secnonce with zeros and will abort if given a\n+ *  secnonce that is all zeros. This is a best effort attempt to protect against nonce\n+ *  reuse. However, this is of course easily defeated if the secnonce has been\n+ *  copied (or serialized). Remember that nonce reuse will leak the secret key!\n+ *\n+ *  For signing to succeed, the secnonce provided to this function must have\n+ *  been generated for the provided keypair. This means that when signing for a\n+ *  keypair consisting of a seckey and pubkey, the secnonce must have been\n+ *  created by calling musig_nonce_gen with that pubkey. Otherwise, the\n+ *  illegal_callback is called.\n+ *\n+ *  This function does not verify the output partial signature, deviating from\n+ *  the BIP 327 specification. It is recommended to verify the output partial\n+ *  signature with `secp256k1_musig_partial_sig_verify` to prevent random or\n+ *  adversarially provoked computation errors.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the provided secnonce has already\n+ *           been used for signing, 1 otherwise\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:  partial_sig: pointer to struct to store the partial signature\n+ *  In/Out:  secnonce: pointer to the secnonce struct created in\n+ *                     musig_nonce_gen that has been never used in a\n+ *                     partial_sign call before and has been created for the\n+ *                     keypair\n+ *  In:       keypair: pointer to keypair to sign the message with\n+ *       keyagg_cache: pointer to the keyagg_cache that was output when the\n+ *                     aggregate public key for this session\n+ *            session: pointer to the session that was created with\n+ *                     musig_nonce_process\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sign(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *partial_sig,\n+    secp256k1_musig_secnonce *secnonce,\n+    const secp256k1_keypair *keypair,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_musig_session *session\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Verifies an individual signer's partial signature\n+ *\n+ *  The signature is verified for a specific signing session. In order to avoid\n+ *  accidentally verifying a signature from a different or non-existing signing\n+ *  session, you must ensure the following:\n+ *    1. The `keyagg_cache` argument is identical to the one used to create the\n+ *       `session` with `musig_nonce_process`.\n+ *    2. The `pubkey` argument must be identical to the one sent by the signer\n+ *       before aggregating it with `musig_pubkey_agg` to create the\n+ *       `keyagg_cache`.\n+ *    3. The `pubnonce` argument must be identical to the one sent by the signer\n+ *       before aggregating it with `musig_nonce_agg` and using the result to\n+ *       create the `session` with `musig_nonce_process`.\n+ *\n+ *  It is not required to call this function in regular MuSig sessions, because\n+ *  if any partial signature does not verify, the final signature will not verify\n+ *  either, so the problem will be caught. But this function allows determining\n+ *  the specific party who produced an invalid signature.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 534,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Certain caveats apply for \"determining the specific party\" (e.g., one need authenticated connections.) Do we want to add a reference to the BIP327 here?\r\n\r\nOr simpler: Rephrase this to \"But this function allows determining which of the partial signatures does not verify.\", which doesn't say that someone produced an invalid signature.",
      "created_at": "2024-09-24T13:11:31Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773318337",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773318337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 533,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 534,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773322436",
      "pull_request_review_id": 2325041173,
      "id": 1773322436,
      "node_id": "PRRC_kwDOAP4Jqs5pssDE",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 79,
      "original_position": 79,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747534666,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we sometimes use it internally, but I don't think it should be a strict rule. And in this case, \"32\" is almost implied by \"hash\" already.  ",
      "created_at": "2024-09-24T13:14:02Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773322436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773322436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 79,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773398783",
      "pull_request_review_id": 2325041173,
      "id": 1773398783,
      "node_id": "PRRC_kwDOAP4Jqs5ps-r_",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 71,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it be preferable to check if `secnonce->data[4..68]` is all zeroes instead? I think it's simpler. (And it's negligible more correct because overflow could also result in a zero scalar.) edit: Hm, okay, we don't have a function for constant-time byte comparison, but we do another of these below (when checking if session_secrand32 is all zeroes.)",
      "created_at": "2024-09-24T13:50:12Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773398783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773398783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773420656",
      "pull_request_review_id": 2325041173,
      "id": 1773420656,
      "node_id": "PRRC_kwDOAP4Jqs5ptEBw",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 515,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nstatic int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\r\n```\r\nperhaps a slightly better name ",
      "created_at": "2024-09-24T14:02:14Z",
      "updated_at": "2024-09-24T14:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773420656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773420656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 515,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773447771",
      "pull_request_review_id": 2325429120,
      "id": 1773447771,
      "node_id": "PRRC_kwDOAP4Jqs5ptKpb",
      "diff_hunk": "@@ -963,4 +963,21 @@ static void secp256k1_ge_from_bytes(secp256k1_ge *r, const unsigned char *buf) {\n     secp256k1_ge_from_storage(r, &s);\n }\n \n+static void secp256k1_ge_to_bytes_ext(unsigned char *data, const secp256k1_ge *ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(data, 0, 64);\n+    } else {\n+        secp256k1_ge_to_bytes(data, ge);\n+    }\n+}\n+\n+static void secp256k1_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data) {\n+    unsigned char zeros[64] = { 0 };",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "12835f80afbd761e198a22fbb01f4d83f72085e2",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`static const`?",
      "created_at": "2024-09-24T14:18:01Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773447771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773447771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773459803",
      "pull_request_review_id": 2325429120,
      "id": 1773459803,
      "node_id": "PRRC_kwDOAP4Jqs5ptNlb",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 10,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: reads a bit unnatural. How about \"that do not apply to single signatures\"?",
      "created_at": "2024-09-24T14:24:51Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773459803",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773459803"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773468572",
      "pull_request_review_id": 2325429120,
      "id": 1773468572,
      "node_id": "PRRC_kwDOAP4Jqs5ptPuc",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 11,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: \"ruling out\" sounds like something a human does when assessing a protocol. How about \"prevent\"?",
      "created_at": "2024-09-24T14:29:29Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773468572",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773468572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773471633",
      "pull_request_review_id": 2325429120,
      "id": 1773471633,
      "node_id": "PRRC_kwDOAP4Jqs5ptQeR",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.",
      "path": "doc/musig.md",
      "position": 25,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(If true) perhaps mention that can be combined and/or invoked multiple times if the setting calls for that?",
      "created_at": "2024-09-24T14:31:15Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773471633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773471633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773501283",
      "pull_request_review_id": 2325429120,
      "id": 1773501283,
      "node_id": "PRRC_kwDOAP4Jqs5ptXtj",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 38,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Worth pointing out (here and elsewhere) that despite being copyable/movable, the encoding is platform- and version-dependent?",
      "created_at": "2024-09-24T14:38:44Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773501283",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773501283"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773549656",
      "pull_request_review_id": 2325429120,
      "id": 1773549656,
      "node_id": "PRRC_kwDOAP4Jqs5ptjhY",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 114,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's only possible that 0 is returned when the API is misused? If so, I think it's better to say \"1 always\" (in the sense that API-compliant callers do not need to care about the return value). Same below.",
      "created_at": "2024-09-24T15:03:08Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773549656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773549656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773553068",
      "pull_request_review_id": 2325429120,
      "id": 1773553068,
      "node_id": "PRRC_kwDOAP4Jqs5ptkWs",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems like a good idea, yes.",
      "created_at": "2024-09-24T15:05:15Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773553068",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773553068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773568228",
      "pull_request_review_id": 2325429120,
      "id": 1773568228,
      "node_id": "PRRC_kwDOAP4Jqs5ptoDk",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 378,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment seems outdated now.",
      "created_at": "2024-09-24T15:14:26Z",
      "updated_at": "2024-09-24T17:13:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1773568228",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1773568228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775877603",
      "pull_request_review_id": 2329346454,
      "id": 1775877603,
      "node_id": "PRRC_kwDOAP4Jqs5p2b3j",
      "diff_hunk": "@@ -0,0 +1,292 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_KEYAGG_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"keyagg.h\"\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+static const unsigned char secp256k1_musig_keyagg_cache_magic[4] = { 0xf4, 0xad, 0xbb, 0xdf };\n+\n+/* A keyagg cache consists of\n+ * - 4 byte magic set during initialization to allow detecting an uninitialized\n+ *   object.\n+ * - 64 byte aggregate (and potentially tweaked) public key\n+ * - 64 byte \"second\" public key (set to the point at infinity if not present)\n+ * - 32 byte hash of all public keys\n+ * - 1 byte the parity of the internal key (if tweaked, otherwise 0)\n+ * - 32 byte tweak\n+ */\n+/* Requires that cache_i->pk is not infinity. */\n+static void secp256k1_keyagg_cache_save(secp256k1_musig_keyagg_cache *cache, const secp256k1_keyagg_cache_internal *cache_i) {\n+    unsigned char *ptr = cache->data;\n+    memcpy(ptr, secp256k1_musig_keyagg_cache_magic, 4);\n+    ptr += 4;\n+    secp256k1_ge_to_bytes(ptr, &cache_i->pk);\n+    ptr += 64;\n+    secp256k1_ge_to_bytes_ext(ptr, &cache_i->second_pk);\n+    ptr += 64;\n+    memcpy(ptr, cache_i->pks_hash, 32);\n+    ptr += 32;\n+    *ptr = cache_i->parity_acc;\n+    ptr += 1;\n+    secp256k1_scalar_get_b32(ptr, &cache_i->tweak);\n+}\n+\n+static int secp256k1_keyagg_cache_load(const secp256k1_context* ctx, secp256k1_keyagg_cache_internal *cache_i, const secp256k1_musig_keyagg_cache *cache) {\n+    const unsigned char *ptr = cache->data;\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_keyagg_cache_magic, 4) == 0);\n+    ptr += 4;\n+    secp256k1_ge_from_bytes(&cache_i->pk, ptr);\n+    ptr += 64;\n+    secp256k1_ge_from_bytes_ext(&cache_i->second_pk, ptr);\n+    ptr += 64;\n+    memcpy(cache_i->pks_hash, ptr, 32);\n+    ptr += 32;\n+    cache_i->parity_acc = *ptr & 1;\n+    ptr += 1;\n+    secp256k1_scalar_set_b32(&cache_i->tweak, ptr, NULL);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg list\")||SHA256(\"KeyAgg list\"). */\n+static void secp256k1_musig_keyagglist_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0xb399d5e0ul;\n+    sha->s[1] = 0xc8fff302ul;\n+    sha->s[2] = 0x6badac71ul;\n+    sha->s[3] = 0x07c5b7f1ul;\n+    sha->s[4] = 0x9701e2eful;\n+    sha->s[5] = 0x2a72ecf8ul;\n+    sha->s[6] = 0x201a4c7bul;\n+    sha->s[7] = 0xab148a38ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Computes pks_hash = tagged_hash(pk[0], ..., pk[np-1]) */\n+static int secp256k1_musig_compute_pks_hash(const secp256k1_context *ctx, unsigned char *pks_hash, const secp256k1_pubkey * const* pks, size_t np) {\n+    secp256k1_sha256 sha;\n+    size_t i;\n+\n+    secp256k1_musig_keyagglist_sha256(&sha);\n+    for (i = 0; i < np; i++) {\n+        unsigned char ser[33];\n+        size_t ser_len = sizeof(ser);\n+        if (!secp256k1_ec_pubkey_serialize(ctx, ser, &ser_len, pks[i], SECP256K1_EC_COMPRESSED)) {\n+            return 0;\n+        }\n+        VERIFY_CHECK(ser_len == sizeof(ser));\n+        secp256k1_sha256_write(&sha, ser, sizeof(ser));\n+    }\n+    secp256k1_sha256_finalize(&sha, pks_hash);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"KeyAgg coefficient\")||SHA256(\"KeyAgg coefficient\"). */\n+static void secp256k1_musig_keyaggcoef_sha256(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+\n+    sha->s[0] = 0x6ef02c5aul;\n+    sha->s[1] = 0x06a480deul;\n+    sha->s[2] = 0x1f298665ul;\n+    sha->s[3] = 0x1d1134f2ul;\n+    sha->s[4] = 0x56a0b063ul;\n+    sha->s[5] = 0x52da4147ul;\n+    sha->s[6] = 0xf280d9d4ul;\n+    sha->s[7] = 0x4484be15ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Compute KeyAgg coefficient which is constant 1 for the second pubkey and\n+ * otherwise tagged_hash(pks_hash, pk) where pks_hash is the hash of public keys.\n+ * second_pk is the point at infinity in case there is no second_pk. Assumes\n+ * that pk is not the point at infinity and that the Y-coordinates of pk and\n+ * second_pk are normalized. */\n+static void secp256k1_musig_keyaggcoef_internal(secp256k1_scalar *r, const unsigned char *pks_hash, secp256k1_ge *pk, const secp256k1_ge *second_pk) {\n+    secp256k1_sha256 sha;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": null,
      "original_position": 119,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1766728801,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-09-25T19:24:01Z",
      "updated_at": "2024-09-25T19:24:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775877603",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775877603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775877864",
      "pull_request_review_id": 2329346840,
      "id": 1775877864,
      "node_id": "PRRC_kwDOAP4Jqs5p2b7o",
      "diff_hunk": "@@ -21,6 +21,7 @@ Features:\n * Optional module for ECDH key exchange.\n * Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n * Optional module for ElligatorSwift key exchange according to [BIP-324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\n+* Optional module for the MuSig2 multi-signature scheme according to [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).",
      "path": "README.md",
      "position": null,
      "original_position": 4,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773215574,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-09-25T19:24:14Z",
      "updated_at": "2024-09-25T19:24:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775877864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775877864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775878129",
      "pull_request_review_id": 2329347330,
      "id": 1775878129,
      "node_id": "PRRC_kwDOAP4Jqs5p2b_x",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 275,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773240310,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:24:21Z",
      "updated_at": "2024-09-25T19:24:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775878129",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775878129"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775878575",
      "pull_request_review_id": 2329348047,
      "id": 1775878575,
      "node_id": "PRRC_kwDOAP4Jqs5p2cGv",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 230,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773240728,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:24:26Z",
      "updated_at": "2024-09-25T19:24:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775878575",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775878575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775879136",
      "pull_request_review_id": 2329348810,
      "id": 1775879136,
      "node_id": "PRRC_kwDOAP4Jqs5p2cPg",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.",
      "path": "include/secp256k1_musig.h",
      "position": 326,
      "original_position": 327,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773246394,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:24:32Z",
      "updated_at": "2024-09-25T19:24:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775879136",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775879136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 322,
      "original_start_line": 323,
      "start_side": "RIGHT",
      "line": 326,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775883200",
      "pull_request_review_id": 2329354514,
      "id": 1775883200,
      "node_id": "PRRC_kwDOAP4Jqs5p2dPA",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if",
      "path": "include/secp256k1_musig.h",
      "position": 347,
      "original_position": 345,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747515236,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Perhaps we should note that a pubkey/seckey mismatch does not count as invalid, but that it will be caught later during signing.\r\n\r\nI added a sentence, but it may be confusing. A pubkey/seckey mismatch in nonce generation may not be caught during signing, because the signer can still provide the correct seckey for signing.",
      "created_at": "2024-09-25T19:25:52Z",
      "updated_at": "2024-09-25T19:25:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775883200",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775883200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 347,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775890562",
      "pull_request_review_id": 2329364877,
      "id": 1775890562,
      "node_id": "PRRC_kwDOAP4Jqs5p2fCC",
      "diff_hunk": "@@ -0,0 +1,579 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility",
      "path": "include/secp256k1_musig.h",
      "position": 327,
      "original_position": 328,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "52cd8e0a7a41210e94ac5e4dd484b255e326a2df",
      "in_reply_to_id": 1747513031,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. The secrand buffer is invalidated whenever nonce_gen returns 1. The alternative is to invalidate whenever a session_secrand argument is given, which is a tiny bit more tedious to test and document. Anyway, if nonce_gen returns 0, then the secnonce is invalid as well, so reusing the secrand buffer in that case is not an issue.",
      "created_at": "2024-09-25T19:28:40Z",
      "updated_at": "2024-09-25T19:28:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775890562",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775890562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775890836",
      "pull_request_review_id": 2329365331,
      "id": 1775890836,
      "node_id": "PRRC_kwDOAP4Jqs5p2fGU",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in\n+ *  `secp256k1_musig_nonce_gen_counter`) is mandatory.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. The nonrepeating_cnt argument must be a counter value that never repeats,\n+ *     i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with\n+ *     the same keypair and nonrepeating_cnt value. For example, this implies\n+ *     that if the same keypair is used with `secp256k1_musig_nonce_gen_counter`\n+ *     on multiple devices, none of the devices should have the same counter\n+ *     value as any other device.\n+ *  2. If you already know the message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same keypair for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *   nonrepeating_cnt: the value of a counter as explained above. Must be\n+ *                     unique to this call to secp256k1_musig_nonce_gen.\n+ *            keypair: keypair of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other keypair.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen_counter(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    uint64_t nonrepeating_cnt,\n+    const secp256k1_keypair *keypair,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Aggregates the nonces of all signers into a single nonce\n+ *\n+ *  This can be done by an untrusted party to reduce the communication\n+ *  between signers. Instead of everyone sending nonces to everyone else, there\n+ *  can be one party receiving all nonces, aggregating the nonces with this\n+ *  function and then sending only the aggregate nonce back to the signers.\n+ *\n+ *  If the aggregator does not compute the aggregate nonce correctly, the final\n+ *  signature will be invalid.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:       aggnonce: pointer to an aggregate public nonce object for\n+ *                       musig_nonce_process\n+ *  In:       pubnonces: array of pointers to public nonces sent by the\n+ *                       signers\n+ *          n_pubnonces: number of elements in the pubnonces array. Must be\n+ *                       greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *aggnonce,\n+    const secp256k1_musig_pubnonce * const *pubnonces,\n+    size_t n_pubnonces\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Takes the aggregate nonce and creates a session that is required for signing\n+ *  and verification of partial signatures.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:          ctx: pointer to a context object\n+ *  Out:       session: pointer to a struct to store the session\n+ *  In:       aggnonce: pointer to an aggregate public nonce object that is the\n+ *                      output of musig_nonce_agg\n+ *              msg32:  the 32-byte message to sign\n+ *       keyagg_cache:  pointer to the keyagg_cache that was used to create the\n+ *                      aggregate (and potentially tweaked) pubkey\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_nonce_process(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_session *session,\n+    const secp256k1_musig_aggnonce *aggnonce,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Produces a partial signature\n+ *\n+ *  This function overwrites the given secnonce with zeros and will abort if given a\n+ *  secnonce that is all zeros. This is a best effort attempt to protect against nonce\n+ *  reuse. However, this is of course easily defeated if the secnonce has been\n+ *  copied (or serialized). Remember that nonce reuse will leak the secret key!\n+ *\n+ *  For signing to succeed, the secnonce provided to this function must have\n+ *  been generated for the provided keypair. This means that when signing for a\n+ *  keypair consisting of a seckey and pubkey, the secnonce must have been\n+ *  created by calling musig_nonce_gen with that pubkey. Otherwise, the\n+ *  illegal_callback is called.\n+ *\n+ *  This function does not verify the output partial signature, deviating from\n+ *  the BIP 327 specification. It is recommended to verify the output partial\n+ *  signature with `secp256k1_musig_partial_sig_verify` to prevent random or\n+ *  adversarially provoked computation errors.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the provided secnonce has already\n+ *           been used for signing, 1 otherwise\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:  partial_sig: pointer to struct to store the partial signature\n+ *  In/Out:  secnonce: pointer to the secnonce struct created in\n+ *                     musig_nonce_gen that has been never used in a\n+ *                     partial_sign call before and has been created for the\n+ *                     keypair\n+ *  In:       keypair: pointer to keypair to sign the message with\n+ *       keyagg_cache: pointer to the keyagg_cache that was output when the\n+ *                     aggregate public key for this session\n+ *            session: pointer to the session that was created with\n+ *                     musig_nonce_process\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sign(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *partial_sig,\n+    secp256k1_musig_secnonce *secnonce,\n+    const secp256k1_keypair *keypair,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_musig_session *session\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n+\n+/** Verifies an individual signer's partial signature\n+ *\n+ *  The signature is verified for a specific signing session. In order to avoid\n+ *  accidentally verifying a signature from a different or non-existing signing\n+ *  session, you must ensure the following:\n+ *    1. The `keyagg_cache` argument is identical to the one used to create the\n+ *       `session` with `musig_nonce_process`.\n+ *    2. The `pubkey` argument must be identical to the one sent by the signer\n+ *       before aggregating it with `musig_pubkey_agg` to create the\n+ *       `keyagg_cache`.\n+ *    3. The `pubnonce` argument must be identical to the one sent by the signer\n+ *       before aggregating it with `musig_nonce_agg` and using the result to\n+ *       create the `session` with `musig_nonce_process`.\n+ *\n+ *  It is not required to call this function in regular MuSig sessions, because\n+ *  if any partial signature does not verify, the final signature will not verify\n+ *  either, so the problem will be caught. But this function allows determining\n+ *  the specific party who produced an invalid signature.",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 534,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773318337,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:28:56Z",
      "updated_at": "2024-09-25T19:28:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775890836",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775890836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 533,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 534,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775893916",
      "pull_request_review_id": 2329370531,
      "id": 1775893916,
      "node_id": "PRRC_kwDOAP4Jqs5p2f2c",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 71,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773398783,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I implemented this by creating a `is_zero_array` function in util.h and using it from both places in the musig module. I think this is a bit nicer, because `is_zero_array` is reusable, but the change did not turn out to make the secnonce load function simpler. Maybe you meant something else?",
      "created_at": "2024-09-25T19:31:55Z",
      "updated_at": "2024-09-25T19:31:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775893916",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775893916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894037",
      "pull_request_review_id": 2329370729,
      "id": 1775894037,
      "node_id": "PRRC_kwDOAP4Jqs5p2f4V",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_scalar_is_zero(&k[0]) & secp256k1_scalar_is_zero(&k[1]);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+    unsigned char acc = 0;\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    for (i = 0; i < 32; i++) {\n+        acc |= session_secrand32[i];\n+    }\n+    ret &= !!acc;\n+    memset(&acc, 0, sizeof(acc));\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    return secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_nonces(const secp256k1_context* ctx, secp256k1_gej *summed_nonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 515,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773420656,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:32:02Z",
      "updated_at": "2024-09-25T19:32:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775894037",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 515,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894139",
      "pull_request_review_id": 2329370874,
      "id": 1775894139,
      "node_id": "PRRC_kwDOAP4Jqs5p2f57",
      "diff_hunk": "@@ -963,4 +963,21 @@ static void secp256k1_ge_from_bytes(secp256k1_ge *r, const unsigned char *buf) {\n     secp256k1_ge_from_storage(r, &s);\n }\n \n+static void secp256k1_ge_to_bytes_ext(unsigned char *data, const secp256k1_ge *ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(data, 0, 64);\n+    } else {\n+        secp256k1_ge_to_bytes(data, ge);\n+    }\n+}\n+\n+static void secp256k1_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data) {\n+    unsigned char zeros[64] = { 0 };",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "12835f80afbd761e198a22fbb01f4d83f72085e2",
      "in_reply_to_id": 1773447771,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:32:08Z",
      "updated_at": "2024-09-25T19:32:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775894139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894296",
      "pull_request_review_id": 2329371125,
      "id": 1775894296,
      "node_id": "PRRC_kwDOAP4Jqs5p2f8Y",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 10,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773459803,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "improved the wording",
      "created_at": "2024-09-25T19:32:17Z",
      "updated_at": "2024-09-25T19:32:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775894296",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775894296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775895771",
      "pull_request_review_id": 2329373325,
      "id": 1775895771,
      "node_id": "PRRC_kwDOAP4Jqs5p2gTb",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set",
      "path": "include/secp256k1_musig.h",
      "position": 292,
      "original_position": 294,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773265504,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's called `output_pubkey` because that is the terminology we use for BIP 341 tweaking. People don't have that context, so I'm ok with changing it. But if we do, then how about `agg_pk` because that's what we're using currently for the aggregation and get_pubkey functions.",
      "created_at": "2024-09-25T19:33:35Z",
      "updated_at": "2024-09-25T19:33:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775895771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775895771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775896051",
      "pull_request_review_id": 2329373660,
      "id": 1775896051,
      "node_id": "PRRC_kwDOAP4Jqs5p2gXz",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.",
      "path": "doc/musig.md",
      "position": null,
      "original_position": 11,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773468572,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:33:48Z",
      "updated_at": "2024-09-25T19:33:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775896051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775896051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775896146",
      "pull_request_review_id": 2329373814,
      "id": 1775896146,
      "node_id": "PRRC_kwDOAP4Jqs5p2gZS",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+Notes on the musig module API\n+===========================\n+\n+The following sections contain additional notes on the API of the musig module (`include/secp256k1_musig.h`).\n+A usage example can be found in `examples/musig.c`.\n+\n+## API misuse\n+\n+The musig API is designed to be as misuse resistant as possible.\n+However, the MuSig protocol has some additional failure modes (mainly due to interactivity) that do not appear in single-signing.\n+While the results can be catastrophic (e.g. leaking of the secret key), it is unfortunately not possible for the musig implementation to rule out all such failure modes.\n+\n+Therefore, users of the musig module must take great care to make sure of the following:\n+\n+1. A unique nonce per signing session is generated in `secp256k1_musig_nonce_gen`.\n+   See the corresponding comment in `include/secp256k1_musig.h` for how to ensure that.\n+2. The `secp256k1_musig_secnonce` structure is never copied or serialized.\n+   See also the comment on `secp256k1_musig_secnonce` in `include/secp256k1_musig.h`.\n+3. Opaque data structures are never written to or read from directly.\n+   Instead, only the provided accessor functions are used.\n+\n+## Key Aggregation and (Taproot) Tweaking\n+\n+Given a set of public keys, the aggregate public key is computed with `secp256k1_musig_pubkey_agg`.\n+A plain tweak can be added to the resulting public key with `secp256k1_ec_pubkey_tweak_add` by setting the `tweak32` argument to the hash defined in BIP 32. Similarly, a Taproot tweak can be added with `secp256k1_xonly_pubkey_tweak_add` by setting the `tweak32` argument to the TapTweak hash defined in BIP 341.",
      "path": "doc/musig.md",
      "position": 25,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773471633,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-25T19:33:53Z",
      "updated_at": "2024-09-25T19:33:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775896146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775896146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775898232",
      "pull_request_review_id": 2329377236,
      "id": 1775898232,
      "node_id": "PRRC_kwDOAP4Jqs5p2g54",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 38,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773501283,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I moved the \"It can be safely copied/moved.\" to the above general section on opaque data structures; right after the sentence that the representation is platform dependent (which is the same as the doc for the other opaque data structures in the API).",
      "created_at": "2024-09-25T19:36:00Z",
      "updated_at": "2024-09-25T19:36:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775898232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775898232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775899008",
      "pull_request_review_id": 2329378539,
      "id": 1775899008,
      "node_id": "PRRC_kwDOAP4Jqs5p2hGA",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 114,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773549656,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-09-25T19:36:50Z",
      "updated_at": "2024-09-25T19:36:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775899008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775899008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775899186",
      "pull_request_review_id": 2329378814,
      "id": 1775899186,
      "node_id": "PRRC_kwDOAP4Jqs5p2hIy",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 378,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773568228,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Outdated in what way?",
      "created_at": "2024-09-25T19:37:01Z",
      "updated_at": "2024-09-25T19:37:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1775899186",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1775899186"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776103134",
      "pull_request_review_id": 2329705543,
      "id": 1776103134,
      "node_id": "PRRC_kwDOAP4Jqs5p3S7e",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 378,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773568228,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no `seckey` argument anymore.\r\n\r\nEDIT: Ok, it does day \"which is part of the keypair argument in `secp256k1_musig_nonce_gen_counter`\", but that sounds a bit confusing given that this is the documentation for that function.\r\n\r\nWhat about \"This requires that a private key is provided to `secp256k1_musig_nonce_gen_counter` (through the keypair argument), as opposed to `secp256k1_musig_nonce_gen` where the seckey argument is optional.\"?",
      "created_at": "2024-09-25T23:39:41Z",
      "updated_at": "2024-09-26T00:45:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1776103134",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776103134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776816636",
      "pull_request_review_id": 2330825345,
      "id": 1776816636,
      "node_id": "PRRC_kwDOAP4Jqs5p6BH8",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_musig.h>\n+#include <secp256k1_schnorrsig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    /* For BIP 32 tweaking the plain_tweak is set to a hash as defined in BIP\n+     * 32. */\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    /* For Taproot tweaking the xonly_tweak is set to the TapTweak hash as\n+     * defined in BIP 341 */\n+    unsigned char xonly_tweak[32] = \"this could be a Taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing, the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating Taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the Taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+    secp256k1_musig_aggnonce agg_pubnonce;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+\n+        secure_erase(seckey, sizeof(seckey));\n+        secure_erase(session_secrand, sizeof(session_secrand));",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 130,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "96c95bfd3a006451aa686947131c5cef69f4e746",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "with the latest change to `secp256k1_musig_nonce_gen`, this line wouldn't be needed anymore (doesn't hurt to keep it though for demonstrating good practices, I presume)",
      "created_at": "2024-09-26T10:43:13Z",
      "updated_at": "2024-09-26T10:47:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1776816636",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776816636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776879713",
      "pull_request_review_id": 2330928126,
      "id": 1776879713,
      "node_id": "PRRC_kwDOAP4Jqs5p6Qhh",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 378,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773568228,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I like the suggestion, s/private key/secret key is more consistent.",
      "created_at": "2024-09-26T11:32:32Z",
      "updated_at": "2024-09-26T11:32:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1776879713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776879713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776894503",
      "pull_request_review_id": 2330953044,
      "id": 1776894503,
      "node_id": "PRRC_kwDOAP4Jqs5p6UIn",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 32);\n+    is_zero |= secp256k1_is_zero_array(&secnonce->data[36], 32);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 67,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "55d3dc0a70367e5980759db49c4c06101db601b2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is what I meant. :) Yeah, it's not so much simpler, but I think it's an improvement overall.\r\n\r\nIf you want to make it one line simpler, you could do this (not sure if it's better):\r\n```suggestion\r\n    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\r\n```",
      "created_at": "2024-09-26T11:43:00Z",
      "updated_at": "2024-09-26T11:43:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1776894503",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776894503"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776907664",
      "pull_request_review_id": 2330974614,
      "id": 1776907664,
      "node_id": "PRRC_kwDOAP4Jqs5p6XWQ",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set",
      "path": "include/secp256k1_musig.h",
      "position": 292,
      "original_position": 294,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "fdc09608036822afc1cebbe0c5b56cebf8ba508d",
      "in_reply_to_id": 1773265504,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> It's called `output_pubkey` because that is the terminology we use for BIP 341 tweaking. \r\n\r\nOh, sure. Never mind, I mixed things up and thought this is simply the aggregate key. But it's the tweaked aggregate key, so yep, it's better to have a separate name for this, and then output_pk is good.",
      "created_at": "2024-09-26T11:53:42Z",
      "updated_at": "2024-09-26T11:53:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1776907664",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1776907664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777292186",
      "pull_request_review_id": 2331618461,
      "id": 1777292186,
      "node_id": "PRRC_kwDOAP4Jqs5p71Oa",
      "diff_hunk": "@@ -0,0 +1,581 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. If you\n+ *  need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. It can be safely copied/moved. No\n+ *  serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved. Serialized\n+ *  and parsed with `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. It can be safely copied/moved.\n+ *  Serialized and parsed with `musig_aggnonce_serialize` and\n+ *  `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. It can be safely\n+ *  copied/moved. No serialization and parsing functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 when the nonce could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 when the signature could be serialized, 0 otherwise\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig2 (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to secp256k1_ec_seckey_verify, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_xonly_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Starts a signing session by generating a nonce\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  MuSig differs from regular Schnorr signing in that implementers _must_ take\n+ *  special care to not reuse a nonce. This can be ensured by following these rules:\n+ *\n+ *  1. Each call to this function must have a UNIQUE session_secrand32 that must\n+ *     NOT BE REUSED in subsequent calls to this function and must be KEPT\n+ *     SECRET (even from other signers).\n+ *  2. If you already know the seckey, message or aggregate public key\n+ *     cache, they can be optionally provided to derive the nonce and increase\n+ *     misuse-resistance. The extra_input32 argument can be used to provide\n+ *     additional data that does not repeat in normal scenarios, such as the\n+ *     current time.\n+ *  3. Avoid copying (or serializing) the secnonce. This reduces the possibility\n+ *     that it is used more than once for signing.\n+ *\n+ *  If you don't have access to good randomness for session_secrand32, but you\n+ *  have access to a non-repeating counter, then see\n+ *  secp256k1_musig_nonce_gen_counter.\n+ *\n+ *  Remember that nonce reuse will leak the secret key!\n+ *  Note that using the same seckey for multiple MuSig sessions is fine.\n+ *\n+ *  Returns: 0 if the arguments are invalid and 1 otherwise\n+ *  Args:         ctx: pointer to a context object (not secp256k1_context_static)\n+ *  Out:     secnonce: pointer to a structure to store the secret nonce\n+ *           pubnonce: pointer to a structure to store the public nonce\n+ *  In:\n+ *  session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this\n+ *                     call to secp256k1_musig_nonce_gen and must be uniformly random.\n+ *             seckey: the 32-byte secret key that will later be used for signing, if\n+ *                     already known (can be NULL)\n+ *             pubkey: public key of the signer creating the nonce. The secnonce\n+ *                     output of this function cannot be used to sign for any\n+ *                     other public key.\n+ *              msg32: the 32-byte message that will later be signed, if already known\n+ *                     (can be NULL)\n+ *       keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate\n+ *                     (and potentially tweaked) public key if already known\n+ *                     (can be NULL)\n+ *      extra_input32: an optional 32-byte array that is input to the nonce\n+ *                     derivation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_musig_nonce_gen(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_secnonce *secnonce,\n+    secp256k1_musig_pubnonce *pubnonce,\n+    const unsigned char *session_secrand32,\n+    const unsigned char *seckey,\n+    const secp256k1_pubkey *pubkey,\n+    const unsigned char *msg32,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *extra_input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(6);\n+\n+\n+/** Alternative way to generate a nonce and start a signing session\n+ *\n+ *  This function outputs a secret nonce that will be required for signing and a\n+ *  corresponding public nonce that is intended to be sent to other signers.\n+ *\n+ *  This function differs from `secp256k1_musig_nonce_gen` by accepting a\n+ *  non-repeating counter value instead of a secret random value. This requires\n+ *  that the seckey argument (which is part of the keypair argument in",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 378,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "81f1c6ae316054f1f591cce767533a29e5891063",
      "in_reply_to_id": 1773568228,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced the sentence with the suggestion.",
      "created_at": "2024-09-26T15:11:37Z",
      "updated_at": "2024-09-26T15:11:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1777292186",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777292186"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777293245",
      "pull_request_review_id": 2331620125,
      "id": 1777293245,
      "node_id": "PRRC_kwDOAP4Jqs5p71e9",
      "diff_hunk": "@@ -0,0 +1,818 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 32);\n+    is_zero |= secp256k1_is_zero_array(&secnonce->data[36], 32);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 67,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "55d3dc0a70367e5980759db49c4c06101db601b2",
      "in_reply_to_id": 1776894503,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, yes! Replaced the two lines with the suggestion.",
      "created_at": "2024-09-26T15:12:16Z",
      "updated_at": "2024-09-26T15:12:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1777293245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777293245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777295035",
      "pull_request_review_id": 2331623054,
      "id": 1777295035,
      "node_id": "PRRC_kwDOAP4Jqs5p7167",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+/** This file demonstrates how to use the MuSig module to create a\n+ *  3-of-3 multisignature. Additionally, see the documentation in\n+ *  include/secp256k1_musig.h and doc/musig.md.\n+ */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_musig.h>\n+#include <secp256k1_schnorrsig.h>\n+\n+#include \"examples_util.h\"\n+\n+struct signer_secrets {\n+    secp256k1_keypair keypair;\n+    secp256k1_musig_secnonce secnonce;\n+};\n+\n+struct signer {\n+    secp256k1_pubkey pubkey;\n+    secp256k1_musig_pubnonce pubnonce;\n+    secp256k1_musig_partial_sig partial_sig;\n+};\n+\n+ /* Number of public keys involved in creating the aggregate signature */\n+#define N_SIGNERS 3\n+/* Create a key pair, store it in signer_secrets->keypair and signer->pubkey */\n+static int create_keypair(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer) {\n+    unsigned char seckey[32];\n+    while (1) {\n+        if (!fill_random(seckey, sizeof(seckey))) {\n+            printf(\"Failed to generate randomness\\n\");\n+            return 0;\n+        }\n+        if (secp256k1_keypair_create(ctx, &signer_secrets->keypair, seckey)) {\n+            break;\n+        }\n+    }\n+    if (!secp256k1_keypair_pub(ctx, &signer->pubkey, &signer_secrets->keypair)) {\n+        return 0;\n+    }\n+\n+    secure_erase(seckey, sizeof(seckey));\n+    return 1;\n+}\n+\n+/* Tweak the pubkey corresponding to the provided keyagg cache, update the cache\n+ * and return the tweaked aggregate pk. */\n+static int tweak(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *cache) {\n+    secp256k1_pubkey output_pk;\n+    /* For BIP 32 tweaking the plain_tweak is set to a hash as defined in BIP\n+     * 32. */\n+    unsigned char plain_tweak[32] = \"this could be a BIP32 tweak....\";\n+    /* For Taproot tweaking the xonly_tweak is set to the TapTweak hash as\n+     * defined in BIP 341 */\n+    unsigned char xonly_tweak[32] = \"this could be a Taproot tweak..\";\n+\n+\n+    /* Plain tweaking which, for example, allows deriving multiple child\n+     * public keys from a single aggregate key using BIP32 */\n+    if (!secp256k1_musig_pubkey_ec_tweak_add(ctx, NULL, cache, plain_tweak)) {\n+        return 0;\n+    }\n+    /* Note that we did not provide an output_pk argument, because the\n+     * resulting pk is also saved in the cache and so if one is just interested\n+     * in signing, the output_pk argument is unnecessary. On the other hand, if\n+     * one is not interested in signing, the same output_pk can be obtained by\n+     * calling `secp256k1_musig_pubkey_get` right after key aggregation to get\n+     * the full pubkey and then call `secp256k1_ec_pubkey_tweak_add`. */\n+\n+    /* Xonly tweaking which, for example, allows creating Taproot commitments */\n+    if (!secp256k1_musig_pubkey_xonly_tweak_add(ctx, &output_pk, cache, xonly_tweak)) {\n+        return 0;\n+    }\n+    /* Note that if we wouldn't care about signing, we can arrive at the same\n+     * output_pk by providing the untweaked public key to\n+     * `secp256k1_xonly_pubkey_tweak_add` (after converting it to an xonly pubkey\n+     * if necessary with `secp256k1_xonly_pubkey_from_pubkey`). */\n+\n+    /* Now we convert the output_pk to an xonly pubkey to allow to later verify\n+     * the Schnorr signature against it. For this purpose we can ignore the\n+     * `pk_parity` output argument; we would need it if we would have to open\n+     * the Taproot commitment. */\n+    if (!secp256k1_xonly_pubkey_from_pubkey(ctx, agg_pk, NULL, &output_pk)) {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+/* Sign a message hash with the given key pairs and store the result in sig */\n+static int sign(const secp256k1_context* ctx, struct signer_secrets *signer_secrets, struct signer *signer, const secp256k1_musig_keyagg_cache *cache, const unsigned char *msg32, unsigned char *sig64) {\n+    int i;\n+    const secp256k1_musig_pubnonce *pubnonces[N_SIGNERS];\n+    const secp256k1_musig_partial_sig *partial_sigs[N_SIGNERS];\n+    /* The same for all signers */\n+    secp256k1_musig_session session;\n+    secp256k1_musig_aggnonce agg_pubnonce;\n+\n+    for (i = 0; i < N_SIGNERS; i++) {\n+        unsigned char seckey[32];\n+        unsigned char session_secrand[32];\n+        /* Create random session ID. It is absolutely necessary that the session ID\n+         * is unique for every call of secp256k1_musig_nonce_gen. Otherwise\n+         * it's trivial for an attacker to extract the secret key! */\n+        if (!fill_random(session_secrand, sizeof(session_secrand))) {\n+            return 0;\n+        }\n+        if (!secp256k1_keypair_sec(ctx, seckey, &signer_secrets[i].keypair)) {\n+            return 0;\n+        }\n+        /* Initialize session and create secret nonce for signing and public\n+         * nonce to send to the other signers. */\n+        if (!secp256k1_musig_nonce_gen(ctx, &signer_secrets[i].secnonce, &signer[i].pubnonce, session_secrand, seckey, &signer[i].pubkey, msg32, NULL, NULL)) {\n+            return 0;\n+        }\n+        pubnonces[i] = &signer[i].pubnonce;\n+\n+        secure_erase(seckey, sizeof(seckey));\n+        secure_erase(session_secrand, sizeof(session_secrand));",
      "path": "examples/musig.c",
      "position": null,
      "original_position": 130,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "96c95bfd3a006451aa686947131c5cef69f4e746",
      "in_reply_to_id": 1776816636,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch. I removed that line. Imo explicitly erasaing secrand is more overkill than good practice.",
      "created_at": "2024-09-26T15:13:25Z",
      "updated_at": "2024-09-26T15:13:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1777295035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1777295035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1780085082",
      "pull_request_review_id": 2335893606,
      "id": 1780085082,
      "node_id": "PRRC_kwDOAP4Jqs5qGfFa",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }",
      "path": "src/modules/musig/session_impl.h",
      "position": 208,
      "original_position": 205,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "curiosity nit: is this check needed, and if yes, does it make sense to also add it in the aggregate nonce parsing function `_musig_aggnonce_parse`? IIUC, this is only becomes relevant once exhaustive tests are added, and returns always 1 in production (so no big deal if it stays as-is now).",
      "created_at": "2024-09-29T16:45:44Z",
      "updated_at": "2024-09-29T17:14:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1780085082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1780085082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 206,
      "original_start_line": 203,
      "start_side": "RIGHT",
      "line": 208,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781215749",
      "pull_request_review_id": 2337697756,
      "id": 1781215749,
      "node_id": "PRRC_kwDOAP4Jqs5qKzIF",
      "diff_hunk": "@@ -0,0 +1,590 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside the opaque data structures is\n+ *  implementation defined and not guaranteed to be portable between different\n+ *  platforms or versions. With the exception of `secp256k1_musig_secnonce`, the\n+ *  data structures can be safely copied/moved. If you need to convert to a\n+ *  format suitable for storage, transmission, or comparison, use the\n+ *  corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. No serialization and parsing functions\n+ *  (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. Serialized and parsed with\n+ *  `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. Serialized and parsed with\n+ *  `musig_aggnonce_serialize` and `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. No serialization and parsing\n+ *  functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 292,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Depending on the sign of the previous aggregated public key, I believe it is also possible this returns 0 if the tweak equals the corresponding private key?",
      "created_at": "2024-09-30T14:12:08Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781215749",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781215749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781434818",
      "pull_request_review_id": 2337697756,
      "id": 1781434818,
      "node_id": "PRRC_kwDOAP4Jqs5qLonC",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 441,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any given individual linear relation between k0 and k1 is of course practically impossible to reach, but what is the reason for this specific one? BIP327 only seems to suggest tests for k0=0 and k1=0 (in *NonceGen()*).",
      "created_at": "2024-09-30T16:30:13Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781434818",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781434818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781469191",
      "pull_request_review_id": 2337697756,
      "id": 1781469191,
      "node_id": "PRRC_kwDOAP4Jqs5qLxAH",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": 450,
      "original_position": 448,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be nice if this could use batch inversion, but `secp256k1_ge_set_all_gej_var` is variable time (which I don't think is acceptable here?), and a constant-time version would either need a guarantee that neither point is infinity, or some annoying cmov logic to deal with infinities. Perhaps for a follow-up.",
      "created_at": "2024-09-30T16:59:34Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781469191",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781469191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781469801",
      "pull_request_review_id": 2337697756,
      "id": 1781469801,
      "node_id": "PRRC_kwDOAP4Jqs5qLxJp",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 546,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think `secp256k1_ge_set_all_gej_var` is usable here, as the public key inputs are not secret?",
      "created_at": "2024-09-30T17:00:07Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781469801",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781469801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 546,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781482841",
      "pull_request_review_id": 2337697756,
      "id": 1781482841,
      "node_id": "PRRC_kwDOAP4Jqs5qL0VZ",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pts);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+/* out_nonce = nonce_pts[0] + b*nonce_pts[1] */\n+static void secp256k1_effective_nonce(secp256k1_gej *out_nonce, const secp256k1_ge *nonce_pts, const secp256k1_scalar *b) {\n+    secp256k1_gej tmp;\n+\n+    secp256k1_gej_set_ge(&tmp, &nonce_pts[1]);\n+    secp256k1_ecmult(out_nonce, &tmp, b, NULL);\n+    secp256k1_gej_add_ge_var(out_nonce, out_nonce, &nonce_pts[0], NULL);\n+}\n+\n+static void secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce_pts, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce_pts, agg_pk32, msg);\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    /* fin_nonce = aggnonce_pts[0] + b*aggnonce_pts[1] */\n+    secp256k1_effective_nonce(&fin_nonce_ptj, aggnonce_pts, b);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pts[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pts, aggnonce)) {\n+        return 0;\n+    }\n+\n+    secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pts, agg_pk32, msg32);\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 705,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there space in the cache data structure to do this caching? Would it make sense to reserve space for it?",
      "created_at": "2024-09-30T17:08:02Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781482841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781482841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 704,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781560625",
      "pull_request_review_id": 2337697756,
      "id": 1781560625,
      "node_id": "PRRC_kwDOAP4Jqs5qMHUx",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, &keypair[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {",
      "path": "src/modules/musig/tests_impl.h",
      "position": 90,
      "original_position": 89,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add a comment what this function does?",
      "created_at": "2024-09-30T18:11:59Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781560625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781560625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781579367",
      "pull_request_review_id": 2337697756,
      "id": 1781579367,
      "node_id": "PRRC_kwDOAP4Jqs5qML5n",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What is `inttypes.h` needed for?",
      "created_at": "2024-09-30T18:30:02Z",
      "updated_at": "2024-09-30T18:41:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1781579367",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1781579367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1782668307",
      "pull_request_review_id": 2340037688,
      "id": 1782668307,
      "node_id": "PRRC_kwDOAP4Jqs5qQVwT",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781579367,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, it seems that `stdint.h` suffices here",
      "created_at": "2024-10-01T12:20:45Z",
      "updated_at": "2024-10-01T12:20:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1782668307",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1782668307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1786910171",
      "pull_request_review_id": 2346797957,
      "id": 1786910171,
      "node_id": "PRRC_kwDOAP4Jqs5qghXb",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": 450,
      "original_position": 448,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781469191,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`nonce_ptj` is guaranteed not to be infinity here. But I agree, this seems something for a follow-up. ",
      "created_at": "2024-10-03T22:35:14Z",
      "updated_at": "2024-10-03T22:35:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1786910171",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1786910171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789783505",
      "pull_request_review_id": 2351294574,
      "id": 1789783505,
      "node_id": "PRRC_kwDOAP4Jqs5qre3R",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }",
      "path": "src/modules/musig/session_impl.h",
      "position": 208,
      "original_position": 205,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1780085082,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, added it for consistency.\r\n\r\n",
      "created_at": "2024-10-07T08:41:39Z",
      "updated_at": "2024-10-07T08:41:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789783505",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789783505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": 206,
      "original_start_line": 203,
      "start_side": "RIGHT",
      "line": 208,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789783894",
      "pull_request_review_id": 2351295130,
      "id": 1789783894,
      "node_id": "PRRC_kwDOAP4Jqs5qre9W",
      "diff_hunk": "@@ -0,0 +1,590 @@\n+#ifndef SECP256K1_MUSIG_H\n+#define SECP256K1_MUSIG_H\n+\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/** This module implements BIP 327 \"MuSig2 for BIP340-compatible\n+ *  Multi-Signatures\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki)\n+ *  v1.0.0. You can find an example demonstrating the musig module in\n+ *  examples/musig.c.\n+ *\n+ *  The module also supports BIP 341 (\"Taproot\") public key tweaking.\n+ *\n+ *  It is recommended to read the documentation in this include file carefully.\n+ *  Further notes on API usage can be found in doc/musig.md\n+ *\n+ *  Since the first version of MuSig is essentially replaced by MuSig2, we use\n+ *  MuSig, musig and MuSig2 synonymously unless noted otherwise.\n+ */\n+\n+/** Opaque data structures\n+ *\n+ *  The exact representation of data inside the opaque data structures is\n+ *  implementation defined and not guaranteed to be portable between different\n+ *  platforms or versions. With the exception of `secp256k1_musig_secnonce`, the\n+ *  data structures can be safely copied/moved. If you need to convert to a\n+ *  format suitable for storage, transmission, or comparison, use the\n+ *  corresponding serialization and parsing functions.\n+ */\n+\n+/** Opaque data structure that caches information about public key aggregation.\n+ *\n+ *  Guaranteed to be 197 bytes in size. No serialization and parsing functions\n+ *  (yet).\n+ */\n+typedef struct {\n+    unsigned char data[197];\n+} secp256k1_musig_keyagg_cache;\n+\n+/** Opaque data structure that holds a signer's _secret_ nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size.\n+ *\n+ *  WARNING: This structure MUST NOT be copied or read or written to directly. A\n+ *  signer who is online throughout the whole process and can keep this\n+ *  structure in memory can use the provided API functions for a safe standard\n+ *  workflow.\n+ *\n+ *  Copying this data structure can result in nonce reuse which will leak the\n+ *  secret signing key.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_secnonce;\n+\n+/** Opaque data structure that holds a signer's public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. Serialized and parsed with\n+ *  `musig_pubnonce_serialize` and `musig_pubnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_pubnonce;\n+\n+/** Opaque data structure that holds an aggregate public nonce.\n+ *\n+ *  Guaranteed to be 132 bytes in size. Serialized and parsed with\n+ *  `musig_aggnonce_serialize` and `musig_aggnonce_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[132];\n+} secp256k1_musig_aggnonce;\n+\n+/** Opaque data structure that holds a MuSig session.\n+ *\n+ *  This structure is not required to be kept secret for the signing protocol to\n+ *  be secure. Guaranteed to be 133 bytes in size. No serialization and parsing\n+ *  functions (yet).\n+ */\n+typedef struct {\n+    unsigned char data[133];\n+} secp256k1_musig_session;\n+\n+/** Opaque data structure that holds a partial MuSig signature.\n+ *\n+ *  Guaranteed to be 36 bytes in size. Serialized and parsed with\n+ *  `musig_partial_sig_serialize` and `musig_partial_sig_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[36];\n+} secp256k1_musig_partial_sig;\n+\n+/** Parse a signer's public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_pubnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a signer's public nonce\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_pubnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_pubnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse an aggregate public nonce.\n+ *\n+ *  Returns: 1 when the nonce could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   nonce: pointer to a nonce object\n+ *  In:     in66: pointer to the 66-byte nonce to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_aggnonce *nonce,\n+    const unsigned char *in66\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an aggregate public nonce\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out66: pointer to a 66-byte array to store the serialized nonce\n+ *  In:    nonce: pointer to the nonce\n+ */\n+SECP256K1_API int secp256k1_musig_aggnonce_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out66,\n+    const secp256k1_musig_aggnonce *nonce\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a MuSig partial signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in32: pointer to the 32-byte signature to be parsed\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_musig_partial_sig *sig,\n+    const unsigned char *in32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a MuSig partial signature\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out32: pointer to a 32-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ */\n+SECP256K1_API int secp256k1_musig_partial_sig_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out32,\n+    const secp256k1_musig_partial_sig *sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Computes an aggregate public key and uses it to initialize a keyagg_cache\n+ *\n+ *  Different orders of `pubkeys` result in different `agg_pk`s.\n+ *\n+ *  Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`\n+ *  which ensures the same `agg_pk` result for the same multiset of pubkeys.\n+ *  This is useful to do before `pubkey_agg`, such that the order of pubkeys\n+ *  does not affect the aggregate public key.\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,\n+ *                    this arg can be NULL.\n+ *      keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that\n+ *                    is required for signing (or observing the signing session\n+ *                    and verifying partial signatures).\n+ *   In:     pubkeys: input array of pointers to public keys to aggregate. The order\n+ *                    is important; a different order will result in a different\n+ *                    aggregate public key.\n+ *         n_pubkeys: length of pubkeys array. Must be greater than 0.\n+ */\n+SECP256K1_API int secp256k1_musig_pubkey_agg(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *agg_pk,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const secp256k1_pubkey * const *pubkeys,\n+    size_t n_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(4);\n+\n+/** Obtain the aggregate public key from a keyagg_cache.\n+ *\n+ *  This is only useful if you need the non-xonly public key, in particular for\n+ *  plain (non-xonly) tweaking or batch-verifying multiple key aggregations\n+ *  (not implemented).\n+ *\n+ *  Returns: 0 if the arguments are invalid, 1 otherwise\n+ *  Args:        ctx: pointer to a context object\n+ *  Out:      agg_pk: the MuSig-aggregated public key.\n+ *  In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                    `musig_pubkey_agg`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_get(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *agg_pk,\n+    const secp256k1_musig_keyagg_cache *keyagg_cache\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Apply plain \"EC\" tweaking to a public key in a given keyagg_cache by adding\n+ *  the generator multiplied with `tweak32` to it. This is useful for deriving\n+ *  child keys from an aggregate public key via BIP 32 where `tweak32` is set to\n+ *  a hash as defined in BIP 32.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig (for example, by following BIP 32).\n+ *\n+ *  The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after\n+ *  the following pseudocode buf and buf2 have identical contents (absent\n+ *  earlier failures).\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)\n+ *  secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)\n+ *  secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)\n+ *  secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)\n+ *  secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:   output_pubkey: pointer to a public key to store the result. Will be set\n+ *                        to an invalid value if this function returns 0. If you\n+ *                        do not need it, this arg can be NULL.\n+ *  In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by\n+ *                       `musig_pubkey_agg`\n+ *  In:          tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                        according to `secp256k1_ec_seckey_verify`, this function\n+ *                        returns 0. For uniformly random 32-byte arrays the\n+ *                        chance of being invalid is negligible (around 1 in\n+ *                        2^128).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_musig_pubkey_ec_tweak_add(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    secp256k1_musig_keyagg_cache *keyagg_cache,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Apply x-only tweaking to a public key in a given keyagg_cache by adding the\n+ *  generator multiplied with `tweak32` to it. This is useful for creating\n+ *  Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP\n+ *  341.\n+ *\n+ *  Callers are responsible for deriving `tweak32` in a way that does not reduce\n+ *  the security of MuSig (for example, by following Taproot BIP 341).\n+ *\n+ *  The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in\n+ *  the following pseudocode xonly_pubkey_tweak_add_check (absent earlier\n+ *  failures) returns 1.\n+ *\n+ *  secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)\n+ *  secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)\n+ *  secp256k1_xonly_pubkey_serialize(..., buf, output_pk)\n+ *  secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)\n+ *\n+ *  This function is required if you want to _sign_ for a tweaked aggregate key.\n+ *  If you are only computing a public key but not intending to create a\n+ *  signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding",
      "path": "include/secp256k1_musig.h",
      "position": null,
      "original_position": 292,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781215749,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Correct, updated the description.",
      "created_at": "2024-10-07T08:41:52Z",
      "updated_at": "2024-10-07T08:41:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789783894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789783894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784187",
      "pull_request_review_id": 2351295582,
      "id": 1789784187,
      "node_id": "PRRC_kwDOAP4Jqs5qrfB7",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 441,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781434818,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't remember. `k[0] == k[1]` doesn't lead to invalid values in contrast to the case where `k[i] == 0` (public nonce would be the unserializable point at infinity). Maybe this was added for testing that `nonce_function_musig` correctly produces two different scalars, but this is now tested explicitly.",
      "created_at": "2024-10-07T08:42:04Z",
      "updated_at": "2024-10-07T08:42:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789784187",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784582",
      "pull_request_review_id": 2351296165,
      "id": 1789784582,
      "node_id": "PRRC_kwDOAP4Jqs5qrfIG",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": 450,
      "original_position": 448,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781469191,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why would variable time batch inversion not be acceptable here?\r\nWe could change the code to:\r\n\r\n```C\r\n  for (i = 0; i < 2; i++) {\r\n      secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptsj[i], &k[i]);\r\n      secp256k1_declassify(ctx, &nonce_ptsj[i], sizeof(nonce_ptsj));\r\n      secp256k1_scalar_clear(&k[i]);\r\n  }\r\n  secp256k1_ge_set_all_gej_var(nonce_pts, nonce_ptsj, 2);\r\n```",
      "created_at": "2024-10-07T08:42:19Z",
      "updated_at": "2024-10-07T08:42:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789784582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784799",
      "pull_request_review_id": 2351296473,
      "id": 1789784799,
      "node_id": "PRRC_kwDOAP4Jqs5qrfLf",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 546,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781469801,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-10-07T08:42:27Z",
      "updated_at": "2024-10-07T08:42:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789784799",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789784799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 546,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785142",
      "pull_request_review_id": 2351297033,
      "id": 1789785142,
      "node_id": "PRRC_kwDOAP4Jqs5qrfQ2",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pts);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+/* out_nonce = nonce_pts[0] + b*nonce_pts[1] */\n+static void secp256k1_effective_nonce(secp256k1_gej *out_nonce, const secp256k1_ge *nonce_pts, const secp256k1_scalar *b) {\n+    secp256k1_gej tmp;\n+\n+    secp256k1_gej_set_ge(&tmp, &nonce_pts[1]);\n+    secp256k1_ecmult(out_nonce, &tmp, b, NULL);\n+    secp256k1_gej_add_ge_var(out_nonce, out_nonce, &nonce_pts[0], NULL);\n+}\n+\n+static void secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce_pts, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce_pts, agg_pk32, msg);\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    /* fin_nonce = aggnonce_pts[0] + b*aggnonce_pts[1] */\n+    secp256k1_effective_nonce(&fin_nonce_ptj, aggnonce_pts, b);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pts[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pts, aggnonce)) {\n+        return 0;\n+    }\n+\n+    secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pts, agg_pk32, msg32);\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 705,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781482841,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looking at this again, I don't see an easy way to do this. Caching all coefficients would make the size of the cache dependent on the number of public keys aggregated. Right now, the cache is just a fixed size object.\r\n\r\nMaybe caching the MuSig coefficient is overkill:\r\n- If a signer doesn't verify partial signatures, caching all coefficients is unnecessary. They just need their own coefficient to sign. It would be possible to cache just that single coefficient, but that would require making key aggregation aware of who is going to sign with the cache later. This would be unnecessary in cases where key aggregation is done by a non-signer.\r\n- Computing the coefficient is essentially just `to_scalar(hash(32_byte_pks_hash, serialize_33(pk))`.",
      "created_at": "2024-10-07T08:42:41Z",
      "updated_at": "2024-10-07T08:42:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789785142",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 704,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785426",
      "pull_request_review_id": 2351297481,
      "id": 1789785426,
      "node_id": "PRRC_kwDOAP4Jqs5qrfVS",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>\n+\n+static int create_keypair_and_pk(secp256k1_keypair *keypair, secp256k1_pubkey *pk, const unsigned char *sk) {\n+    int ret;\n+    secp256k1_keypair keypair_tmp;\n+    ret = secp256k1_keypair_create(CTX, &keypair_tmp, sk);\n+    ret &= secp256k1_keypair_pub(CTX, pk, &keypair_tmp);\n+    if (keypair != NULL) {\n+        *keypair = keypair_tmp;\n+    }\n+    return ret;\n+}\n+\n+/* Just a simple (non-tweaked) 2-of-2 MuSig aggregate, sign, verify\n+ * test. */\n+static void musig_simple_test(void) {\n+    unsigned char sk[2][32];\n+    secp256k1_keypair keypair[2];\n+    secp256k1_musig_pubnonce pubnonce[2];\n+    const secp256k1_musig_pubnonce *pubnonce_ptr[2];\n+    secp256k1_musig_aggnonce aggnonce;\n+    unsigned char msg[32];\n+    secp256k1_xonly_pubkey agg_pk;\n+    secp256k1_musig_keyagg_cache keyagg_cache;\n+    unsigned char session_secrand[2][32];\n+    secp256k1_musig_secnonce secnonce[2];\n+    secp256k1_pubkey pk[2];\n+    const secp256k1_pubkey *pk_ptr[2];\n+    secp256k1_musig_partial_sig partial_sig[2];\n+    const secp256k1_musig_partial_sig *partial_sig_ptr[2];\n+    unsigned char final_sig[64];\n+    secp256k1_musig_session session;\n+    int i;\n+\n+    testrand256(msg);\n+    for (i = 0; i < 2; i++) {\n+        testrand256(sk[i]);\n+        pk_ptr[i] = &pk[i];\n+        pubnonce_ptr[i] = &pubnonce[i];\n+        partial_sig_ptr[i] = &partial_sig[i];\n+\n+        CHECK(create_keypair_and_pk(&keypair[i], &pk[i], sk[i]));\n+        if (i == 0) {\n+            testrand256(session_secrand[i]);\n+            CHECK(secp256k1_musig_nonce_gen(CTX, &secnonce[i], &pubnonce[i], session_secrand[i], sk[i], &pk[i], NULL, NULL, NULL) == 1);\n+        } else {\n+            uint64_t nonrepeating_cnt = 0;\n+            CHECK(secp256k1_musig_nonce_gen_counter(CTX, &secnonce[i], &pubnonce[i], nonrepeating_cnt, &keypair[i], NULL, NULL, NULL) == 1);\n+        }\n+    }\n+\n+    CHECK(secp256k1_musig_pubkey_agg(CTX, &agg_pk, &keyagg_cache, pk_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_agg(CTX, &aggnonce, pubnonce_ptr, 2) == 1);\n+    CHECK(secp256k1_musig_nonce_process(CTX, &session, &aggnonce, msg, &keyagg_cache) == 1);\n+\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_musig_partial_sign(CTX, &partial_sig[i], &secnonce[i], &keypair[i], &keyagg_cache, &session) == 1);\n+        CHECK(secp256k1_musig_partial_sig_verify(CTX, &partial_sig[i], &pubnonce[i], &pk[i], &keyagg_cache, &session) == 1);\n+    }\n+\n+    CHECK(secp256k1_musig_partial_sig_agg(CTX, final_sig, &session, partial_sig_ptr, 2) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(CTX, final_sig, msg, sizeof(msg), &agg_pk) == 1);\n+}\n+\n+static void pubnonce_summing_to_inf(secp256k1_musig_pubnonce *pubnonce) {",
      "path": "src/modules/musig/tests_impl.h",
      "position": 90,
      "original_position": 89,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781560625,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-10-07T08:42:52Z",
      "updated_at": "2024-10-07T08:42:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789785426",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785693",
      "pull_request_review_id": 2351297795,
      "id": 1789785693,
      "node_id": "PRRC_kwDOAP4Jqs5qrfZd",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_TESTS_IMPL_H\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"session.h\"\n+#include \"keyagg.h\"\n+#include \"../../scalar.h\"\n+#include \"../../field.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../util.h\"\n+\n+#include \"vectors.h\"\n+#include <inttypes.h>",
      "path": "src/modules/musig/tests_impl.h",
      "position": null,
      "original_position": 25,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781579367,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not needed (anymore). Removed.",
      "created_at": "2024-10-07T08:43:00Z",
      "updated_at": "2024-10-07T08:43:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1789785693",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1789785693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790068274",
      "pull_request_review_id": 2351713476,
      "id": 1790068274,
      "node_id": "PRRC_kwDOAP4Jqs5qskYy",
      "diff_hunk": "@@ -963,4 +963,21 @@ static void secp256k1_ge_from_bytes(secp256k1_ge *r, const unsigned char *buf) {\n     secp256k1_ge_from_storage(r, &s);\n }\n \n+static void secp256k1_ge_to_bytes_ext(unsigned char *data, const secp256k1_ge *ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(data, 0, 64);\n+    } else {\n+        secp256k1_ge_to_bytes(data, ge);\n+    }\n+}\n+\n+static void secp256k1_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data) {\n+    unsigned char zeros[64] = { 0 };",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "12835f80afbd761e198a22fbb01f4d83f72085e2",
      "in_reply_to_id": 1773447771,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: you did this, but in the \"wrong\" commit",
      "created_at": "2024-10-07T11:45:19Z",
      "updated_at": "2024-10-07T11:59:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1790068274",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790068274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790079414",
      "pull_request_review_id": 2351729234,
      "id": 1790079414,
      "node_id": "PRRC_kwDOAP4Jqs5qsnG2",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);",
      "path": "src/modules/musig/session_impl.h",
      "position": 450,
      "original_position": 448,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781469191,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When performing an EC multiplication *A = aG* for secret *a*, the resulting **affine** coordinates of *A* are presumed to not leak information about *a* (ECDLP), but the same is not necessarily true for the Jacobian coordinates that come out of our multiplication algorithm. So we shouldn't treat `nonce_ptj` as public here.",
      "created_at": "2024-10-07T11:52:59Z",
      "updated_at": "2024-10-07T11:53:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1790079414",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790079414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 450,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790081051",
      "pull_request_review_id": 2351731611,
      "id": 1790081051,
      "node_id": "PRRC_kwDOAP4Jqs5qsngb",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pts);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+/* out_nonce = nonce_pts[0] + b*nonce_pts[1] */\n+static void secp256k1_effective_nonce(secp256k1_gej *out_nonce, const secp256k1_ge *nonce_pts, const secp256k1_scalar *b) {\n+    secp256k1_gej tmp;\n+\n+    secp256k1_gej_set_ge(&tmp, &nonce_pts[1]);\n+    secp256k1_ecmult(out_nonce, &tmp, b, NULL);\n+    secp256k1_gej_add_ge_var(out_nonce, out_nonce, &nonce_pts[0], NULL);\n+}\n+\n+static void secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce_pts, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce_pts, agg_pk32, msg);\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    /* fin_nonce = aggnonce_pts[0] + b*aggnonce_pts[1] */\n+    secp256k1_effective_nonce(&fin_nonce_ptj, aggnonce_pts, b);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pts[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pts, aggnonce)) {\n+        return 0;\n+    }\n+\n+    secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pts, agg_pk32, msg32);\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 705,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781482841,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In that case, remove the TODO, or clarify the nuance?",
      "created_at": "2024-10-07T11:54:10Z",
      "updated_at": "2024-10-07T11:54:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1790081051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790081051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 704,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790294348",
      "pull_request_review_id": 2352059073,
      "id": 1790294348,
      "node_id": "PRRC_kwDOAP4Jqs5qtblM",
      "diff_hunk": "@@ -963,4 +963,21 @@ static void secp256k1_ge_from_bytes(secp256k1_ge *r, const unsigned char *buf) {\n     secp256k1_ge_from_storage(r, &s);\n }\n \n+static void secp256k1_ge_to_bytes_ext(unsigned char *data, const secp256k1_ge *ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(data, 0, 64);\n+    } else {\n+        secp256k1_ge_to_bytes(data, ge);\n+    }\n+}\n+\n+static void secp256k1_ge_from_bytes_ext(secp256k1_ge *ge, const unsigned char *data) {\n+    unsigned char zeros[64] = { 0 };",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "12835f80afbd761e198a22fbb01f4d83f72085e2",
      "in_reply_to_id": 1773447771,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-10-07T14:05:13Z",
      "updated_at": "2024-10-07T14:05:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1790294348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790294348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790294775",
      "pull_request_review_id": 2352059803,
      "id": 1790294775,
      "node_id": "PRRC_kwDOAP4Jqs5qtbr3",
      "diff_hunk": "@@ -0,0 +1,817 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+#define SECP256K1_MODULE_MUSIG_SESSION_IMPL_H\n+\n+#include <string.h>\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_musig.h\"\n+\n+#include \"keyagg.h\"\n+#include \"session.h\"\n+#include \"../../eckey.h\"\n+#include \"../../hash.h\"\n+#include \"../../scalar.h\"\n+#include \"../../util.h\"\n+\n+/* Outputs 33 zero bytes if the given group element is the point at infinity and\n+ * otherwise outputs the compressed serialization */\n+static void secp256k1_musig_ge_serialize_ext(unsigned char *out33, secp256k1_ge* ge) {\n+    if (secp256k1_ge_is_infinity(ge)) {\n+        memset(out33, 0, 33);\n+    } else {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(ge, out33, &size, 1);\n+#ifdef VERIFY\n+        /* Serialize must succeed because the point is not at infinity */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+}\n+\n+/* Outputs the point at infinity if the given byte array is all zero, otherwise\n+ * attempts to parse compressed point serialization. */\n+static int secp256k1_musig_ge_parse_ext(secp256k1_ge* ge, const unsigned char *in33) {\n+    unsigned char zeros[33] = { 0 };\n+\n+    if (secp256k1_memcmp_var(in33, zeros, sizeof(zeros)) == 0) {\n+        secp256k1_ge_set_infinity(ge);\n+        return 1;\n+    }\n+    return secp256k1_eckey_pubkey_parse(ge, in33, 33);\n+}\n+\n+static const unsigned char secp256k1_musig_secnonce_magic[4] = { 0x22, 0x0e, 0xdc, 0xf1 };\n+\n+static void secp256k1_musig_secnonce_save(secp256k1_musig_secnonce *secnonce, const secp256k1_scalar *k, const secp256k1_ge *pk) {\n+    memcpy(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4);\n+    secp256k1_scalar_get_b32(&secnonce->data[4], &k[0]);\n+    secp256k1_scalar_get_b32(&secnonce->data[36], &k[1]);\n+    secp256k1_ge_to_bytes(&secnonce->data[68], pk);\n+}\n+\n+static int secp256k1_musig_secnonce_load(const secp256k1_context* ctx, secp256k1_scalar *k, secp256k1_ge *pk, const secp256k1_musig_secnonce *secnonce) {\n+    int is_zero;\n+    ARG_CHECK(secp256k1_memcmp_var(&secnonce->data[0], secp256k1_musig_secnonce_magic, 4) == 0);\n+    /* We make very sure that the nonce isn't invalidated by checking the values\n+     * in addition to the magic. */\n+    is_zero = secp256k1_is_zero_array(&secnonce->data[4], 2 * 32);\n+    secp256k1_declassify(ctx, &is_zero, sizeof(is_zero));\n+    ARG_CHECK(!is_zero);\n+\n+    secp256k1_scalar_set_b32(&k[0], &secnonce->data[4], NULL);\n+    secp256k1_scalar_set_b32(&k[1], &secnonce->data[36], NULL);\n+    secp256k1_ge_from_bytes(pk, &secnonce->data[68]);\n+    return 1;\n+}\n+\n+/* If flag is true, invalidate the secnonce; otherwise leave it. Constant-time. */\n+static void secp256k1_musig_secnonce_invalidate(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, int flag) {\n+    secp256k1_memczero(secnonce->data, sizeof(secnonce->data), flag);\n+    /* The flag argument is usually classified. So, the line above makes the\n+     * magic and public key classified. However, we need both to be\n+     * declassified. Note that we don't declassify the entire object, because if\n+     * flag is 0, then k[0] and k[1] have not been zeroed. */\n+    secp256k1_declassify(ctx, secnonce->data, sizeof(secp256k1_musig_secnonce_magic));\n+    secp256k1_declassify(ctx, &secnonce->data[68], 64);\n+}\n+\n+static const unsigned char secp256k1_musig_pubnonce_magic[4] = { 0xf5, 0x7a, 0x3d, 0xa0 };\n+\n+/* Saves two group elements into a pubnonce. Requires that none of the provided\n+ * group elements is infinity. */\n+static void secp256k1_musig_pubnonce_save(secp256k1_musig_pubnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes(nonce->data + 4+64*i, &ges[i]);\n+    }\n+}\n+\n+/* Loads two group elements from a pubnonce. Returns 1 unless the nonce wasn't\n+ * properly initialized */\n+static int secp256k1_musig_pubnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_pubnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_pubnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes(&ges[i], nonce->data + 4 + 64*i);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_aggnonce_magic[4] = { 0xa8, 0xb7, 0xe4, 0x67 };\n+\n+static void secp256k1_musig_aggnonce_save(secp256k1_musig_aggnonce* nonce, const secp256k1_ge* ges) {\n+    int i;\n+    memcpy(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_to_bytes_ext(&nonce->data[4 + 64*i], &ges[i]);\n+    }\n+}\n+\n+static int secp256k1_musig_aggnonce_load(const secp256k1_context* ctx, secp256k1_ge* ges, const secp256k1_musig_aggnonce* nonce) {\n+    int i;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&nonce->data[0], secp256k1_musig_aggnonce_magic, 4) == 0);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_from_bytes_ext(&ges[i], &nonce->data[4 + 64*i]);\n+    }\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_session_cache_magic[4] = { 0x9d, 0xed, 0xe9, 0x17 };\n+\n+/* A session consists of\n+ * - 4 byte session cache magic\n+ * - 1 byte the parity of the final nonce\n+ * - 32 byte serialized x-only final nonce\n+ * - 32 byte nonce coefficient b\n+ * - 32 byte signature challenge hash e\n+ * - 32 byte scalar s that is added to the partial signatures of the signers\n+ */\n+static void secp256k1_musig_session_save(secp256k1_musig_session *session, const secp256k1_musig_session_internal *session_i) {\n+    unsigned char *ptr = session->data;\n+\n+    memcpy(ptr, secp256k1_musig_session_cache_magic, 4);\n+    ptr += 4;\n+    *ptr = session_i->fin_nonce_parity;\n+    ptr += 1;\n+    memcpy(ptr, session_i->fin_nonce, 32);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->noncecoef);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->challenge);\n+    ptr += 32;\n+    secp256k1_scalar_get_b32(ptr, &session_i->s_part);\n+}\n+\n+static int secp256k1_musig_session_load(const secp256k1_context* ctx, secp256k1_musig_session_internal *session_i, const secp256k1_musig_session *session) {\n+    const unsigned char *ptr = session->data;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(ptr, secp256k1_musig_session_cache_magic, 4) == 0);\n+    ptr += 4;\n+    session_i->fin_nonce_parity = *ptr;\n+    ptr += 1;\n+    memcpy(session_i->fin_nonce, ptr, 32);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->noncecoef, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->challenge, ptr, NULL);\n+    ptr += 32;\n+    secp256k1_scalar_set_b32(&session_i->s_part, ptr, NULL);\n+    return 1;\n+}\n+\n+static const unsigned char secp256k1_musig_partial_sig_magic[4] = { 0xeb, 0xfb, 0x1a, 0x32 };\n+\n+static void secp256k1_musig_partial_sig_save(secp256k1_musig_partial_sig* sig, secp256k1_scalar *s) {\n+    memcpy(&sig->data[0], secp256k1_musig_partial_sig_magic, 4);\n+    secp256k1_scalar_get_b32(&sig->data[4], s);\n+}\n+\n+static int secp256k1_musig_partial_sig_load(const secp256k1_context* ctx, secp256k1_scalar *s, const secp256k1_musig_partial_sig* sig) {\n+    int overflow;\n+\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+    secp256k1_scalar_set_b32(s, &sig->data[4], &overflow);\n+    /* Parsed signatures can not overflow */\n+    VERIFY_CHECK(!overflow);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_parse(const secp256k1_context* ctx, secp256k1_musig_pubnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_eckey_pubkey_parse(&ges[i], &in66[33*i], 33)) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_is_in_correct_subgroup(&ges[i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_pubnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_pubnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_pubnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_pubnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        int ret;\n+        size_t size = 33;\n+        ret = secp256k1_eckey_pubkey_serialize(&ges[i], &out66[33*i], &size, 1);\n+#ifdef VERIFY\n+        /* serialize must succeed because the point was just loaded */\n+        VERIFY_CHECK(ret && size == 33);\n+#else\n+        (void) ret;\n+#endif\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_parse(const secp256k1_context* ctx, secp256k1_musig_aggnonce* nonce, const unsigned char *in66) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(nonce != NULL);\n+    ARG_CHECK(in66 != NULL);\n+\n+    for (i = 0; i < 2; i++) {\n+        if (!secp256k1_musig_ge_parse_ext(&ges[i], &in66[33*i])) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_musig_aggnonce_save(nonce, ges);\n+    return 1;\n+}\n+\n+int secp256k1_musig_aggnonce_serialize(const secp256k1_context* ctx, unsigned char *out66, const secp256k1_musig_aggnonce* nonce) {\n+    secp256k1_ge ges[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out66 != NULL);\n+    memset(out66, 0, 66);\n+    ARG_CHECK(nonce != NULL);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, ges, nonce)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(&out66[33*i], &ges[i]);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_parse(const secp256k1_context* ctx, secp256k1_musig_partial_sig* sig, const unsigned char *in32) {\n+    secp256k1_scalar tmp;\n+    int overflow;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in32 != NULL);\n+\n+    /* Ensure that using the signature will fail if parsing fails (and the user\n+     * doesn't check the return value). */\n+    memset(sig, 0, sizeof(*sig));\n+\n+    secp256k1_scalar_set_b32(&tmp, in32, &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_musig_partial_sig_save(sig, &tmp);\n+    return 1;\n+}\n+\n+int secp256k1_musig_partial_sig_serialize(const secp256k1_context* ctx, unsigned char *out32, const secp256k1_musig_partial_sig* sig) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out32 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&sig->data[0], secp256k1_musig_partial_sig_magic, 4) == 0);\n+\n+    memcpy(out32, &sig->data[4], 32);\n+    return 1;\n+}\n+\n+/* Write optional inputs into the hash */\n+static void secp256k1_nonce_function_musig_helper(secp256k1_sha256 *sha, unsigned int prefix_size, const unsigned char *data, unsigned char len) {\n+    unsigned char zero[7] = { 0 };\n+    /* The spec requires length prefixes to be between 1 and 8 bytes\n+     * (inclusive) */\n+    VERIFY_CHECK(prefix_size >= 1 && prefix_size <= 8);\n+    /* Since the length of all input data fits in a byte, we can always pad the\n+     * length prefix with prefix_size - 1 zero bytes. */\n+    secp256k1_sha256_write(sha, zero, prefix_size - 1);\n+    if (data != NULL) {\n+        secp256k1_sha256_write(sha, &len, 1);\n+        secp256k1_sha256_write(sha, data, len);\n+    } else {\n+        len = 0;\n+        secp256k1_sha256_write(sha, &len, 1);\n+    }\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/aux\")||SHA256(\"MuSig/aux\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa19e884bul;\n+    sha->s[1] = 0xf463fe7eul;\n+    sha->s[2] = 0x2f18f9a2ul;\n+    sha->s[3] = 0xbeb0f9fful;\n+    sha->s[4] = 0x0f37e8b0ul;\n+    sha->s[5] = 0x06ebd26ful;\n+    sha->s[6] = 0xe3b243d2ul;\n+    sha->s[7] = 0x522fb150ul;\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/nonce\")||SHA256(\"MuSig/nonce\"). */\n+static void secp256k1_nonce_function_musig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x07101b64ul;\n+    sha->s[1] = 0x18003414ul;\n+    sha->s[2] = 0x0391bc43ul;\n+    sha->s[3] = 0x0e6258eeul;\n+    sha->s[4] = 0x29d26b72ul;\n+    sha->s[5] = 0x8343937eul;\n+    sha->s[6] = 0xb7a0a4fbul;\n+    sha->s[7] = 0xff568a30ul;\n+    sha->bytes = 64;\n+}\n+\n+static void secp256k1_nonce_function_musig(secp256k1_scalar *k, const unsigned char *session_secrand, const unsigned char *msg32, const unsigned char *seckey32, const unsigned char *pk33, const unsigned char *agg_pk32, const unsigned char *extra_input32) {\n+    secp256k1_sha256 sha;\n+    unsigned char rand[32];\n+    unsigned char i;\n+    unsigned char msg_present;\n+\n+    if (seckey32 != NULL) {\n+        secp256k1_nonce_function_musig_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, session_secrand, 32);\n+        secp256k1_sha256_finalize(&sha, rand);\n+        for (i = 0; i < 32; i++) {\n+            rand[i] ^= seckey32[i];\n+        }\n+    } else {\n+        memcpy(rand, session_secrand, sizeof(rand));\n+    }\n+\n+    secp256k1_nonce_function_musig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, rand, sizeof(rand));\n+    secp256k1_nonce_function_musig_helper(&sha, 1, pk33, 33);\n+    secp256k1_nonce_function_musig_helper(&sha, 1, agg_pk32, 32);\n+    msg_present = msg32 != NULL;\n+    secp256k1_sha256_write(&sha, &msg_present, 1);\n+    if (msg_present) {\n+        secp256k1_nonce_function_musig_helper(&sha, 8, msg32, 32);\n+    }\n+    secp256k1_nonce_function_musig_helper(&sha, 4, extra_input32, 32);\n+\n+    for (i = 0; i < 2; i++) {\n+        unsigned char buf[32];\n+        secp256k1_sha256 sha_tmp = sha;\n+        secp256k1_sha256_write(&sha_tmp, &i, 1);\n+        secp256k1_sha256_finalize(&sha_tmp, buf);\n+        secp256k1_scalar_set_b32(&k[i], buf, NULL);\n+\n+        /* Attempt to erase secret data */\n+        memset(buf, 0, sizeof(buf));\n+        memset(&sha_tmp, 0, sizeof(sha_tmp));\n+    }\n+    memset(rand, 0, sizeof(rand));\n+    memset(&sha, 0, sizeof(sha));\n+}\n+\n+int secp256k1_musig_nonce_gen_internal(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, const unsigned char *input_nonce, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    secp256k1_scalar k[2];\n+    secp256k1_ge nonce_pts[2];\n+    int i;\n+    unsigned char pk_ser[33];\n+    size_t pk_ser_len = sizeof(pk_ser);\n+    unsigned char aggpk_ser[32];\n+    unsigned char *aggpk_ser_ptr = NULL;\n+    secp256k1_ge pk;\n+    int pk_serialize_success;\n+    int ret = 1;\n+\n+    ARG_CHECK(pubnonce != NULL);\n+    memset(pubnonce, 0, sizeof(*pubnonce));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+\n+    /* Check that the seckey is valid to be able to sign for it later. */\n+    if (seckey != NULL) {\n+        secp256k1_scalar sk;\n+        ret &= secp256k1_scalar_set_b32_seckey(&sk, seckey);\n+        secp256k1_scalar_clear(&sk);\n+    }\n+\n+    if (keyagg_cache != NULL) {\n+        secp256k1_keyagg_cache_internal cache_i;\n+        if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+            return 0;\n+        }\n+        /* The loaded point cache_i.pk can not be the point at infinity. */\n+        secp256k1_fe_get_b32(aggpk_ser, &cache_i.pk.x);\n+        aggpk_ser_ptr = aggpk_ser;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    pk_serialize_success = secp256k1_eckey_pubkey_serialize(&pk, pk_ser, &pk_ser_len, 1);\n+\n+#ifdef VERIFY\n+    /* A pubkey cannot be the point at infinity */\n+    VERIFY_CHECK(pk_serialize_success);\n+    VERIFY_CHECK(pk_ser_len == sizeof(pk_ser));\n+#else\n+    (void) pk_serialize_success;\n+#endif\n+\n+    secp256k1_nonce_function_musig(k, input_nonce, msg32, seckey, pk_ser, aggpk_ser_ptr, extra_input32);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[0]));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(&k[1]));\n+    VERIFY_CHECK(!secp256k1_scalar_eq(&k[0], &k[1]));\n+    secp256k1_musig_secnonce_save(secnonce, k, &pk);\n+    secp256k1_musig_secnonce_invalidate(ctx, secnonce, !ret);\n+\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_gej nonce_ptj;\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &nonce_ptj, &k[i]);\n+        secp256k1_ge_set_gej(&nonce_pts[i], &nonce_ptj);\n+        secp256k1_declassify(ctx, &nonce_pts[i], sizeof(nonce_pts));\n+        secp256k1_scalar_clear(&k[i]);\n+    }\n+    /* None of the nonce_pts will be infinity because k != 0 with overwhelming\n+     * probability */\n+    secp256k1_musig_pubnonce_save(pubnonce, nonce_pts);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const secp256k1_pubkey *pubkey, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(session_secrand32 != NULL);\n+\n+    /* Check in constant time that the session_secrand32 is not 0 as a\n+     * defense-in-depth measure that may protect against a faulty RNG. */\n+    ret &= !secp256k1_is_zero_array(session_secrand32, 32);\n+\n+    /* We can declassify because branching on ret is only relevant when this\n+     * function called with an invalid session_secrand32 argument */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret == 0) {\n+        secp256k1_musig_secnonce_invalidate(ctx, secnonce, 1);\n+        return 0;\n+    }\n+\n+    ret &= secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, session_secrand32, seckey, pubkey, msg32, keyagg_cache, extra_input32);\n+\n+    /* Set the session_secrand32 buffer to zero to prevent the caller from using\n+     * nonce_gen multiple times with the same buffer. */\n+    secp256k1_memczero(session_secrand32, 32, ret);\n+    return ret;\n+}\n+\n+int secp256k1_musig_nonce_gen_counter(const secp256k1_context* ctx, secp256k1_musig_secnonce *secnonce, secp256k1_musig_pubnonce *pubnonce, uint64_t nonrepeating_cnt, const secp256k1_keypair *keypair, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache, const unsigned char *extra_input32) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char seckey[32];\n+    secp256k1_pubkey pubkey;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secnonce != NULL);\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    ARG_CHECK(keypair != NULL);\n+\n+    secp256k1_write_be64(buf, nonrepeating_cnt);\n+    /* keypair_sec and keypair_pub do not fail if the arguments are not NULL */\n+    ret = secp256k1_keypair_sec(ctx, seckey, keypair);\n+    VERIFY_CHECK(ret);\n+    ret = secp256k1_keypair_pub(ctx, &pubkey, keypair);\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+\n+    if (!secp256k1_musig_nonce_gen_internal(ctx, secnonce, pubnonce, buf, seckey, &pubkey, msg32, keyagg_cache, extra_input32)) {\n+        return 0;\n+    }\n+    memset(seckey, 0, sizeof(seckey));\n+    return 1;\n+}\n+\n+static int secp256k1_musig_sum_pubnonces(const secp256k1_context* ctx, secp256k1_gej *summed_pubnonces, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    size_t i;\n+    int j;\n+\n+    secp256k1_gej_set_infinity(&summed_pubnonces[0]);\n+    secp256k1_gej_set_infinity(&summed_pubnonces[1]);\n+\n+    for (i = 0; i < n_pubnonces; i++) {\n+        secp256k1_ge nonce_pts[2];\n+        if (!secp256k1_musig_pubnonce_load(ctx, nonce_pts, pubnonces[i])) {\n+            return 0;\n+        }\n+        for (j = 0; j < 2; j++) {\n+            secp256k1_gej_add_ge_var(&summed_pubnonces[j], &summed_pubnonces[j], &nonce_pts[j], NULL);\n+        }\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_musig_nonce_agg(const secp256k1_context* ctx, secp256k1_musig_aggnonce  *aggnonce, const secp256k1_musig_pubnonce * const* pubnonces, size_t n_pubnonces) {\n+    secp256k1_gej aggnonce_ptsj[2];\n+    secp256k1_ge aggnonce_pts[2];\n+    int i;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(pubnonces != NULL);\n+    ARG_CHECK(n_pubnonces > 0);\n+\n+    if (!secp256k1_musig_sum_pubnonces(ctx, aggnonce_ptsj, pubnonces, n_pubnonces)) {\n+        return 0;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_ge_set_gej(&aggnonce_pts[i], &aggnonce_ptsj[i]);\n+    }\n+    secp256k1_musig_aggnonce_save(aggnonce, aggnonce_pts);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"MuSig/noncecoef\")||SHA256(\"MuSig/noncecoef\"). */\n+static void secp256k1_musig_compute_noncehash_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x2c7d5a45ul;\n+    sha->s[1] = 0x06bf7e53ul;\n+    sha->s[2] = 0x89be68a6ul;\n+    sha->s[3] = 0x971254c0ul;\n+    sha->s[4] = 0x60ac12d2ul;\n+    sha->s[5] = 0x72846dcdul;\n+    sha->s[6] = 0x6c81212ful;\n+    sha->s[7] = 0xde7a2500ul;\n+    sha->bytes = 64;\n+}\n+\n+/* tagged_hash(aggnonce[0], aggnonce[1], agg_pk, msg) */\n+static void secp256k1_musig_compute_noncehash(unsigned char *noncehash, secp256k1_ge *aggnonce, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char buf[33];\n+    secp256k1_sha256 sha;\n+    int i;\n+\n+    secp256k1_musig_compute_noncehash_sha256_tagged(&sha);\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_musig_ge_serialize_ext(buf, &aggnonce[i]);\n+        secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    }\n+    secp256k1_sha256_write(&sha, agg_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg, 32);\n+    secp256k1_sha256_finalize(&sha, noncehash);\n+}\n+\n+/* out_nonce = nonce_pts[0] + b*nonce_pts[1] */\n+static void secp256k1_effective_nonce(secp256k1_gej *out_nonce, const secp256k1_ge *nonce_pts, const secp256k1_scalar *b) {\n+    secp256k1_gej tmp;\n+\n+    secp256k1_gej_set_ge(&tmp, &nonce_pts[1]);\n+    secp256k1_ecmult(out_nonce, &tmp, b, NULL);\n+    secp256k1_gej_add_ge_var(out_nonce, out_nonce, &nonce_pts[0], NULL);\n+}\n+\n+static void secp256k1_musig_nonce_process_internal(int *fin_nonce_parity, unsigned char *fin_nonce, secp256k1_scalar *b, secp256k1_ge *aggnonce_pts, const unsigned char *agg_pk32, const unsigned char *msg) {\n+    unsigned char noncehash[32];\n+    secp256k1_ge fin_nonce_pt;\n+    secp256k1_gej fin_nonce_ptj;\n+\n+    secp256k1_musig_compute_noncehash(noncehash, aggnonce_pts, agg_pk32, msg);\n+    secp256k1_scalar_set_b32(b, noncehash, NULL);\n+    /* fin_nonce = aggnonce_pts[0] + b*aggnonce_pts[1] */\n+    secp256k1_effective_nonce(&fin_nonce_ptj, aggnonce_pts, b);\n+    secp256k1_ge_set_gej(&fin_nonce_pt, &fin_nonce_ptj);\n+    if (secp256k1_ge_is_infinity(&fin_nonce_pt)) {\n+        fin_nonce_pt = secp256k1_ge_const_g;\n+    }\n+    /* fin_nonce_pt is not the point at infinity */\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.x);\n+    secp256k1_fe_get_b32(fin_nonce, &fin_nonce_pt.x);\n+    secp256k1_fe_normalize_var(&fin_nonce_pt.y);\n+    *fin_nonce_parity = secp256k1_fe_is_odd(&fin_nonce_pt.y);\n+}\n+\n+int secp256k1_musig_nonce_process(const secp256k1_context* ctx, secp256k1_musig_session *session, const secp256k1_musig_aggnonce  *aggnonce, const unsigned char *msg32, const secp256k1_musig_keyagg_cache *keyagg_cache) {\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_ge aggnonce_pts[2];\n+    unsigned char fin_nonce[32];\n+    secp256k1_musig_session_internal session_i;\n+    unsigned char agg_pk32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(session != NULL);\n+    ARG_CHECK(aggnonce != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(agg_pk32, &cache_i.pk.x);\n+\n+    if (!secp256k1_musig_aggnonce_load(ctx, aggnonce_pts, aggnonce)) {\n+        return 0;\n+    }\n+\n+    secp256k1_musig_nonce_process_internal(&session_i.fin_nonce_parity, fin_nonce, &session_i.noncecoef, aggnonce_pts, agg_pk32, msg32);\n+    secp256k1_schnorrsig_challenge(&session_i.challenge, fin_nonce, msg32, 32, agg_pk32);\n+\n+    /* If there is a tweak then set `challenge` times `tweak` to the `s`-part.*/\n+    secp256k1_scalar_set_int(&session_i.s_part, 0);\n+    if (!secp256k1_scalar_is_zero(&cache_i.tweak)) {\n+        secp256k1_scalar e_tmp;\n+        secp256k1_scalar_mul(&e_tmp, &session_i.challenge, &cache_i.tweak);\n+        if (secp256k1_fe_is_odd(&cache_i.pk.y)) {\n+            secp256k1_scalar_negate(&e_tmp, &e_tmp);\n+        }\n+        session_i.s_part = e_tmp;\n+    }\n+    memcpy(session_i.fin_nonce, fin_nonce, sizeof(session_i.fin_nonce));\n+    secp256k1_musig_session_save(session, &session_i);\n+    return 1;\n+}\n+\n+static void secp256k1_musig_partial_sign_clear(secp256k1_scalar *sk, secp256k1_scalar *k) {\n+    secp256k1_scalar_clear(sk);\n+    secp256k1_scalar_clear(&k[0]);\n+    secp256k1_scalar_clear(&k[1]);\n+}\n+\n+int secp256k1_musig_partial_sign(const secp256k1_context* ctx, secp256k1_musig_partial_sig *partial_sig, secp256k1_musig_secnonce *secnonce, const secp256k1_keypair *keypair, const secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_musig_session *session) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk, keypair_pk;\n+    secp256k1_scalar k[2];\n+    secp256k1_scalar mu, s;\n+    secp256k1_keyagg_cache_internal cache_i;\n+    secp256k1_musig_session_internal session_i;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    ARG_CHECK(secnonce != NULL);\n+    /* Fails if the magic doesn't match */\n+    ret = secp256k1_musig_secnonce_load(ctx, k, &pk, secnonce);\n+    /* Set nonce to zero to avoid nonce reuse. This will cause subsequent calls\n+     * of this function to fail */\n+    memset(secnonce, 0, sizeof(*secnonce));\n+    if (!ret) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    ARG_CHECK(partial_sig != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(keyagg_cache != NULL);\n+    ARG_CHECK(session != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, &sk, &keypair_pk, keypair)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+    ARG_CHECK(secp256k1_fe_equal(&pk.x, &keypair_pk.x)\n+              && secp256k1_fe_equal(&pk.y, &keypair_pk.y));\n+    if (!secp256k1_keyagg_cache_load(ctx, &cache_i, keyagg_cache)) {\n+        secp256k1_musig_partial_sign_clear(&sk, k);\n+        return 0;\n+    }\n+\n+    /* Negate sk if secp256k1_fe_is_odd(&cache_i.pk.y)) XOR cache_i.parity_acc.\n+     * This corresponds to the line \"Let d = g⋅gacc⋅d' mod n\" in the\n+     * specification. */\n+    if ((secp256k1_fe_is_odd(&cache_i.pk.y)\n+         != cache_i.parity_acc)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    /* Multiply KeyAgg coefficient */\n+    /* TODO Cache mu */",
      "path": "src/modules/musig/session_impl.h",
      "position": null,
      "original_position": 705,
      "commit_id": "168c92011f5ddae8d7fe28d166b68f126459548a",
      "original_commit_id": "6f496a0d5fb2be2fa872acc62d88957d0d7dbd50",
      "in_reply_to_id": 1781482841,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed the TODO",
      "created_at": "2024-10-07T14:05:29Z",
      "updated_at": "2024-10-07T14:05:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1479#discussion_r1790294775",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1790294775"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1479"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 704,
      "side": "RIGHT"
    }
  ]
}